<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="hanx の 碎片栈" type="application/atom+xml" />






<meta name="description" content="向死而生">
<meta property="og:type" content="website">
<meta property="og:title" content="hanx の 碎片栈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="hanx の 碎片栈">
<meta property="og:description" content="向死而生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hanx の 碎片栈">
<meta name="twitter:description" content="向死而生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e7cd7543c04aa55f06761709bc920324";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  <link rel="canonical" href="http://yoursite.com/"/>





  <title>hanx の 碎片栈</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hanx の 碎片栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Time waits for no one</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/理解JavaScript碰撞检测算法核心简单实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/理解JavaScript碰撞检测算法核心简单实现原理/" itemprop="url">理解JavaScript碰撞检测算法核心简单实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T17:00:16+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>碰撞检测在前端游戏，设计拖拽的实用业务等领域的应用场景非常广泛，今天我们就在这里对于前端JavaScript如何实现碰撞检测算法进行一个原理上的探讨，让大家能够明白如何实现碰撞以及碰撞的理念是什么：</p>
<h3 id="矩形与矩形间的碰撞"><a href="#矩形与矩形间的碰撞" class="headerlink" title="矩形与矩形间的碰撞"></a>矩形与矩形间的碰撞</h3><p>核心理念<br>判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。大体实现方式就是以一个矩形的某个定点作为运动物，计算自己的坐上顶点与另一元素的左上定点的位置和宽高数据进行判断检测<br>通用算法判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(react1.offsetLeft&lt;react2.offsetLeft+react2.offsetWidth&amp;&amp;</div><div class="line">   react1.offsetLeft+react1.offsetWidth&gt;react2.offsetLeft&amp;&amp;</div><div class="line">   react1.offsetTop&lt;react2.offsetTop+react2.offsetHeight&amp;&amp;</div><div class="line">   react1.offsetHeight+react1.offsetTop&gt;react2.offsetTop</div><div class="line">)&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'碰撞成功'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下：图中的 x 既是 offsetLeft , y 既是 offsetTop；矩形的宽和高既是 offsetWidth 、offsetHeight </p>
<p><img src="/img/bVbesmo.jpg" alt="这里写图片描述"></p>
<h3 id="圆形与圆形的碰撞"><a href="#圆形与圆形的碰撞" class="headerlink" title="圆形与圆形的碰撞"></a>圆形与圆形的碰撞</h3><p>核心理念<br>通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。<br>通用算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|AB|=<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(x1-x2,<span class="number">2</span>)+<span class="built_in">Math</span>.pow(y1-y2,<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>概念模型</p>
<p><img src="/img/bVbesmu.jpg" alt="这里写图片描述"></p>
<h3 id="圆形与矩形之间的碰撞"><a href="#圆形与矩形之间的碰撞" class="headerlink" title="圆形与矩形之间的碰撞"></a>圆形与矩形之间的碰撞</h3><p>核心理念<br>通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。改点的位置可以通过获取矩形左上角的坐标位置和元素的宽高来进行数据计算。<br>通用算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> distance=<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(closestPoint.x-x1,<span class="number">2</span>)+<span class="built_in">Math</span>.pow(closestPoint.y-y1,<span class="number">2</span>));</div><div class="line"><span class="keyword">if</span>(distance&lt;r1)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'碰撞成功'</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'没碰到'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>概念模型<br><img src="/img/bVbesmz.jpg" alt="这里写图片描述"></p>
<h3 id="圆形与矩形之间的碰撞-1"><a href="#圆形与矩形之间的碰撞-1" class="headerlink" title="圆形与矩形之间的碰撞"></a>圆形与矩形之间的碰撞</h3><p>核心理念<br>通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。改点的位置可以通过获取矩形左上角的坐标位置和元素的宽高来进行数据计算。<br>通用算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> distance=<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(closestPoint.x-x1,<span class="number">2</span>)+<span class="built_in">Math</span>.pow(closestPoint.y-y1,<span class="number">2</span>));</div><div class="line"><span class="keyword">if</span>(distance&lt;r1)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'碰撞成功'</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'没碰到'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>概念模型 </p>
<p><img src="/img/bVbes43mz.jpg" alt="这里写图片描述"></p>
<h3 id="圆形与旋转矩形之间的碰撞"><a href="#圆形与旋转矩形之间的碰撞" class="headerlink" title="圆形与旋转矩形之间的碰撞"></a>圆形与旋转矩形之间的碰撞</h3><p>核心理念<br>即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。但是矩形的边缘坐标需要进行一个数据转换，通过这个旋转的角度值计算转换后的位置<br>通用算法（同上）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> distance=<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(closestPoint.x-x1,<span class="number">2</span>)+<span class="built_in">Math</span>.pow(closestPoint.y-y1,<span class="number">2</span>));</div><div class="line"><span class="keyword">if</span>(distance&lt;r1)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'碰撞成功'</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'没碰到'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>概念模型 </p>
<p><img src="/img/bVbesmG.jpg" alt="这里写图片描述"></p>
<h3 id="矩形与障碍物之间的碰撞（地图碰撞算法）"><a href="#矩形与障碍物之间的碰撞（地图碰撞算法）" class="headerlink" title="矩形与障碍物之间的碰撞（地图碰撞算法）"></a>矩形与障碍物之间的碰撞（地图碰撞算法）</h3><p>核心理念<br>将整个地图进行数据化，划分为一个矩形的地图，地图的每个基本单位是一个矩形区域。地图中所有可能参与碰撞的物体都要是基本单位大小的整数倍，地图中参与检测的对象都存储着自身所在格子的坐标，两个物体在同一格才为碰撞。<br>通用算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//标记为0的可以通过，1的不可以通过既是障碍物</span></div><div class="line"><span class="keyword">var</span> map=[</div><div class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</div><div class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</div><div class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</div><div class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</div><div class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</div><div class="line">]</div><div class="line"><span class="comment">//设置角色的初始位置</span></div><div class="line">player=&#123;<span class="attr">left</span>:<span class="number">2</span>,<span class="attr">top</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="comment">//下面就要用到A*寻路算法进行判断检测碰撞了</span></div><div class="line">......</div></pre></td></tr></table></figure>
<p>概念模型</p>
<p><img src="/img/bVbesmI.jpg" alt="这里写图片描述"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/从 1 到完美，用 js 和 electron 写一个桌面应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/从 1 到完美，用 js 和 electron 写一个桌面应用/" itemprop="url">从 1 到完美，用 js 和 electron 写一个桌面应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T17:00:16+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前用 js 和前端技术写桌面软件的方案主要有两种：electron 和 nw.js。这两者在底层实现上有所不同，简单的说，electron 是 node + chromium，nw.js 是 node + webkit。从使用上来说，electron 的使用更为广泛，社区也更活跃，有一大批成熟的商用软件，像 vscode, atom等。所以，现在一般推荐使用 electron 来写桌面软件。</p>
<h3 id="选择合适的组件库和工具库"><a href="#选择合适的组件库和工具库" class="headerlink" title="选择合适的组件库和工具库"></a>选择合适的组件库和工具库</h3><p>electron 社区多年的积累，已经有很多成熟的第三方组建库和工具库帮助你轻松的构建桌面应用，提高开发效率，避免重复造轮子。</p>
<p>组件库是用来帮助你书写程序的逻辑或者UI：</p>
<ul>
<li>electron-store: 保存应用数据，比如数据缓存，应用配置等</li>
<li>electron-context-menu: 创建右键菜单功能</li>
<li>menubar: 创建状态栏视图</li>
<li>photon: 一套快捷的组件库</li>
<li>electron-log: 日志记录</li>
</ul>
<p>工具库是用来帮助你构建程序：</p>
<ul>
<li>electron-builder: 创建应用的安装文件(win: exe, linux: deb, mac: dmg 等)</li>
<li>devtron: 官方的 chromium DevTools 插件</li>
<li>electron-packager: 把应用打包成一个可运行文件(win: exe, linux: deb, mac: dmg 等，非安装文件)</li>
<li>spectron: electron 应用的测试工具</li>
<li>electron-devtools-installer: 确保 electron 开发相关的 chromium DevTools 插件的安装</li>
</ul>
<p>更多可以参考 <a href="https://electronjs.org/community" target="_blank" rel="external">electron community.</a></p>
<h3 id="选择合适的模板"><a href="#选择合适的模板" class="headerlink" title="选择合适的模板"></a>选择合适的模板</h3><p>社区有很多现成的模板，里面封装好了各种工具，打包成应用，创建安装文件等一系列功能，使用者只需要关注怎么编写应用，而不需要关心工具及各个命令的实现及原理。</p>
<ul>
<li>electron-react-boilerplate: electron + react + redux</li>
<li>electron-vue: electron + vue</li>
<li>electron-boilerplate: electron</li>
</ul>
<p>更多可以参考 <a href="https://github.com/search?o=desc&amp;q=electron+boilerplate&amp;s=stars&amp;type=Repositories" target="_blank" rel="external">https://github.com/search?o=desc&amp;q=electron+boilerplate&amp;s=stars&amp;type=Repositories</a>.</p>
<p>如果你需要扩展功能，可以更改相关的配置文件。</p>
<h3 id="开发应用与运行命令"><a href="#开发应用与运行命令" class="headerlink" title="开发应用与运行命令"></a>开发应用与运行命令</h3><p>以 electron-react-boilerplate 为例。</p>
<p>web部分是以 react + redux + react-router + redux-thunk + react-redux，构建工具部分是以 webpack + babel + eslint + stylelint + prettier + flow + enzyme</p>
<p>另外，它封装了开发工具主要为以下几个命令：</p>
<h4 id="dev-开发调试命令"><a href="#dev-开发调试命令" class="headerlink" title="dev 开发调试命令"></a>dev 开发调试命令</h4><blockquote>
<p>npm run dev</p>
</blockquote>
<p>这个命令将会运行一个 electron 应用实例，然后在本地开启一个本地 server 服务，当你编写渲染进程代码，本地 server 服务会自动刷新页面，而不需要关闭应用重新运行命令。</p>
<h4 id="start-以发布模式启动应用"><a href="#start-以发布模式启动应用" class="headerlink" title="start 以发布模式启动应用"></a>start 以发布模式启动应用</h4><blockquote>
<p>npm run start</p>
</blockquote>
<p>与开发调试命令不同的是，它不会开起本地 server 服务，也不会监听文件变动，而是会像发布的应用一样运行。这个一般在发布之前运行，查看应用的运行情况。</p>
<h4 id="package-打包应用为安装文件"><a href="#package-打包应用为安装文件" class="headerlink" title="package 打包应用为安装文件"></a>package 打包应用为安装文件</h4><blockquote>
<h1 id="create-installer-for-linux-amp-win-amp-mac"><a href="#create-installer-for-linux-amp-win-amp-mac" class="headerlink" title="create installer for linux&amp;win&amp;mac."></a>create installer for linux&amp;win&amp;mac.</h1><p>npm run package-all</p>
</blockquote>
<h1 id="create-installer-only-for-linux"><a href="#create-installer-only-for-linux" class="headerlink" title="create installer only for linux."></a>create installer only for linux.</h1><p>npm run package-linux</p>
<h1 id="create-installer-only-for-win"><a href="#create-installer-only-for-win" class="headerlink" title="create installer only for win."></a>create installer only for win.</h1><p>npm run package-win</p>
<h1 id="create-installer-only-for-mac"><a href="#create-installer-only-for-mac" class="headerlink" title="create installer only for mac."></a>create installer only for mac.</h1><p>npm run package-mac</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>image-viewer 便是使用 electron-react-boilerplate 模板开发的一个图片浏览器应用。</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><a href="https://github.com/senntyou/blogs" target="_blank" rel="external">查看</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/JavaScript 引擎基础：原型优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/JavaScript 引擎基础：原型优化/" itemprop="url">JavaScript 引擎基础：原型优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T17:00:06+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文就所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎。作为一名 JavaScript 开发者，深入了解 JavaScript 引擎是如何工作的将有助于你了解自己所写代码的性能特征。</p>
<p>在前一篇文章中，我们讨论了 JavaScript 引擎是如何通过 Shapes 和 Inline Caches 来优化访问对象与数组的。本文将介绍引擎在优化流程中的一些权衡与取舍点，并对其在优化原型属性访问方面的工作进行介绍。</p>
<p>本文中会涉及 JavaScript 引擎中 Inline Caches 和 Shapes 的概念使用，如果你想了解其中更多细节可以移步上一篇译文 JavaScript 引擎基础：Shapes 和 Inline Caches 查看更多。</p>
<p>原文 JavaScript engine fundamentals: optimizing prototypes，作者 @Benedikt 和 @Mathias，译者 hijiangtao。以下开始正文。</p>
<blockquote>
<p>如果你倾向看视频演讲，请移步 <a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DIFWulQnM5E0" target="_blank" rel="external">YouTube</a> 查看更多。</p>
</blockquote>
<h3 id="优化层级与执行效率的取舍"><a href="#优化层级与执行效率的取舍" class="headerlink" title="优化层级与执行效率的取舍"></a>优化层级与执行效率的取舍</h3><p>JavaScript 引擎通用的工作流程：</p>
<p><img src="/img/v2-a9e70b6a9d7decc22c164f8f953eb7ce_hd.jpg" alt="这里写图片描述"></p>
<p>我们也指出，尽管从高级抽象层面来看，引擎之间的处理流程都很相似，但他们在优化流程上通常都存在差异。为什么呢？为什么有些引擎的优化层级会比其他引擎多一些？事实证明，在快速获取可运行的代码与花费更多时间获得最优运行性能的代码之间存在一些取舍与平衡点。</p>
<p><img src="/img/v2-f465fb2efe44c02e6dd42cb7cd34e3e9_hd.jpg" alt="这里写图片描述"></p>
<p>解释器可以快速生成字节码，但字节码通常效率不高。 相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码。</p>
<p>这正是 V8 在使用的模型。它的解释器叫 Ignition，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。</p>
<p><img src="/img/v2-e7e156e96cc00c3ea8d548f3ff582003_hd.jpg" alt="这里写图片描述"></p>
<p>我们往往需要在启动延迟与执行速度之间做出一些取舍，而这便是一些 JavaScript 引擎决定是否在流程中加入优化层的原因所在。例如，SpiderMonkey 在解释器和完整的 IonMonkey 优化编译器之间添加了一个 Baseline 层：</p>
<p><img src="/img/v2-dac06ba5ac123aa21faca57cae54ad4e_hd.jpg" alt="这里写图片描述"></p>
<p>解释器可以快速生成字节码，但字节码执行起来相对较慢。Baseline 生成代码需要花费更长的时间，但能提供更好的运行时性能。最后，IonMonkey 优化编译器花费最长时间来生成机器码，但该代码运行起来非常高效。</p>
<p>让我们通过一个具体的例子，看看不同引擎中的优化流程都有哪些差异。这是一些在循环中会经常出现的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4242424242</span>; ++i) &#123;</div><div class="line">	result += i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(result);</div></pre></td></tr></table></figure>
<p>V8开始在 Ignition 解释器中运行字节码。从某些方面来看，代码是否足够 hot由引擎决定，引擎还负责调度 TurboFan 前端，它是 TurboFan 中负责处理集成分析数据和构建代码在机器层面表示的一部分。这部分结果之后会被发送到另一个线程上的 TurboFan 优化器被进一步优化。</p>
<p><img src="/img/v2-2cb19e88a1fca759f121b076d2c6bb33_hd.jpg" alt="这里写图片描述"></p>
<p>当优化器运行时，V8 会继续在 Ignition 中执行字节码。 当优化器处理完成后，我们获得可执行的机器码，执行流程便会继续下去。</p>
<p>SpiderMonkey 引擎也开始在解释器中运行字节码。但它有一个额外的 Baseline 层，这意味着比较 hot 的代码会首先被发送到 Baseline。 Baseline 编译器在主线程上生成 Baseline 代码，并在完成后继续后面的执行。</p>
<p><img src="/img/v2-42ac267c4aacf1aa27c472b7d24d4586_hd.jpg" alt="这里写图片描述"></p>
<p>如果 Baseline 代码运行了一段时间，SpiderMonkey 最终会激活 IonMonkey 前端，并启动优化器 - 这与 V8 非常相似。当 IonMonkey 进行优化时，代码在 Baseline 中会一直运行。当优化器处理完成后，被执行的是优化后的代码而不是 Baseline 代码。</p>
<p>Chakra 的架构与 SpiderMonkey 非常相似，但 Chakra 尝试通过并行处理更多内容来避免阻塞主线程。Chakra 不在主线程上运行编译器，而是将不同编译器可能需要的字节码和分析数据复制出来，将其发送到一个专用的编译器进程。</p>
<p><img src="/img/v2-7defa2186b8bb2573c7dd9edd45ea087_hd.jpg" alt="这里写图片描述"></p>
<p>当代码准备就绪，引擎便开始运行 SimpleJIT 代码而不是字节码。 对于 FullJIT 来说流程同样如此。这种方法的好处是，与运行完整的编译器（前端）相比，复制所产生的中断时间通常要短得多。但其缺点在于这种启发式复制可能会遗漏某些优化所需的某些信息，因此它在一定程度上是用代码质量来换时间的消耗。</p>
<p>在 JavaScriptCore 中，所有优化编译器都与主 JavaScript 执行完全并发运行；根本没有复制阶段！相反，主线程仅仅是触发了另一个线程上的编译作业。然后，编译器使用复杂的加锁方式从主线程中获取到要访问的分析数据。</p>
<p><img src="/img/v2-55a5d7215f31313bd7edbe84a089d981_hd.jpg" alt="这里写图片描述"></p>
<p>这种方法的优点在于它减少了主线程上由 JavaScript 优化引起的抖动。 缺点是它需要处理复杂的多线程问题并为各种操作付出一些加锁的成本。</p>
<p>我们已经讨论过在使用解释器快速生成代码或使用优化编译器生成可高效执行代码之间的一些权衡。但还有另一个权衡：内存使用！为了说明这一点，来看一个简单的两数相加 JvaScript 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>这是我们使用 V8 中的 Ignition 解释器为 add 函数生成的字节码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StackCheck</div><div class="line">Ldar a1</div><div class="line">Add a0, [<span class="number">0</span>]</div><div class="line">Return</div></pre></td></tr></table></figure>
<p>不要在意这些字节码 - 你不需要了解细节。关键在于它只是四条指令！</p>
<p>当代码变得 hot，TurboFan 便会开始处理以生成如下高度优化的机器码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">leaq rcx,[rip+<span class="number">0x0</span>]</div><div class="line">movq rcx,[rcx<span class="number">-0x37</span>]</div><div class="line">testb [rcx+<span class="number">0xf</span>],<span class="number">0x1</span></div><div class="line">jnz CompileLazyDeoptimizedCode</div><div class="line">push rbp</div><div class="line">movq rbp,rsp</div><div class="line">push rsi</div><div class="line">push rdi</div><div class="line">cmpq rsp,[r13+<span class="number">0xe88</span>]</div><div class="line">jna StackOverflow</div><div class="line">movq rax,[rbp+<span class="number">0x18</span>]</div><div class="line">test al,<span class="number">0x1</span></div><div class="line">jnz Deoptimize</div><div class="line">movq rbx,[rbp+<span class="number">0x10</span>]</div><div class="line">testb rbx,<span class="number">0x1</span></div><div class="line">jnz Deoptimize</div><div class="line">movq rdx,rbx</div><div class="line">shrq rdx, <span class="number">32</span></div><div class="line">movq rcx,rax</div><div class="line">shrq rcx, <span class="number">32</span></div><div class="line">addl rdx,rcx</div><div class="line">jo Deoptimize</div><div class="line">shlq rdx, <span class="number">32</span></div><div class="line">movq rax,rdx</div><div class="line">movq rsp,rbp</div><div class="line">pop rbp</div><div class="line">ret <span class="number">0x18</span></div></pre></td></tr></table></figure>
<p>这么一大堆代码，这比四行要远远超出更多！通常来说，字节码比机器码更紧凑，特别是对比优化过的机器码。但另一方面，字节码需要解释器才能执行，而优化过机器码可以由处理器直接执行。</p>
<p>这就是为什么 JavaScript 引擎不简单粗暴”优化一切”的主要原因之一。正如我们之前所见，生成优化的机器码也需要很长时间，而最重要的是，我们刚刚了解到优化的机器码也需要更多的内存。</p>
<p><img src="/img/v2-4d181566b8b5edc8c57ef8d187a5b02c_hd.jpg" alt="这里写图片描述"></p>
<blockquote>
<p>小结：JavaScript 引擎之所以具有不同优化层，就在于使用解释器快速生成代码或使用优化编译器生成高效代码之间存在一个基本权衡。通过添加更多优化层可以让你做出更细粒度的决策，但是以额外的复杂性和开销为代价。此外，在优化级别和生成代码所占用的内存之间也存在折衷。这就是为什么 JavaScript 引擎仅尝试优化比较 hot 功能的原因所在。</p>
</blockquote>
<h3 id="原型属性访问优化"><a href="#原型属性访问优化" class="headerlink" title="原型属性访问优化"></a>原型属性访问优化</h3><p>之前的文章解释了 JavaScript 引擎如何使用 Shapes 和 Inline Caches 优化对象属性加载。回顾一下，引擎将对象的 Shape 与对象值分开存储。</p>
<p><img src="/img/v2-8014267c30392e557b6e336ea6b08b7d_hd.jpg" alt="这里写图片描述"></p>
<p>Shapes 可以实现称为 Inline Caches 或简称 ICs 的优化。通过组合，Shapes 和 ICs 可以加快代码中相同位置的重复属性访问速度。</p>
<p><img src="/img/v2-66f3e883ed43057d0d94bec61760a2f2_hd.jpg" alt="这里写图片描述"></p>
<h4 id="Class-和基于原型的编程"><a href="#Class-和基于原型的编程" class="headerlink" title="Class 和基于原型的编程"></a>Class 和基于原型的编程</h4><p>既然我们知道如何在 JavaScript 对象上快速进行属性访问，那么让我们看一下最近添加到 JavaScript 中的特性：class（类）。JavaScript 中的类语法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(x) &#123;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">	&#125;</div><div class="line">	getX() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管它看上去是 JavaScript 中的一个全新概念，但它仅仅是基于原型编程的语法糖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.x = x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.prototype.getX = <span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这里，我们在 Bar.prototype 对象上分配一个 getX 属性。这与其他任何对象的工作方式完全相同，因为原型只是 JavaScript 中的对象！在基于原型的编程语言（如 JavaScript）中，方法通过原型共享，而字段则存储在实际的实例上。</p>
<p>让我们来实际看看，当我们创建一个名为 foo 的 Bar 新实例时，幕后所发生的事情。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>通过运行此代码创建的实例具有一个带有属性 “x” 的 shape。foo 的原型是属于 class Bar 的 Bar.prototype。</p>
<p><img src="/img/v2-51bbb2ce6cea40dea88d4b41afe164e1_hd.jpg" alt="这里写图片描述"></p>
<p>Bar.prototype 有自己的 shape，其中包含一个属性 ‘getX’，取值则是函数 getX，它在调用时只返回 this.x。Bar.prototype 的原型是 Object.prototype，它是 JavaScript 语言的一部分。由于 Object.prototype是原型树的根节点，因此它的原型是 null。</p>
<p><img src="/img/v2-bbecbef82de21d921ce07679a291d26c_hd.jpg" alt="这里写图片描述"></p>
<p>如果你在这个类上创建另一个实例，那么两个实例将共享对象 shape。两个实例都指向相同的 Bar.prototype 对象。</p>
<h4 id="原型属性访问"><a href="#原型属性访问" class="headerlink" title="原型属性访问"></a>原型属性访问</h4><p>好的，现在我们知道当我们定义一个类并创建一个新实例时会发生什么。但是如果我们在一个实例上调用一个方法会发生什么，比如我们在这里做了什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</div><div class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</div><div class="line"><span class="keyword">const</span> x = foo.getX();</div></pre></td></tr></table></figure>
<p>你可以将任何方法调用都视为两个单独的步骤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> x = foo.getX(); </div><div class="line"><span class="comment">// 实际上是两步操作: </span></div><div class="line"><span class="keyword">const</span> $getX = foo.getX; </div><div class="line"><span class="keyword">const</span> x = $getX.call(foo);</div></pre></td></tr></table></figure>
<p>第1步是加载这个方法，它只是原型上的一个属性（其值恰好是一个函数）。第2步是使用实例作为 this 值来调用该函数。让我们来看看第一步，即从实例 foo 中加载方法 getX。</p>
<p><img src="/img/v2-0df76c9b83f4b1c7e04c414b2131fbdb_hd.jpg" alt="这里写图片描述"></p>
<p>引擎从 foo 实例开始，并且意识到 foo 的 shape 上没有 ‘getX’ 属性，所以它必须向原型链追溯。我们到了 Bar.prototype，查看它的原型 shape，发现它在偏移0处有 ‘getX’ 属性。我们在 Bar.prototype 的这个偏移处查找该值，并找到我们想要的JSFunction getX。就是这样！</p>
<p>但 JavaScript 的灵活性使得我们可以改变原型链链接，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</div><div class="line">foo.getX();</div><div class="line"><span class="comment">// → true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(foo, <span class="literal">null</span>);</div><div class="line">foo.getX();</div><div class="line"><span class="comment">// → Uncaught TypeError: foo.getX is not a function</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们调用 foo.getX() 两次，但每次它都具有完全不同的含义和结果。 这就是为什么尽管原型只是 JavaScript 中的对象，但优化原型属性访问对于 JavaScript 引擎而言比优化常规对象的属性访问更具挑战性的原因了。</p>
<p>粗略的来看，加载原型属性是一个非常频繁的操作：每次调用一个方法时都会发生这种情况！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</div><div class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</div><div class="line"><span class="keyword">const</span> x = foo.getX();</div></pre></td></tr></table></figure>
<p>之前，我们讨论了引擎如何通过使用 Shapes 和 Inline Caches 来优化访问常规属性的。 我们如何在具有相似 shape 的对象上优化原型属性的重复访问呢？ 我们在上面已经看过是如何访问属性的。</p>
<p><img src="/img/v2-25043d3630da77f67fe0958663e4cd9b_hd.jpg" alt="这里写图片描述"></p>
<p>为了在这种特殊情况下实现快速重复访问，我们需要知道这三件事：</p>
<p>foo的 shape 不包含 ‘getX’ 并且没有改变过。这意味着没有人通过添加或删除属性或通过更改其中一个属性来更改对象 foo。foo 的原型仍然是最初的 Bar.prototype。这意味着没有人通过使用 Object.setPrototypeOf() 或通过赋予特殊的 <em>proto</em> 属性来更改 foo的原型。Bar.prototype 的形状包含 ‘getX’ 并且没有改变。这意味着没有人通过添加或删除属性或更改其中一个属性来更改 Bar.prototype。</p>
<p>一般情况下，这意味着我们必须对实例本身执行1次检查，并对每个原型进行2次检查，直到找到我们正在寻找的属性所在原型。1 + 2N 次检查（其中 N是所涉及的原型的数量）对于这种情况听起来可能不太糟糕，因为这里原型链相对较浅 - 但是引擎通常必须处理更长的原型链，就像常见的 DOM 类一样。这是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> anchor = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line"><span class="comment">// → HTMLAnchorElement</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> title = anchor.getAttribute(<span class="string">'title'</span>);</div></pre></td></tr></table></figure>
<p>我们有一个 HTMLAnchorElement，在其上调用 getAttribute() 方法。这个简单的锚元素原型链就已经涉及6个原型！大多数有趣的 DOM 方法并不是直接存在于 HTMLAnchorElement 原型中，而是在原型链的更高层。</p>
<p><img src="/img/v2-12705088e96ddfd3afe3d6bffda5b306_hd.jpg" alt="这里写图片描述"></p>
<p>我们可以在 Element.prototype 上找到 getAttribute() 方法。这意味着我们每次调用 anchor.getAttribute() 时，JavaScript引擎都需要……</p>
<p>检测到 ‘getAttribute’ 不在锚对象本身上，检测到直接原型为 HTMLAnchorElement.prototype，断言原型上缺少’getAttribute’，检测到下一个原型是 HTMLElement.prototype，断言 ‘getAttribute’ 也不存在于这个原型上，最终检测出下一个原型是 Element.prototype，找到 ‘getAttribute’。</p>
<p>总共有7次检测！由于这是 Web 上一种非常常见的代码，因此引擎会应用技巧来减少原型上属性加载所需的检查次数。</p>
<p>回到前面的例子，我们在 foo 上访问 ‘getX’ 时总共执行了3次检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</div><div class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</div><div class="line"><span class="keyword">const</span> $getX = foo.getX;</div></pre></td></tr></table></figure>
<p>在直到我们找到携带目标属性的原型之前，我们需要对原型链上的每个对象进行 shape 的缺失检查。如果我们可以通过将原型检查折叠到缺失检查来减少检查次数，那就太好了。而这基本上就是引擎所做的：引擎将原型链在 Shape 上，而不是直接链在实例上。</p>
<p><img src="/img/v2-53cede62cf5632b52bf66a6f22d773d76_hd.jpg" alt="这里写图片描述"></p>
<p>每个 shape 都指向原型。这也意味着每次 foo 原型发生变化时，引擎都会转换到一个新 shape。 现在我们只需要检查一个对象的 shape，这样既可以断言某些属性的缺失，也可以保护原型链链接。</p>
<p>通过这种方法，我们可以将检查次数从 1 + 2N 降到 1 + N，以便在原型上更快地访问属性。但这仍相当昂贵，因为它在原型链的长度上仍然是线性的。 为了进一步将检查次数减少到一个常量级别，引擎采用了不同的技巧，特别是对于相同属性访问的后续执行。</p>
<h4 id="Validity-cells"><a href="#Validity-cells" class="headerlink" title="Validity cells"></a>Validity cells</h4><p>V8专门为此目的处理原型的 shape。每个原型都具有一个不与其他对象（特别是不与其他原型共享）共享且独特的 shape，且每个原型的 shape 都具有与之关联的一个特殊 ValidityCell。</p>
<p><img src="/img/v2-a497a7e9a6f46afcef5376f4f507437b_hd.jpg" alt="这里写图片描述"></p>
<p>只要有人更改相关原型或其祖先的任何原型，此 ValidityCell 就会失效。让我们来看看它是如何工作的。</p>
<p>为了加速原型的后续访问，V8 建立了一个 Inline Cache，其中包含四个字段：</p>
<p><img src="/img/v2-93577009f1276e45544656d94661c026_hd.jpg" alt="这里写图片描述"></p>
<p>在第一次运行此代码预热 inline cache 时，V8 会记住目标属性在原型中的偏移量，找到属性的原型（本例中为 Bar.prototype），实例的 shape（在这种情况下为 foo 的 shape），以及与实例 shape 链接的直接原型中 ValidityCell 的链接（在本例中也恰好是 Bar.prototype）。</p>
<p>下次 inline cache 命中时，引擎必须检查实例的 shape 和 ValidityCell。如果它仍然有效，则引擎可以直接到达 Prototype 上的 Offset 位置，跳过其他查找。</p>
<p><img src="/img/v2-d31e1e11c96db86a381f80f78cdd5388_hd.jpg" alt="这里写图片描述"></p>
<p>当原型改变时，shape 将重新分配，且先前的 ValidityCell 失效。因此，Inline Cache 在下次执行时会失效，从而导致性能下降。</p>
<p>回到之前的 DOM 示例，这意味着对 Object.prototype 的任何更改不仅会使 Object.prototype本身的 inline cache 失效，而且还会使其下游的所有原型失效，包括EventTarget.prototype，Node.prototype，Element.prototype 等，直到 HTMLAnchorElement.prototype 为止。</p>
<p><img src="/img/v2-c40b5c7ce5dc801d4bb5762c29ed018e_hd.jpg" alt="这里写图片描述"></p>
<p>实际上，在运行代码时修改 Object.prototype 意味着完全抛弃性能上的考虑。不要这样做！</p>
<p>让我们用一个具体的例子来探讨这个问题。 假设我们有一个类叫做 Bar，并且我们有一个函数 loadX，它调用 Bar 对象上的方法。 我们用同一个类的实例多调用这个 loadX 函数几次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; <span class="comment">/* … */</span> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">bar</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> bar.getX(); <span class="comment">// IC for 'getX' on `Bar` instances.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">loadX(<span class="keyword">new</span> Bar(<span class="literal">true</span>));</div><div class="line">loadX(<span class="keyword">new</span> Bar(<span class="literal">false</span>));</div><div class="line"><span class="comment">// IC in `loadX` now links the `ValidityCell` for</span></div><div class="line"><span class="comment">// `Bar.prototype`.</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.prototype.newMethod = <span class="function"><span class="params">y</span> =&gt;</span> y;</div><div class="line"><span class="comment">// The `ValidityCell` in the `loadX` IC is invalid</span></div><div class="line"><span class="comment">// now, because `Object.prototype` changed.</span></div></pre></td></tr></table></figure>
<p>loadX 中的 inline cache 现在指向 Bar.prototype 的 ValidityCell。 如果你之后执行了类似于改变 Object.prototype（这是 JavaScript 中所有原型的根节点）的操作，则ValidityCell 将失效，且现有的 inline cache 会在下次命中时丢失，从而导致性能下降。</p>
<p>修改 Object.prototype 被认为是一个不好的操作，因为它使引擎在此之前为原型访问准备的所有 inline cache 都失效。 这是另一个不推荐的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* … */</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Run critical code:</span></div><div class="line">someObject.foo();</div><div class="line"><span class="comment">// End of critical code.</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype.foo;</div></pre></td></tr></table></figure>
<p>我们扩展了 Object.prototype，它使引擎在此之前存储的所有原型 inline cache 均无效了。然后我们运行一些用到新原型方法的代码。引擎此时则需要从头开始，并为所有原型属性的访问设置新的 inline cache。最后，我们删除了之前添加的原型方法。</p>
<p>删除，这听起来像个好主意，对吧？然而在这种情况下，它只会让情况变得更糟！删除属性会修改 Object.prototype，因此所有 inline cache 会再次失效，而引擎又必须从头开始。</p>
<blockquote>
<p>总结：虽然原型只是对象，但它们由 JavaScript 引擎专门处理，以优化在原型上查找方法的性能表现。把你的原型放在一旁！或者，如果你确实需要修改原型，请在其他代码运行之前执行此操作，这样至少不会让引擎所做的优化付诸东流。</p>
</blockquote>
<h3 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h3><p>我们已经了解了 JavaScript 引擎是如何存储对象与类的，Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型的。基于这些知识，我们认为有一个普适实用的 JavaScript 编码技巧，可以帮助提高性能：请勿随意修改原型对象（即便你真的需要，那么请在其他代码运行之前做这件事）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/JSX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/JSX/" itemprop="url">JSX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T17:00:06+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>只要你用过React，就应该大概了解过 JSX，一种用于创建 React 元素的类 XML 语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div className=<span class="string">"greeting"</span>&gt;</div><div class="line">      &lt;h1 foo=<span class="string">"bar"</span>&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;Good to see you &#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为浏览器还不支持 JSX，所以在运行前，需要将代码转换为普通的 JavaScript。从对开发者友好的代码转换成对浏览器友好的代码这项工作，通常都是用 Babel 这样的工具来做。Babel 编译后，getGreeting函数就会被编译成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> React.createElement(</div><div class="line">    <span class="string">"div"</span>,</div><div class="line">    &#123; <span class="attr">className</span>: <span class="string">"greeting"</span> &#125;,</div><div class="line">    React.createElement(<span class="string">"h1"</span>, &#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;, <span class="string">"Hello!"</span>),</div><div class="line">    React.createElement(<span class="string">"h2"</span>, <span class="literal">null</span>, <span class="string">"Good to see you "</span>, name)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个不同的语法中，所有的标签名、属性名、属性值以及文本内容都没有改变。那么React.createElement是什么？</p>
<p>React.createElement是 React 用来创建元素的方法。因为JSX通常与React同时使用，所以 Babel 默认注入这个方法，但实际情况并非如此。事实上，JSX 是从React中脱离出来的，JSX 是用于在 JS 中使用类似 XML 的语法定义树结构的规范。这个树结构可以是一个 React 组件渲染的元素，也可以是完全不同的其他的东西。</p>
<p>为了不只是在 React 中使用 JSX，我们需要告诉 Babel 使用其他的函数来代替React.createElement。只要在文件中添加/* @jsx 另一个函数名 /这样的注释就行了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx foo */</span></div><div class="line"><span class="keyword">var</span> bar = <span class="xml"><span class="tag">&lt;<span class="name">x</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span>;</div><div class="line"><span class="keyword">var</span> bax = <span class="xml"><span class="tag">&lt;<span class="name">Y</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">Y</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// becomes:</span></div><div class="line"><span class="keyword">var</span> bar = foo(<span class="string">"x"</span>, <span class="literal">null</span>, <span class="string">"Hi"</span>);</div><div class="line"><span class="keyword">var</span> bax = foo(Y, <span class="literal">null</span>, <span class="string">"Hi"</span>);</div></pre></td></tr></table></figure>
<p>最后要说的一点是，Babel会根据元素名称的大小写使用不同的方式处理JSX。小写字母名称会以字符串参数的形式进行传递，首字母大写的名称则会作为函数进行传递，就像在代码段中一样。</p>
<h3 id="数学中的JSX"><a href="#数学中的JSX" class="headerlink" title="数学中的JSX"></a>数学中的JSX</h3><p>我们可以使用Math.sqrt(a <em> a + b </em> b)来算a和b的弦等于多少，但这一点都不好玩。我们可以用JSX来计算这个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Sum = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</div><div class="line"><span class="keyword">const</span> Pow = <span class="function">(<span class="params">&#123; exponent &#125;, base</span>) =&gt;</span> <span class="built_in">Math</span>.pow(base, exponent);</div><div class="line"><span class="keyword">const</span> Sqrt = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.sqrt(x);</div><div class="line"></div><div class="line"><span class="keyword">const</span> Hypotenuse = <span class="function">(<span class="params">&#123; a, b &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;Sqrt&gt;</div><div class="line">    &lt;Sum&gt;</div><div class="line">      &lt;Pow exponent=&#123;<span class="number">2</span>&#125;&gt;&#123;a&#125;&lt;<span class="regexp">/Pow&gt;</span></div><div class="line"><span class="regexp">      &lt;Pow exponent=&#123;2&#125;&gt;&#123;b&#125;&lt;/</span>Pow&gt;</div><div class="line">    &lt;<span class="regexp">/Sum&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>Sqrt&gt;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">/** @jsx calc */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">operation, props, ...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> params = props ? [props] : [];</div><div class="line">  params = params.concat(...args);</div><div class="line">  <span class="keyword">return</span> operation(...params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">Hypotenuse</span> <span class="attr">a</span>=<span class="string">&#123;3&#125;</span> <span class="attr">b</span>=<span class="string">&#123;4&#125;</span> /&gt;</span>);</span></div></pre></td></tr></table></figure>
<p>这里还有另一个版本的hypotenuse可以接收两个以上的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Hypotenuse = <span class="function">(<span class="params">&#123; values &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;Sqrt&gt;</div><div class="line">    &lt;Sum&gt;&#123;values.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;Pow exponent=&#123;<span class="number">2</span>&#125;&gt;&#123;v&#125;&lt;<span class="regexp">/Pow&gt;)&#125;&lt;/</span>Sum&gt;</div><div class="line">  &lt;<span class="regexp">/Sqrt&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">console.log(&lt;Hypotenuse values=&#123;[3, 4, 5]&#125; /</span>&gt;);</div><div class="line">            <span class="keyword">const</span> Hypotenuse = <span class="function">(<span class="params">&#123; values &#125;</span>) =&gt;</span> (</div><div class="line">  &lt;Sqrt&gt;</div><div class="line">    &lt;Sum&gt;&#123;values.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;Pow exponent=&#123;<span class="number">2</span>&#125;&gt;&#123;v&#125;&lt;<span class="regexp">/Pow&gt;)&#125;&lt;/</span>Sum&gt;</div><div class="line">  &lt;<span class="regexp">/Sqrt&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">console.log(&lt;Hypotenuse values=&#123;[3, 4, 5]&#125; /</span>&gt;);</div></pre></td></tr></table></figure>
<h3 id="无所不能的JSX"><a href="#无所不能的JSX" class="headerlink" title="无所不能的JSX"></a>无所不能的JSX</h3><p>接下来尝试做一些更神奇的事情，我们来试试归并排序。</p>
<p>首先，使用RamdaJS来给我们的组件加入一些初始功能。otaku</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> R <span class="keyword">from</span> <span class="string">"ramda"</span>;</div><div class="line"><span class="keyword">var</span> divisibleBy = R.curry(R.pipe(R.flip(R.modulo), R.equals(<span class="number">0</span>)));</div><div class="line"><span class="keyword">var</span> fizzbuzz = R.map(</div><div class="line">  R.cond([</div><div class="line">    [R.both(divisibleBy(<span class="number">3</span>), divisibleBy(<span class="number">5</span>)), R.always(<span class="string">"FizzBuzz"</span>)],</div><div class="line">    [divisibleBy(<span class="number">3</span>), R.always(<span class="string">"Fizz"</span>)],</div><div class="line">    [divisibleBy(<span class="number">5</span>), R.always(<span class="string">"Buzz"</span>)],</div><div class="line">    [R.T, R.identity]</div><div class="line">  ])</div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(fizzbuzz(R.range(<span class="number">1</span>, <span class="number">16</span>)));</div></pre></td></tr></table></figure>
<p>我们可以使用 JSX 写出相同的代码，只需要编写与JSX元素名称匹配的函数去调用ramda函数就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx run */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">f, props, ...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> R[f](...args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> divisibleBy = (</div><div class="line">  &lt;curry&gt;</div><div class="line">    &lt;pipe&gt;</div><div class="line">      &lt;flip&gt;</div><div class="line">        &lt;modulo /&gt;</div><div class="line">      &lt;<span class="regexp">/flip&gt;</span></div><div class="line"><span class="regexp">      &lt;equals&gt;&#123;0&#125;&lt;/</span>equals&gt;</div><div class="line">    &lt;<span class="regexp">/pipe&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>curry&gt;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> fizzbuzz = (</div><div class="line">  &lt;map&gt;</div><div class="line">    &lt;cond&gt;</div><div class="line">      &#123;[</div><div class="line">        [</div><div class="line">          &lt;both&gt;</div><div class="line">            &#123;divisibleBy(<span class="number">3</span>)&#125;</div><div class="line">            &#123;divisibleBy(<span class="number">5</span>)&#125;</div><div class="line">          &lt;<span class="regexp">/both&gt;,</span></div><div class="line"><span class="regexp">          &lt;always&gt;"FizzBuzz"&lt;/</span>always&gt;</div><div class="line">        ],</div><div class="line">        [divisibleBy(<span class="number">3</span>), &lt;always&gt;<span class="string">"Fizz"</span>&lt;<span class="regexp">/always&gt;],</span></div><div class="line"><span class="regexp">        [divisibleBy(5), &lt;always&gt;"Buzz"&lt;/always&gt;],</span></div><div class="line"><span class="regexp">        [R.T, &lt;identity /&gt;]</span></div><div class="line"><span class="regexp">      ]&#125;</span></div><div class="line"><span class="regexp">    &lt;/</span>cond&gt;</div><div class="line">  &lt;<span class="regexp">/map&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">console.log(fizzbuzz(R.range(1, 16)));</span></div></pre></td></tr></table></figure>
<p>好看了？……并没有。</p>
<p>运行的函数还可以再智能一点，这样可以增加 JSX 代码的 “纯净度”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> FizzBuzz = (</div><div class="line">  &lt;map&gt;</div><div class="line">    &lt;cond concat&gt;</div><div class="line">      &lt;pair&gt;</div><div class="line">        &lt;both&gt;</div><div class="line">          &lt;DivisibleBy value=&#123;<span class="number">3</span>&#125; /&gt;</div><div class="line">          &lt;DivisibleBy value=&#123;<span class="number">5</span>&#125; /&gt;</div><div class="line">        &lt;<span class="regexp">/both&gt;</span></div><div class="line"><span class="regexp">        &lt;always value="FizzBuzz" /</span>&gt;</div><div class="line">      &lt;<span class="regexp">/pair&gt;</span></div><div class="line"><span class="regexp">      &lt;pair&gt;</span></div><div class="line"><span class="regexp">        &lt;DivisibleBy value=&#123;3&#125; /</span>&gt;</div><div class="line">        &lt;always value=<span class="string">"Fizz"</span> /&gt;</div><div class="line">      &lt;<span class="regexp">/pair&gt;</span></div><div class="line"><span class="regexp">      &lt;pair&gt;</span></div><div class="line"><span class="regexp">        &lt;DivisibleBy value=&#123;5&#125; /</span>&gt;</div><div class="line">        &lt;always value=<span class="string">"Buzz"</span> /&gt;</div><div class="line">      &lt;<span class="regexp">/pair&gt;</span></div><div class="line"><span class="regexp">      &lt;pair&gt;</span></div><div class="line"><span class="regexp">        &lt;t /</span>&gt;</div><div class="line">        &lt;identity /&gt;</div><div class="line">      &lt;<span class="regexp">/pair&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>cond&gt;</div><div class="line">  &lt;<span class="regexp">/map&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">console.log(</span></div><div class="line"><span class="regexp">  &lt;FizzBuzz&gt;</span></div><div class="line"><span class="regexp">    &lt;range&gt;</span></div><div class="line"><span class="regexp">      &#123;1&#125;</span></div><div class="line"><span class="regexp">      &#123;16&#125;</span></div><div class="line"><span class="regexp">    &lt;/</span>range&gt;</div><div class="line">  &lt;<span class="regexp">/FizzBuzz&gt;</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure>
<p>现在，你可以用ramda做的所有事情都可以用JSX来做了。你可以使用它来做任何事情，包括归并排序：</p>
<p><img src="/img/16522dd37ca244f5.png" alt="这里写图片描述"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/前端缓存概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/前端缓存概述/" itemprop="url">前端缓存概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T13:00:06+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前端缓存概述"><a href="#前端缓存概述" class="headerlink" title="前端缓存概述"></a>前端缓存概述</h3><p>前端缓存主要是分为HTTP缓存和浏览器缓存。其中HTTP缓存是在HTTP请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端js上进行设置。下面会分别具体描述。</p>
<p><img src="/img/bVbekda.png" alt="这里写图片描述"></p>
<h3 id="前端缓存分类"><a href="#前端缓存分类" class="headerlink" title="前端缓存分类"></a>前端缓存分类</h3><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><blockquote>
<p>整体流程：HTTP缓存都是从第二次请求开始的。<br>第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。</p>
</blockquote>
<p>HTTP缓存分为强缓存和协议缓存，它们的区别如下：</p>
<p><img src="/img/bVbekkz.png" alt="这里写图片描述"></p>
<blockquote>
<p>200 from disk or 200 from memory :<br>强缓存的200也有两种情况：200 from disk和200 from memory。现在我没有找到明确的文档来描述这种区别的发生条件。知乎这个问题中提到了一些情景，可以自行取用。</p>
</blockquote>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存都是成对出现的。</p>
<p><img src="/img/bVbeklT.png" alt="这里写图片描述"></p>
<h4 id="最佳优化策略-消灭304"><a href="#最佳优化策略-消灭304" class="headerlink" title="最佳优化策略-消灭304"></a>最佳优化策略-消灭304</h4><blockquote>
<p>最佳优化策略：因为协商缓存本身也有http请求的损耗，所以最佳优化策略是要尽可能的将静态文件存储为较长的时间，多利用强缓存而不是协商缓存，即消灭304。</p>
</blockquote>
<p>但是给文件设置一个很长的Cacha-Control也会带来其他的问题，最主要的问题是静态内容更新时，用户不能及时获得更新的内容。这时候就要使用hash的方法对文件进行命名，通过每次更新不同的静态文件名来消除强缓存的影响。</p>
<blockquote>
<p>Hash命名：<br><a href="http://xxx.com/main.5eas34fa.js" target="_blank" rel="external">http://xxx.com/main.5eas34fa.js</a><br><a href="http://xxx.com/main.js?5eas34fa" target="_blank" rel="external">http://xxx.com/main.js?5eas34fa</a><br><a href="http://xxx.com/5eas34fa/main.js" target="_blank" rel="external">http://xxx.com/5eas34fa/main.js</a></p>
</blockquote>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><h4 id="本地存储小容量"><a href="#本地存储小容量" class="headerlink" title="本地存储小容量"></a>本地存储小容量</h4><p>Cookie主要用于用户信息的存储，Cookie的内容可以自动在请求的时候被传递给服务器。<br>LocalStorage的数据将一直保存在浏览器内，直到用户清除浏览器缓存数据为止。<br>SessionStorage的其他属性同LocalStorage，只不过它的生命周期同标签页的生命周期，当标签页被关闭时，SessionStorage也会被清除。</p>
<p><img src="/img/bVbeuT8.png" alt="这里写图片描述"></p>
<h4 id="本地存储大容量"><a href="#本地存储大容量" class="headerlink" title="本地存储大容量"></a>本地存储大容量</h4><p>WebSql和IndexDB主要用在前端有大容量存储需求的页面上，例如，在线编辑浏览器或者网页邮箱。</p>
<p><img src="/img/bVbeuT7.png" alt="这里写图片描述"></p>
<h4 id="应用缓存与PWA"><a href="#应用缓存与PWA" class="headerlink" title="应用缓存与PWA"></a>应用缓存与PWA</h4><p>应用缓存全称为Offline Web Application，它的缓存内容被存在浏览器的Application Cache中。它也是一个被W3C标准废弃的功能，主要是通过manifest文件来标注要被缓存的静态文件清单。但是在缓存静态文件的同时，也会默认缓存html文件。这导致页面的更新只能通过manifest文件中的版本号来决定。而且，即使我们更新了version，用户的第一次访问还是会访问到老的页面，只有下一次再访问才能访问到新的页面。所以，应用缓存只适合那种常年不变化的静态网站。如此的不方便，也是被废弃的重要原因。</p>
<p>PWA全称是渐进式网络应用，主要目标是实现web网站的APP式功能和展示。尽管PWA也有manifest文件，但是与应用缓存却完全不同。不同于manifest简单的将文件通过是否缓存进行分类，PWA用manifest构建了自己的APP骨架。另外，PWA用Service Worker来控制缓存的使用。这一块的内容较多，在这里就不详细展开了。</p>
<p><img src="/img/bVbeuTV.png" alt="这里写图片描述"></p>
<h4 id="往返缓存"><a href="#往返缓存" class="headerlink" title="往返缓存"></a>往返缓存</h4><p>往返缓存又称为BFCache，是浏览器在前进后退按钮上为了提升历史页面的渲染速度的一种策略。BFCache会缓存所有的DOM结构，但是问题在于，一些页面开始时进行的上报或者请求可能会被影响。这个问题现在主要会出现在微信h5的开发中。</p>
<p>去除BFCache有多种方法，但不是本文的重点，想了解的同学可以看<a href="https://segmentfault.com/a/1190000015321895" target="_blank" rel="external">《浏览器往返缓存（Back/Forward cache）问题的分析与解决》</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/vuex持久化方案探究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/vuex持久化方案探究/" itemprop="url">vuex持久化方案探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T11:00:16+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>用vue开发中大型应用时候，我们通常都会使用vuex进行状态管理，但由于vuex是将数据以js对象的形势维护在内存中，所以当页面刷新时候，存在内存中的vuex数据将会丢失，在很多场景中，我们不愿意看到这样的结果的</p>
<h3 id="引出的问题"><a href="#引出的问题" class="headerlink" title="引出的问题"></a>引出的问题</h3><p>那么如何实现vuex的持久化，使得他能变得像localStorage，sessionStorag一样呢？</p>
<h3 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h3><p>大体的思路无非就是将vuex的state存起来，初始化的时候去读取缓存并注册vuex，具体可看下面两种方案：</p>
<h4 id="方案1：编写vuex插件"><a href="#方案1：编写vuex插件" class="headerlink" title="方案1：编写vuex插件"></a>方案1：编写vuex插件</h4><p>vuex提供了插件的功能，我们可以在每次mutation的时候将state保存下来，存到localStorage，sessionStorage中，然后页面初始化的时候，读取存储的state值，覆盖state的初始值</p>
<h4 id="方案2：利用beforeunload事件"><a href="#方案2：利用beforeunload事件" class="headerlink" title="方案2：利用beforeunload事件"></a>方案2：利用beforeunload事件</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload" target="_blank" rel="external">beforeunload</a>事件可能大家用的不是特别多，他并不是一个新特性，而是一个很老的事件，并且兼容性特别好（IE6都兼容了，你敢信）</p>
<p>beforeunload事件会在页面卸载之前执。如刷新，返回到其他页面，关闭等操作都会触发这个事件<br>这就给我们提供另外一种缓存思路，与其每次mutation时记录变化，为何不在页面unload时，一次性把要缓存的state都缓存起来呢，这样效率不是更高吗？<br>基于这个原理，我开发了一款插件<a href="https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload" target="_blank" rel="external">vue-vuex-persist</a></p>
<h3 id="第三方解决方案"><a href="#第三方解决方案" class="headerlink" title="第三方解决方案"></a>第三方解决方案</h3><blockquote>
<p>大多数第三方插件基于vuex插件实现。</p>
</blockquote>
<p>社区也有一些不错的插件，如<a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank" rel="external">vuex-persistedstate</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/Virtual DOM的简单实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/Virtual DOM的简单实现/" itemprop="url">Virtual DOM的简单实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T23:16:06+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在看vue的源码时了解了vue关于Virtual DOM的一些想法,Virtual DOM可以帮助我们更高效的操作DOM。它通过实现一个vnode的js对象，vnode的对象与dom的node对象是一一对应的，通过我们对vnode的操作可以实现对dom的操作，这样就可以避免频繁的dom操作带来的效率问题。vue的Virtual DOM实现了一套高效的diff算法来快速的比对更新dom树。</p>
<h4 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h4><p>首先，创建vnode的对象，vnode记录相应的DOM对象的一些属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span> (tag, nodeType,key, props, text, children)&#123;</div><div class="line">        <span class="keyword">this</span>.tag = tag <span class="comment">//element类型</span></div><div class="line">        <span class="keyword">this</span>.nodeType = nodeType <span class="comment">//node类型，1为普通节点，3为文本节点，8为注释</span></div><div class="line">        <span class="keyword">this</span>.key = key</div><div class="line">        <span class="keyword">this</span>.props = props <span class="comment">//node的属性</span></div><div class="line">        <span class="keyword">this</span>.text = text <span class="comment">//文本节点的内容</span></div><div class="line">        <span class="keyword">this</span>.children = children<span class="comment">//子节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将vnode渲染成DOM节点的方法</span></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">var</span> el</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">1</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tag)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="keyword">this</span>.props)&#123;</div><div class="line">                setAttr(el,prop,<span class="keyword">this</span>.props[prop])</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.children)&#123;</div><div class="line">                <span class="keyword">this</span>.children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ch,i</span>)</span>&#123;</div><div class="line">                    el.appendChild(ch.render())</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">3</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.text)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">8</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createComment(<span class="keyword">this</span>.text)</div><div class="line">        &#125;</div><div class="line">        el.key = <span class="keyword">this</span>.key</div><div class="line">        <span class="keyword">return</span> el</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttr</span>(<span class="params">node,key,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(key===<span class="string">'style'</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">in</span> value)&#123;</div><div class="line">            node.style[val] = value[val]</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        node.setAttribute(key,value)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h4><p>diff主要是用来对比新旧vnode的区别，找出区别的元素并记录在directives对象上，便于接下来可以通过directives的内容对旧的vnode进行替换，绘制新的DOM.</p>
<p>这是diff的入口方法，参数是旧的vnode和新的vnode,directives是用来记录每个节点的改变情况的对象。<br><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export default function diff(oldVNode, newVNode)&#123;</div><div class="line">    directives = &#123;&#125;</div><div class="line">    diffVNode(oldVNode,newVNode,directives)</div><div class="line">    return directives</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在diff方法中调用diffVNode来对节点进行逐一比较。首先，它会比较oldVNode和newVNode是否是相同的节点。如果相同，就对节点类型进行判断，来选择比较的方法，对于文本和注释节点，只需要比较文本内容是否相同即可，对于元素则要比较元素标签，元素的属性以及子元素是否相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function diffVNode(oldVNode,newVNode)&#123;</div><div class="line"></div><div class="line">    if(newVNode &amp;&amp; isSameTypeNode(oldVNode,newVNode))&#123;</div><div class="line">        if(newVNode.nodeType===3 || newVNode.nodeType===8)&#123;</div><div class="line">            if(oldVNode.text !== newVNode.text)&#123;</div><div class="line">                addDirectives(newVNode.key,&#123;type:TEXT, content: newVNode.text&#125;)</div><div class="line">            &#125;</div><div class="line">        &#125; else if(newVNode.nodeType===1)&#123;</div><div class="line">            if(oldVNode.tag === newVNode.tag &amp;&amp; oldVNode.key == newVNode.key)&#123;</div><div class="line">                var propPatches = diffProps(oldVNode.props, newVNode.props)</div><div class="line">                if(Object.keys(propPatches).length&gt;0)&#123;</div><div class="line">                    addDirectives(newVNode.key,&#123;type:PROP, content: propPatches&#125;)</div><div class="line">                &#125;</div><div class="line">                if(oldVNode.children || newVNode.children)</div><div class="line">                    diffChildren(oldVNode.children,newVNode.children,newVNode.key)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return directives</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是比较节点属性的方法，对于有变化的属性我们将变化的部分记在patches这个数组里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps,newProps</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> patches=&#123;&#125;</div><div class="line">    <span class="keyword">if</span>(oldProps)&#123;</div><div class="line">        <span class="built_in">Object</span>.keys(oldProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">            <span class="keyword">if</span>(prop === <span class="string">'style'</span> &amp;&amp; newProps[prop])&#123;</div><div class="line">                <span class="keyword">let</span> newStyle = newProps[prop]</div><div class="line">                <span class="keyword">let</span> isSame = <span class="literal">true</span></div><div class="line">                <span class="built_in">Object</span>.keys(oldProps[prop]).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(prop[item] !== newStyle[item])&#123;</div><div class="line">                        isSame = <span class="literal">false</span></div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                <span class="keyword">if</span>(isSame)&#123;</div><div class="line">                    <span class="built_in">Object</span>.keys(newStyle).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                        <span class="keyword">if</span>(!prop.hasOwnProperty(item))&#123;</div><div class="line">                            isSame = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!isSame)</div><div class="line">                    patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(newProps[prop] !== oldProps[prop])&#123;</div><div class="line">                patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newProps)&#123;</div><div class="line">       <span class="built_in">Object</span>.keys(newProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!oldProps.hasOwnProperty(prop))&#123;</div><div class="line">            patches[prop] = newProps[prop]</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> patches</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是比较子节点的方法，子节点的更新分为增加子节点，删除子节点和移动子节点三种操作。对于子节点的操作将被记录在父节点的directives上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildren,newChildren,parentKey</span>)</span>&#123;</div><div class="line">    oldChildren = oldChildren || []</div><div class="line">    newChildren = newChildren || []</div><div class="line">    <span class="keyword">let</span> movedItem = []</div><div class="line">    <span class="keyword">let</span> oldKeyIndexObject = parseNodeList(oldChildren)</div><div class="line">    <span class="keyword">let</span> newKeyIndexObject = parseNodeList(newChildren)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> newKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(!oldKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            addDirectives(parentKey,&#123;<span class="attr">type</span>:INSERT,<span class="attr">index</span>:newKeyIndexObject[key],<span class="attr">node</span>:newChildren[newKeyIndexObject[key]]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(newKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            <span class="keyword">if</span>(oldKeyIndexObject[key] !== newKeyIndexObject[key])&#123;</div><div class="line">                <span class="keyword">let</span> moveObj = &#123;<span class="string">'oldIndex'</span>:oldKeyIndexObject[key],<span class="string">'newIndex'</span>:newKeyIndexObject[key]&#125;</div><div class="line">                movedItem[newKeyIndexObject[key]] = oldKeyIndexObject[key]</div><div class="line">            &#125;</div><div class="line">            diffVNode(oldChildren[oldKeyIndexObject[key]],newChildren[newKeyIndexObject[key]])</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            addDirectives(key,&#123;<span class="attr">type</span>:REMOVE,<span class="attr">index</span>:oldKeyIndexObject[key]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(movedItem.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        addDirectives(parentKey,&#123;<span class="attr">type</span>:MOVE, <span class="attr">moved</span>:movedItem&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在经过Diff方法后，我们将得到我们传入的oldNode与newNode的比较结果，并记录在Directives对象中。</p>
<h4 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h4><p>Patch主要做的是通过我们之前的比较得到的Directives对象来修改Dom树。在Patch方法中如果该节点涉及到更新，将会调用applyPatch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node,directives</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(node)&#123;</div><div class="line">        <span class="keyword">var</span> orderList = []</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> node.childNodes)&#123;</div><div class="line"></div><div class="line">            patch(child,directives)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(directives[node.key])&#123;</div><div class="line">            applyPatch(node,directives[node.key])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>applyPatch方法主要对具体的Dom节点进行修改。根据directives的不同类型，调用不同的方法进行更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatch</span>(<span class="params">node, directives</span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> directive <span class="keyword">of</span> directives)&#123;</div><div class="line">        <span class="keyword">switch</span> (directive.type)&#123;</div><div class="line">            <span class="keyword">case</span> TEXT:</div><div class="line">                setContent(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> PROP:</div><div class="line">                setProps(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> REMOVE:</div><div class="line">                removeNode(node)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> INSERT:</div><div class="line">                insertNode(node,directive.node,directive.index)</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的更新方法是通过js来操作DOM节点进行操作。</p>
<p>推荐一个找vue,angular组件的 <a href="http://www.wheelsfactory.cn/#/" target="_blank" rel="external">轮子工厂</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/HTML 5.2 有哪些新内容？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/HTML 5.2 有哪些新内容？/" itemprop="url">HTML 5.2 有哪些新内容？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T20:38:11+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>就在不到一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。</p>
<p>在 REC 阶段有个原则叫做“任何新事物都至少要有两种独立的实现”，这对于我们 web 开发者来说是一个实践新特性的绝佳机会。</p>
<p>在 HTML 5.2 中有一些添加和删除，具体改变可以参考官方的 HTML 5.2 变动内容网页。本文将介绍一些我认为与我的开发有关的改动。</p>
<h4 id="原生的dialog元素"><a href="#原生的dialog元素" class="headerlink" title="原生的dialog元素"></a>原生的dialog元素</h4><p>在 HTML 5.2 的所有改动中，最让我激动的就是关于dialog元素这个原生对话框的介绍。在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。<br>新的dialog元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。<br>由一个dialog&gt; 元素创建对话框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div></pre></td></tr></table></figure>
<p>默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">open</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"open"</span>&gt;</span>Open Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>Close Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></div><div class="line"><span class="javascript"><span class="keyword">const</span> dialog = <span class="built_in">document</span>.getElementById(<span class="string">"dialog"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"open"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.show();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"close"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.close();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>目前，Chrome 浏览器已经支持dialog元素，Firefox 也即将支持（behind a flag）。<br><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fde4350f53d00?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>上图为 caniuse.com 关于 dialog 特性主流浏览器兼容情况的数据</p>
<h4 id="在iFrame-中使用-Payment-Request-API（支付请求-API）"><a href="#在iFrame-中使用-Payment-Request-API（支付请求-API）" class="headerlink" title="在iFrame 中使用 Payment Request API（支付请求 API）"></a>在iFrame 中使用 Payment Request API（支付请求 API）</h4><p>Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。<br>在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。<br>为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">allowpaymentrequest</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="苹果的图标尺寸"><a href="#苹果的图标尺寸" class="headerlink" title="苹果的图标尺寸"></a>苹果的图标尺寸</h4><p>如要定义网页图标，我们可以在文档的 head 中使用link rel=”icon”元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"16x16"</span> <span class="attr">href</span>=<span class="string">"path/to/icon16.png"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"32x32"</span> <span class="attr">href</span>=<span class="string">"path/to/icon32.png"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。<br>在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。<br>在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。</p>
<h4 id="多个main元素"><a href="#多个main元素" class="headerlink" title="多个main元素"></a>多个main元素</h4><p>main元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但main元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main元素在 DOM 中必须唯一才能令页面有效。<br>随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个main 元素，但在任意时刻只能给用户展示其中的一个。<br>使用 HTML 5.2，我们只要保证同一时刻只有一个main元素可见，就能在我们的标签中使用多个main元素。与此同时其它的main元素必须使用 hidden 属性进行隐藏。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的main元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。</p>
<h4 id="在body中写样式"><a href="#在body中写样式" class="headerlink" title="在body中写样式"></a>在body中写样式</h4><p>一般来说，使用style元素定义的内联 CSS 样式会放置在 HTML 文档的head中。随着组件化开发的流行，开发者已经发现编写 style 并放置在与其相关的 html 中更加有益。<br>在 HTML 5.2 中，可以在 HTML 文档body内的任何地方定义内联style样式块。这意味着样式定义可以离它们被使用的地方更近。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">        <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: cornflowerblue; &#125;</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然而仍需注意的是，由于性能问题，样式还是应当优先考虑放在head中。参见 规范，</p>
<p>样式元素最好用于文档的 head 中。在文档的 body 中使用样式可能导致重复定义样式，触发重布局、导致重绘，因此需要小心使用。</p>
<p>此外还应该注意的是如示例所示，样式不存在作用域。后来在 HTML 文档中定义的内联样式仍然会应用于之前定义的元素，所以它可能会触发重绘。</p>
<h4 id="legend中的标题元素"><a href="#legend中的标题元素" class="headerlink" title="legend中的标题元素"></a>legend中的标题元素</h4><p>在表单中，legend元素表示fieldset表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Basic Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for basic information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Contact Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for contact information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。</p>
<h4 id="在HTML-5-2-中移除了一些元素，具体为："><a href="#在HTML-5-2-中移除了一些元素，具体为：" class="headerlink" title="在HTML 5.2 中移除了一些元素，具体为："></a>在HTML 5.2 中移除了一些元素，具体为：</h4><p>keygen：曾经用于帮助表单生成公钥<br>menu 与 menuitem：曾经用于创建导航与内容菜单</p>
<h4 id="在p中不再能包含行内、浮动、块类型的子元素"><a href="#在p中不再能包含行内、浮动、块类型的子元素" class="headerlink" title="在p中不再能包含行内、浮动、块类型的子元素"></a>在p中不再能包含行内、浮动、块类型的子元素</h4><p>在 HTML 5.2 中，p元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签p 内：<br>行内块（Inline blocks）<br>行内表格（Inline tables）<br>浮动块与固定位置块</p>
<h4 id="不再支持严格文档类型（Strict-Doctypes）"><a href="#不再支持严格文档类型（Strict-Doctypes）" class="headerlink" title="不再支持严格文档类型（Strict Doctypes）"></a>不再支持严格文档类型（Strict Doctypes）</h4><p>最后，我们终于可以和这些文档类型说再见了！<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span>  </div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/2017前端技术梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/2017前端技术梳理/" itemprop="url">2017前端技术梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T21:16:06+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>JavaScript<br>CoffeeScript<br>TypeScript<br>Material design<br>WebAssembly</p>
<h3 id="前端标准-规范"><a href="#前端标准-规范" class="headerlink" title="前端标准/规范"></a>前端标准/规范</h3><p>HTTP/1.1<br>HTTP/2<br>HTTPS<br>W3C<br>ECMAScript<br>Commonjs<br>AMD (RequireJs)<br>CMD (Seajs)<br>UMD (UMD)<br>Yslow-23<br>OOCSS<br>SMACSS<br>BEM<br><a href="http://alloyteam.github.io/code-guide/" target="_blank" rel="external">Code Guide</a><br><a href="http://segmentfault.com/a/1190000000388784/" target="_blank" rel="external">编写可维护的CSS</a><br><a href="http://alloyteam.github.io/JX/doc/specification/google-javascript.xml" target="_blank" rel="external">GJS编码规范指南</a><br><a href="http://contribute.jquery.org/style-guide/js/" target="_blank" rel="external">jQuery规范</a></p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>Sublime Text<br>webStorm<br>Atom<br>Vim<br>Emacs<br>Dreamweaver<br>Eclipse<br>WebStorm</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>Developer Tools<br>Firebug<br>IETest<br>Chrome Dev Tools</p>
<h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>Git<br>SVN<br>GitHub<br>SourceForge<br><a href="http://mercurial.selenic.com/" target="_blank" rel="external">Mercurial(Hg)</a></p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>Trident = IE<br>Blink/prev.Webkit = Chrome<br>Gecko = Firefox<br>WebKit = Safari<br>Blink/Pre.Presto = Opera<br>EdgeHTML = Edge</p>
<h3 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h3><p>JScript = IE8-/Asp<br>Chakra = IE9/Edge<br>V8 = Chrome/Opera/Nodejs/MongoDb<br>SpoderMonkey = Firefox<br>Nitro = Safari</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>JQuery<br>Backbone<br>JSDoc<br>Prototype<br>Zepto<br>Polymer<br>MooTool<br>Polyfill<br>Shim<br>Immutable<br>Lodash<br>RxJS</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Babel<br>React<br>Redux<br>Vue<br>VueX<br>Isomorphic JavaScript<br>Incremental DOM<br>Virtual Dom<br><a href="http://www.angularjs.org" target="_blank" rel="external">AngularJs</a><br><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone</a><br><a href="http://ampersandjs.com/" target="_blank" rel="external">AmpersandJS</a><br><a href="http://knockoutjs.com/" target="_blank" rel="external">Knockout</a><br><a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a></p>
<h3 id="代码质量-质量控制"><a href="#代码质量-质量控制" class="headerlink" title="代码质量/质量控制"></a>代码质量/质量控制</h3><p>Qunit<br>Jasmine<br>UnitJs<br>Mocha<br>Should<br>Chai<br>Expect</p>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p><a href="http://www.embeddedjs.com/" target="_blank" rel="external">EJS</a><br><a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebars</a><br><a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a><br><a href="http://velocity.apache.org/" target="_blank" rel="external">Velocity</a></p>
<h3 id="布局框架"><a href="#布局框架" class="headerlink" title="布局框架"></a>布局框架</h3><p><a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap</a><br><a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a><br><a href="http://www.getuikit.com/" target="_blank" rel="external">Uikit</a><br><a href="http://css-tricks.com/modular-future-web-components//" target="_blank" rel="external">Web Components</a></p>
<h3 id="构建工具及包管理器"><a href="#构建工具及包管理器" class="headerlink" title="构建工具及包管理器"></a>构建工具及包管理器</h3><p>Browserify<br>Gulp<br><a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a><br><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a><br><a href="http://bower.io/" target="_blank" rel="external">Bower</a><br><a href="https://www.npmjs.org/" target="_blank" rel="external">NPM</a><br>Webpack<br>JSlint<br>JSHint<br>Jscs<br>Csslint<br>Postcss<br>Compression<br>Minification</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p><a href="http://pivotal.github.io/jasmine/" target="_blank" rel="external">Jasmine</a><br><a href="http://qunitjs.com/" target="_blank" rel="external">QUnit</a><br><a href="http://visionmedia.github.io/mocha/" target="_blank" rel="external">Mocha</a><br><a href="http://expressjs.com/" target="_blank" rel="external">Express</a></p>
<h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="external">Normalize.css</a><br><a href="http://www.lesscss.net/" target="_blank" rel="external">LESS</a><br><a href="http://www.oocss.cc/ http://oocss.org/" target="_blank" rel="external">OOCSS</a><br><a href="http://www.cssreset.com/" target="_blank" rel="external">CssReset</a><br>Stylus</p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p><a href="http://lesscss.org/" target="_blank" rel="external">Less</a><br><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a><br>Stylus</p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p><a href="http://d3js.org/" target="_blank" rel="external">D3.js</a><br>ECharts<br>Processing<br>Recline.js<br>Dygraphs.js<br>InfoVis<br>The Google Visualization API<br>Springy.js<br>Polymaps.js<br>Dimple<br>Sigma.js<br>Raphael.js<br>Graphaël<br>Leaflet<br>Ember Charts<br><a href="http://kineticjs.com/" target="_blank" rel="external">KINETIC</a></p>
<h3 id="WebGL库"><a href="#WebGL库" class="headerlink" title="WebGL库"></a>WebGL库</h3><p>Three.js<br>Phaser.js<br>Pixi.js<br>Plotly.js<br>Two.js<br>Babylon.js<br>Deck.gl<br>Mapbox-gl-js</p>
<h3 id="模块加载器"><a href="#模块加载器" class="headerlink" title="模块加载器"></a>模块加载器</h3><p><a href="https://github.com/ecomfe/esl" target="_blank" rel="external">ESL</a><br><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a><br><a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS</a></p>
<h3 id="调试工具-1"><a href="#调试工具-1" class="headerlink" title="调试工具"></a>调试工具</h3><p>Tern<br>Babel<br><a href="https://developers.google.com/chrome-developer-tools/" target="_blank" rel="external">Chrome</a><br><a href="https://getfirebug.com/" target="_blank" rel="external">Firebug</a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HTTPWatch</a><br><a href="http://www.telerik.com/fiddler" target="_blank" rel="external">Fiddler</a><br>IE Developer Toolbar<br><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="external">Weinre</a><br>ESLint</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Adsafe<br>Caja<br>Sandbox<br>同源策略<br>CSP 内容安全策略<br>白名单机制<br>CSRF<br>XSS 跨站请求伪造/跨站脚本攻击</p>
<h3 id="文档输出"><a href="#文档输出" class="headerlink" title="文档输出"></a>文档输出</h3><p>Dox<br>Doxmate<br>Grunt-doxmate</p>
<h3 id="压缩合并"><a href="#压缩合并" class="headerlink" title="压缩合并"></a>压缩合并</h3><p>CleanCss<br>UglifyJS<br>Google Clousure Complier<br>YUI Compressor</p>
<h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><p><a href="http://nodejs.org/" target="_blank" rel="external">Node</a><br><a href="http://httpd.apache.org/" target="_blank" rel="external">Apache</a><br><a href="http://nginx.org/" target="_blank" rel="external">Nginx</a></p>
<h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p><a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">Google Page Speed</a><br><a href="https://developers.google.com/web-toolkit/speedtracer/?hl=zh-CN" target="_blank" rel="external">Google Speed Tracer  </a><br><a href="http://yslow.org/" target="_blank" rel="external">Yahoo Yslow </a><br><a href="http://fiddler2.com/" target="_blank" rel="external">Fiddler </a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HttpWatch </a><br><a href="http://www.ieinspector.com/" target="_blank" rel="external">HTTP Analyzer</a></p>
<h3 id="服务器监控"><a href="#服务器监控" class="headerlink" title="服务器监控"></a>服务器监控</h3><p><a href="http://www.nagios.org/" target="_blank" rel="external">Nagios</a><br><a href="http://www.cacti.net/" target="_blank" rel="external">Cacti</a></p>
<h3 id="辅助应用"><a href="#辅助应用" class="headerlink" title="辅助应用"></a>辅助应用</h3><p>Fireworks<br>Paint.net<br>Photoshop<br>Paint.net<br>GIMP<br><a href="http://www.axure.com/" target="_blank" rel="external">Axure RP</a><br><a href="http://www.xmind.net/" target="_blank" rel="external">XMind</a></p>
<h3 id="社区-会议"><a href="#社区-会议" class="headerlink" title="社区/会议"></a>社区/会议</h3><p>w3c Tech<br>w3c Plus<br>w3 help<br>div.io<br>nedeParty<br>alloyteam<br>html5基地<br>segmentfault会议<br>深js<br>杭js<br>沪js<br>CMIC<br>D2<br>webrebuild<br>Qcon<br>velocity<br>CSSConf<br>HybridApp<br>html5 梦工厂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/Java串口通信工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/Java串口通信工具类/" itemprop="url">Java串口通信工具类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T21:45:37+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><blockquote>
<p>Jar，Source，Doc包文件下载：<a href="http://pan.baidu.com/s/1nvwTpqT" target="_blank" rel="external">http://pan.baidu.com/s/1nvwTpqT</a><br>RXTX官网：<a href="http://rxtx.qbang.org/wiki/index.php/Using_RXTX" target="_blank" rel="external">http://rxtx.qbang.org/wiki/index.php/Using_RXTX</a></p>
</blockquote>
<h3 id="安装RXTX"><a href="#安装RXTX" class="headerlink" title="安装RXTX"></a>安装RXTX</h3><p>假设JDK路径如下:<br>c:\Program Files\Java\jre1.6.0_01\<br>复制 rxtxParallel.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 rxtxSerial.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 RXTXcomm.jar 到 c:\Program Files\Java\jre1.6.0_01\lib\ext\<br>注意: 如果在windows xp系统上安装还需要crtdll.dll，C运行时组件，自行去下载</p>
<h3 id="引入Jar包SerialPortHelper-1-0-jar"><a href="#引入Jar包SerialPortHelper-1-0-jar" class="headerlink" title="引入Jar包SerialPortHelper-1.0.jar"></a>引入Jar包SerialPortHelper-1.0.jar</h3><p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xdemo.utils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SerialPortHelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="编写回调类"><a href="#编写回调类" class="headerlink" title="编写回调类"></a>编写回调类</h3><p>继承 AbstractReadCallback ，在call方法中，获取输入流输入的内容，用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.utils.serial.demo;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> gnu.io.SerialPortEvent;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Timer;</div><div class="line"><span class="keyword">import</span> java.util.TimerTask;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.AbstractReadCallback;</div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.SerialPortHelper;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * DEMO，获取串口输出</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2017年6月20日 上午9:32:23</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadCallback</span> <span class="keyword">extends</span> <span class="title">AbstractReadCallback</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(BufferedReader reader, InputStream is)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">               方式一：</span></div><div class="line"><span class="comment">               char[] buff=new char[1024];</span></div><div class="line"><span class="comment">                reader.read(buff);</span></div><div class="line"><span class="comment">                String c=new String(buff).trim();</span></div><div class="line"><span class="comment">                addResult(c);</span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">               方式二：</span></div><div class="line"><span class="comment">               String result = reader.readLine();</span></div><div class="line"><span class="comment">                addResult(result.trim());</span></div><div class="line"><span class="comment">                </span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">             */</span></div><div class="line">             </div><div class="line">            <span class="comment">//方式三 对于一些乱码的情况，需要进行字符集转换</span></div><div class="line">             </div><div class="line">            String result=reader.readLine();</div><div class="line">            result=<span class="keyword">new</span> String(result.getBytes(<span class="string">"GBK"</span>),<span class="string">"GBK"</span>);<span class="comment">//编码根据实际场景而定</span></div><div class="line">            addResult(result);</div><div class="line">             </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(SerialPortEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"出错了,错误类型:\t"</span>+event.getEventType());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//连续输出的，一般不需要发送命令，直接就是接受</span></div><div class="line">        <span class="keyword">final</span> SerialPortHelper sp=<span class="keyword">new</span> SerialPortHelper();</div><div class="line">        sp.open(<span class="string">"C:\\serial.config.properties"</span>);</div><div class="line">         </div><div class="line">        <span class="comment">//如果需要发送命令的</span></div><div class="line">        <span class="comment">//sp.write("P");</span></div><div class="line">         </div><div class="line">        <span class="comment">//如果需要不停的发送，可以使用#Timer,每隔1秒发送一次</span></div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                sp.write(<span class="string">"P"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">         </div><div class="line">        MyReadCallback callback=<span class="keyword">new</span> MyReadCallback();</div><div class="line">        sp.read(callback, Charset.forName(<span class="string">"UTF-8"</span>));</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">            System.out.println(callback.getResult());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="配置文件，参考如下"><a href="#配置文件，参考如下" class="headerlink" title="配置文件，参考如下"></a>配置文件，参考如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#端口号</div><div class="line">PORT=COM5</div><div class="line">#波特率</div><div class="line">BAUD_RATE=9600</div><div class="line">#奇偶校验   NONE:0,ODD:1,EVEN:2,MARK:3,SPACE:4</div><div class="line">PARITY_BIT=0</div><div class="line">#数据位        5,6,7,8</div><div class="line">DATA_BIT=8</div><div class="line">#停止位        1:1,2:2,1.5:3</div><div class="line">STOP_BIT=1</div><div class="line">#字符编码</div><div class="line">CHARSET=UTF-8</div></pre></td></tr></table></figure>
<blockquote>
<p>转自：<a href="http://www.xdemo.org/java-serial-port/" target="_blank" rel="external">http://www.xdemo.org/java-serial-port/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/20171022140737.png"
                alt="hanx" />
            
              <p class="site-author-name" itemprop="name">hanx</p>
              <p class="site-description motion-element" itemprop="description">向死而生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    ❤
  </span>
  <span class="author" itemprop="copyrightHolder">hanx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  1052685403@qq.com




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
