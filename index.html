<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="hanx の 碎片栈" type="application/atom+xml" />






<meta name="description" content="向死而生">
<meta property="og:type" content="website">
<meta property="og:title" content="hanx の 碎片栈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="hanx の 碎片栈">
<meta property="og:description" content="向死而生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hanx の 碎片栈">
<meta name="twitter:description" content="向死而生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e7cd7543c04aa55f06761709bc920324";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  <link rel="canonical" href="http://yoursite.com/"/>





  <title>hanx の 碎片栈</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hanx の 碎片栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Time waits for no one</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/Virtual DOM的简单实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/Virtual DOM的简单实现/" itemprop="url">Virtual DOM的简单实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T23:16:06+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在看vue的源码时了解了vue关于Virtual DOM的一些想法,Virtual DOM可以帮助我们更高效的操作DOM。它通过实现一个vnode的js对象，vnode的对象与dom的node对象是一一对应的，通过我们对vnode的操作可以实现对dom的操作，这样就可以避免频繁的dom操作带来的效率问题。vue的Virtual DOM实现了一套高效的diff算法来快速的比对更新dom树。</p>
<h4 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h4><p>首先，创建vnode的对象，vnode记录相应的DOM对象的一些属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span> (tag, nodeType,key, props, text, children)&#123;</div><div class="line">        <span class="keyword">this</span>.tag = tag <span class="comment">//element类型</span></div><div class="line">        <span class="keyword">this</span>.nodeType = nodeType <span class="comment">//node类型，1为普通节点，3为文本节点，8为注释</span></div><div class="line">        <span class="keyword">this</span>.key = key</div><div class="line">        <span class="keyword">this</span>.props = props <span class="comment">//node的属性</span></div><div class="line">        <span class="keyword">this</span>.text = text <span class="comment">//文本节点的内容</span></div><div class="line">        <span class="keyword">this</span>.children = children<span class="comment">//子节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将vnode渲染成DOM节点的方法</span></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">var</span> el</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">1</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tag)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="keyword">this</span>.props)&#123;</div><div class="line">                setAttr(el,prop,<span class="keyword">this</span>.props[prop])</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.children)&#123;</div><div class="line">                <span class="keyword">this</span>.children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ch,i</span>)</span>&#123;</div><div class="line">                    el.appendChild(ch.render())</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">3</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.text)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">8</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createComment(<span class="keyword">this</span>.text)</div><div class="line">        &#125;</div><div class="line">        el.key = <span class="keyword">this</span>.key</div><div class="line">        <span class="keyword">return</span> el</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttr</span>(<span class="params">node,key,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(key===<span class="string">'style'</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">in</span> value)&#123;</div><div class="line">            node.style[val] = value[val]</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        node.setAttribute(key,value)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h4><p>diff主要是用来对比新旧vnode的区别，找出区别的元素并记录在directives对象上，便于接下来可以通过directives的内容对旧的vnode进行替换，绘制新的DOM.</p>
<p>这是diff的入口方法，参数是旧的vnode和新的vnode,directives是用来记录每个节点的改变情况的对象。<br><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export default function diff(oldVNode, newVNode)&#123;</div><div class="line">    directives = &#123;&#125;</div><div class="line">    diffVNode(oldVNode,newVNode,directives)</div><div class="line">    return directives</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在diff方法中调用diffVNode来对节点进行逐一比较。首先，它会比较oldVNode和newVNode是否是相同的节点。如果相同，就对节点类型进行判断，来选择比较的方法，对于文本和注释节点，只需要比较文本内容是否相同即可，对于元素则要比较元素标签，元素的属性以及子元素是否相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function diffVNode(oldVNode,newVNode)&#123;</div><div class="line"></div><div class="line">    if(newVNode &amp;&amp; isSameTypeNode(oldVNode,newVNode))&#123;</div><div class="line">        if(newVNode.nodeType===3 || newVNode.nodeType===8)&#123;</div><div class="line">            if(oldVNode.text !== newVNode.text)&#123;</div><div class="line">                addDirectives(newVNode.key,&#123;type:TEXT, content: newVNode.text&#125;)</div><div class="line">            &#125;</div><div class="line">        &#125; else if(newVNode.nodeType===1)&#123;</div><div class="line">            if(oldVNode.tag === newVNode.tag &amp;&amp; oldVNode.key == newVNode.key)&#123;</div><div class="line">                var propPatches = diffProps(oldVNode.props, newVNode.props)</div><div class="line">                if(Object.keys(propPatches).length&gt;0)&#123;</div><div class="line">                    addDirectives(newVNode.key,&#123;type:PROP, content: propPatches&#125;)</div><div class="line">                &#125;</div><div class="line">                if(oldVNode.children || newVNode.children)</div><div class="line">                    diffChildren(oldVNode.children,newVNode.children,newVNode.key)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return directives</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是比较节点属性的方法，对于有变化的属性我们将变化的部分记在patches这个数组里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps,newProps</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> patches=&#123;&#125;</div><div class="line">    <span class="keyword">if</span>(oldProps)&#123;</div><div class="line">        <span class="built_in">Object</span>.keys(oldProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">            <span class="keyword">if</span>(prop === <span class="string">'style'</span> &amp;&amp; newProps[prop])&#123;</div><div class="line">                <span class="keyword">let</span> newStyle = newProps[prop]</div><div class="line">                <span class="keyword">let</span> isSame = <span class="literal">true</span></div><div class="line">                <span class="built_in">Object</span>.keys(oldProps[prop]).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(prop[item] !== newStyle[item])&#123;</div><div class="line">                        isSame = <span class="literal">false</span></div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                <span class="keyword">if</span>(isSame)&#123;</div><div class="line">                    <span class="built_in">Object</span>.keys(newStyle).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                        <span class="keyword">if</span>(!prop.hasOwnProperty(item))&#123;</div><div class="line">                            isSame = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!isSame)</div><div class="line">                    patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(newProps[prop] !== oldProps[prop])&#123;</div><div class="line">                patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newProps)&#123;</div><div class="line">       <span class="built_in">Object</span>.keys(newProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!oldProps.hasOwnProperty(prop))&#123;</div><div class="line">            patches[prop] = newProps[prop]</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> patches</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是比较子节点的方法，子节点的更新分为增加子节点，删除子节点和移动子节点三种操作。对于子节点的操作将被记录在父节点的directives上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildren,newChildren,parentKey</span>)</span>&#123;</div><div class="line">    oldChildren = oldChildren || []</div><div class="line">    newChildren = newChildren || []</div><div class="line">    <span class="keyword">let</span> movedItem = []</div><div class="line">    <span class="keyword">let</span> oldKeyIndexObject = parseNodeList(oldChildren)</div><div class="line">    <span class="keyword">let</span> newKeyIndexObject = parseNodeList(newChildren)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> newKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(!oldKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            addDirectives(parentKey,&#123;<span class="attr">type</span>:INSERT,<span class="attr">index</span>:newKeyIndexObject[key],<span class="attr">node</span>:newChildren[newKeyIndexObject[key]]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(newKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            <span class="keyword">if</span>(oldKeyIndexObject[key] !== newKeyIndexObject[key])&#123;</div><div class="line">                <span class="keyword">let</span> moveObj = &#123;<span class="string">'oldIndex'</span>:oldKeyIndexObject[key],<span class="string">'newIndex'</span>:newKeyIndexObject[key]&#125;</div><div class="line">                movedItem[newKeyIndexObject[key]] = oldKeyIndexObject[key]</div><div class="line">            &#125;</div><div class="line">            diffVNode(oldChildren[oldKeyIndexObject[key]],newChildren[newKeyIndexObject[key]])</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            addDirectives(key,&#123;<span class="attr">type</span>:REMOVE,<span class="attr">index</span>:oldKeyIndexObject[key]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(movedItem.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        addDirectives(parentKey,&#123;<span class="attr">type</span>:MOVE, <span class="attr">moved</span>:movedItem&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在经过Diff方法后，我们将得到我们传入的oldNode与newNode的比较结果，并记录在Directives对象中。</p>
<h4 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h4><p>Patch主要做的是通过我们之前的比较得到的Directives对象来修改Dom树。在Patch方法中如果该节点涉及到更新，将会调用applyPatch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node,directives</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(node)&#123;</div><div class="line">        <span class="keyword">var</span> orderList = []</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> node.childNodes)&#123;</div><div class="line"></div><div class="line">            patch(child,directives)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(directives[node.key])&#123;</div><div class="line">            applyPatch(node,directives[node.key])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>applyPatch方法主要对具体的Dom节点进行修改。根据directives的不同类型，调用不同的方法进行更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatch</span>(<span class="params">node, directives</span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> directive <span class="keyword">of</span> directives)&#123;</div><div class="line">        <span class="keyword">switch</span> (directive.type)&#123;</div><div class="line">            <span class="keyword">case</span> TEXT:</div><div class="line">                setContent(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> PROP:</div><div class="line">                setProps(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> REMOVE:</div><div class="line">                removeNode(node)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> INSERT:</div><div class="line">                insertNode(node,directive.node,directive.index)</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的更新方法是通过js来操作DOM节点进行操作。</p>
<p>推荐一个找vue,angular组件的 <a href="http://www.wheelsfactory.cn/#/" target="_blank" rel="external">轮子工厂</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/HTML 5.2 有哪些新内容？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/HTML 5.2 有哪些新内容？/" itemprop="url">HTML 5.2 有哪些新内容？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T20:38:11+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>就在不到一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。</p>
<p>在 REC 阶段有个原则叫做“任何新事物都至少要有两种独立的实现”，这对于我们 web 开发者来说是一个实践新特性的绝佳机会。</p>
<p>在 HTML 5.2 中有一些添加和删除，具体改变可以参考官方的 HTML 5.2 变动内容网页。本文将介绍一些我认为与我的开发有关的改动。</p>
<h4 id="原生的dialog元素"><a href="#原生的dialog元素" class="headerlink" title="原生的dialog元素"></a>原生的dialog元素</h4><p>在 HTML 5.2 的所有改动中，最让我激动的就是关于dialog元素这个原生对话框的介绍。在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。<br>新的dialog元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。<br>由一个dialog&gt; 元素创建对话框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div></pre></td></tr></table></figure>
<p>默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">open</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"open"</span>&gt;</span>Open Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>Close Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></div><div class="line"><span class="javascript"><span class="keyword">const</span> dialog = <span class="built_in">document</span>.getElementById(<span class="string">"dialog"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"open"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.show();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"close"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.close();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>目前，Chrome 浏览器已经支持dialog元素，Firefox 也即将支持（behind a flag）。<br><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fde4350f53d00?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>上图为 caniuse.com 关于 dialog 特性主流浏览器兼容情况的数据</p>
<h4 id="在iFrame-中使用-Payment-Request-API（支付请求-API）"><a href="#在iFrame-中使用-Payment-Request-API（支付请求-API）" class="headerlink" title="在iFrame 中使用 Payment Request API（支付请求 API）"></a>在iFrame 中使用 Payment Request API（支付请求 API）</h4><p>Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。<br>在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。<br>为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">allowpaymentrequest</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="苹果的图标尺寸"><a href="#苹果的图标尺寸" class="headerlink" title="苹果的图标尺寸"></a>苹果的图标尺寸</h4><p>如要定义网页图标，我们可以在文档的 head 中使用link rel=”icon”元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"16x16"</span> <span class="attr">href</span>=<span class="string">"path/to/icon16.png"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"32x32"</span> <span class="attr">href</span>=<span class="string">"path/to/icon32.png"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。<br>在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。<br>在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。</p>
<h4 id="多个main元素"><a href="#多个main元素" class="headerlink" title="多个main元素"></a>多个main元素</h4><p>main元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但main元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main元素在 DOM 中必须唯一才能令页面有效。<br>随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个main 元素，但在任意时刻只能给用户展示其中的一个。<br>使用 HTML 5.2，我们只要保证同一时刻只有一个main元素可见，就能在我们的标签中使用多个main元素。与此同时其它的main元素必须使用 hidden 属性进行隐藏。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的main元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。</p>
<h4 id="在body中写样式"><a href="#在body中写样式" class="headerlink" title="在body中写样式"></a>在body中写样式</h4><p>一般来说，使用style元素定义的内联 CSS 样式会放置在 HTML 文档的head中。随着组件化开发的流行，开发者已经发现编写 style 并放置在与其相关的 html 中更加有益。<br>在 HTML 5.2 中，可以在 HTML 文档body内的任何地方定义内联style样式块。这意味着样式定义可以离它们被使用的地方更近。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">        <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: cornflowerblue; &#125;</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然而仍需注意的是，由于性能问题，样式还是应当优先考虑放在head中。参见 规范，</p>
<p>样式元素最好用于文档的 head 中。在文档的 body 中使用样式可能导致重复定义样式，触发重布局、导致重绘，因此需要小心使用。</p>
<p>此外还应该注意的是如示例所示，样式不存在作用域。后来在 HTML 文档中定义的内联样式仍然会应用于之前定义的元素，所以它可能会触发重绘。</p>
<h4 id="legend中的标题元素"><a href="#legend中的标题元素" class="headerlink" title="legend中的标题元素"></a>legend中的标题元素</h4><p>在表单中，legend元素表示fieldset表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Basic Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for basic information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Contact Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for contact information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。</p>
<h4 id="在HTML-5-2-中移除了一些元素，具体为："><a href="#在HTML-5-2-中移除了一些元素，具体为：" class="headerlink" title="在HTML 5.2 中移除了一些元素，具体为："></a>在HTML 5.2 中移除了一些元素，具体为：</h4><p>keygen：曾经用于帮助表单生成公钥<br>menu 与 menuitem：曾经用于创建导航与内容菜单</p>
<h4 id="在p中不再能包含行内、浮动、块类型的子元素"><a href="#在p中不再能包含行内、浮动、块类型的子元素" class="headerlink" title="在p中不再能包含行内、浮动、块类型的子元素"></a>在p中不再能包含行内、浮动、块类型的子元素</h4><p>在 HTML 5.2 中，p元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签p 内：<br>行内块（Inline blocks）<br>行内表格（Inline tables）<br>浮动块与固定位置块</p>
<h4 id="不再支持严格文档类型（Strict-Doctypes）"><a href="#不再支持严格文档类型（Strict-Doctypes）" class="headerlink" title="不再支持严格文档类型（Strict Doctypes）"></a>不再支持严格文档类型（Strict Doctypes）</h4><p>最后，我们终于可以和这些文档类型说再见了！<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span>  </div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/2017前端技术梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/2017前端技术梳理/" itemprop="url">2017前端技术梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T21:16:06+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>JavaScript<br>CoffeeScript<br>TypeScript<br>Material design<br>WebAssembly</p>
<h3 id="前端标准-规范"><a href="#前端标准-规范" class="headerlink" title="前端标准/规范"></a>前端标准/规范</h3><p>HTTP/1.1<br>HTTP/2<br>HTTPS<br>W3C<br>ECMAScript<br>Commonjs<br>AMD (RequireJs)<br>CMD (Seajs)<br>UMD (UMD)<br>Yslow-23<br>OOCSS<br>SMACSS<br>BEM<br><a href="http://alloyteam.github.io/code-guide/" target="_blank" rel="external">Code Guide</a><br><a href="http://segmentfault.com/a/1190000000388784/" target="_blank" rel="external">编写可维护的CSS</a><br><a href="http://alloyteam.github.io/JX/doc/specification/google-javascript.xml" target="_blank" rel="external">GJS编码规范指南</a><br><a href="http://contribute.jquery.org/style-guide/js/" target="_blank" rel="external">jQuery规范</a></p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>Sublime Text<br>webStorm<br>Atom<br>Vim<br>Emacs<br>Dreamweaver<br>Eclipse<br>WebStorm</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>Developer Tools<br>Firebug<br>IETest<br>Chrome Dev Tools</p>
<h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>Git<br>SVN<br>GitHub<br>SourceForge<br><a href="http://mercurial.selenic.com/" target="_blank" rel="external">Mercurial(Hg)</a></p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>Trident = IE<br>Blink/prev.Webkit = Chrome<br>Gecko = Firefox<br>WebKit = Safari<br>Blink/Pre.Presto = Opera<br>EdgeHTML = Edge</p>
<h3 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h3><p>JScript = IE8-/Asp<br>Chakra = IE9/Edge<br>V8 = Chrome/Opera/Nodejs/MongoDb<br>SpoderMonkey = Firefox<br>Nitro = Safari</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>JQuery<br>Backbone<br>JSDoc<br>Prototype<br>Zepto<br>Polymer<br>MooTool<br>Polyfill<br>Shim<br>Immutable<br>Lodash<br>RxJS</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Babel<br>React<br>Redux<br>Vue<br>VueX<br>Isomorphic JavaScript<br>Incremental DOM<br>Virtual Dom<br><a href="http://www.angularjs.org" target="_blank" rel="external">AngularJs</a><br><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone</a><br><a href="http://ampersandjs.com/" target="_blank" rel="external">AmpersandJS</a><br><a href="http://knockoutjs.com/" target="_blank" rel="external">Knockout</a><br><a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a></p>
<h3 id="代码质量-质量控制"><a href="#代码质量-质量控制" class="headerlink" title="代码质量/质量控制"></a>代码质量/质量控制</h3><p>Qunit<br>Jasmine<br>UnitJs<br>Mocha<br>Should<br>Chai<br>Expect</p>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p><a href="http://www.embeddedjs.com/" target="_blank" rel="external">EJS</a><br><a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebars</a><br><a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a><br><a href="http://velocity.apache.org/" target="_blank" rel="external">Velocity</a></p>
<h3 id="布局框架"><a href="#布局框架" class="headerlink" title="布局框架"></a>布局框架</h3><p><a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap</a><br><a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a><br><a href="http://www.getuikit.com/" target="_blank" rel="external">Uikit</a><br><a href="http://css-tricks.com/modular-future-web-components//" target="_blank" rel="external">Web Components</a></p>
<h3 id="构建工具及包管理器"><a href="#构建工具及包管理器" class="headerlink" title="构建工具及包管理器"></a>构建工具及包管理器</h3><p>Browserify<br>Gulp<br><a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a><br><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a><br><a href="http://bower.io/" target="_blank" rel="external">Bower</a><br><a href="https://www.npmjs.org/" target="_blank" rel="external">NPM</a><br>Webpack<br>JSlint<br>JSHint<br>Jscs<br>Csslint<br>Postcss<br>Compression<br>Minification</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p><a href="http://pivotal.github.io/jasmine/" target="_blank" rel="external">Jasmine</a><br><a href="http://qunitjs.com/" target="_blank" rel="external">QUnit</a><br><a href="http://visionmedia.github.io/mocha/" target="_blank" rel="external">Mocha</a><br><a href="http://expressjs.com/" target="_blank" rel="external">Express</a></p>
<h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="external">Normalize.css</a><br><a href="http://www.lesscss.net/" target="_blank" rel="external">LESS</a><br><a href="http://www.oocss.cc/ http://oocss.org/" target="_blank" rel="external">OOCSS</a><br><a href="http://www.cssreset.com/" target="_blank" rel="external">CssReset</a><br>Stylus</p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p><a href="http://lesscss.org/" target="_blank" rel="external">Less</a><br><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a><br>Stylus</p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p><a href="http://d3js.org/" target="_blank" rel="external">D3.js</a><br>ECharts<br>Processing<br>Recline.js<br>Dygraphs.js<br>InfoVis<br>The Google Visualization API<br>Springy.js<br>Polymaps.js<br>Dimple<br>Sigma.js<br>Raphael.js<br>Graphaël<br>Leaflet<br>Ember Charts<br><a href="http://kineticjs.com/" target="_blank" rel="external">KINETIC</a></p>
<h3 id="WebGL库"><a href="#WebGL库" class="headerlink" title="WebGL库"></a>WebGL库</h3><p>Three.js<br>Phaser.js<br>Pixi.js<br>Plotly.js<br>Two.js<br>Babylon.js<br>Deck.gl<br>Mapbox-gl-js</p>
<h3 id="模块加载器"><a href="#模块加载器" class="headerlink" title="模块加载器"></a>模块加载器</h3><p><a href="https://github.com/ecomfe/esl" target="_blank" rel="external">ESL</a><br><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a><br><a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS</a></p>
<h3 id="调试工具-1"><a href="#调试工具-1" class="headerlink" title="调试工具"></a>调试工具</h3><p>Tern<br>Babel<br><a href="https://developers.google.com/chrome-developer-tools/" target="_blank" rel="external">Chrome</a><br><a href="https://getfirebug.com/" target="_blank" rel="external">Firebug</a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HTTPWatch</a><br><a href="http://www.telerik.com/fiddler" target="_blank" rel="external">Fiddler</a><br>IE Developer Toolbar<br><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="external">Weinre</a><br>ESLint</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Adsafe<br>Caja<br>Sandbox<br>同源策略<br>CSP 内容安全策略<br>白名单机制<br>CSRF<br>XSS 跨站请求伪造/跨站脚本攻击</p>
<h3 id="文档输出"><a href="#文档输出" class="headerlink" title="文档输出"></a>文档输出</h3><p>Dox<br>Doxmate<br>Grunt-doxmate</p>
<h3 id="压缩合并"><a href="#压缩合并" class="headerlink" title="压缩合并"></a>压缩合并</h3><p>CleanCss<br>UglifyJS<br>Google Clousure Complier<br>YUI Compressor</p>
<h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><p><a href="http://nodejs.org/" target="_blank" rel="external">Node</a><br><a href="http://httpd.apache.org/" target="_blank" rel="external">Apache</a><br><a href="http://nginx.org/" target="_blank" rel="external">Nginx</a></p>
<h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p><a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">Google Page Speed</a><br><a href="https://developers.google.com/web-toolkit/speedtracer/?hl=zh-CN" target="_blank" rel="external">Google Speed Tracer  </a><br><a href="http://yslow.org/" target="_blank" rel="external">Yahoo Yslow </a><br><a href="http://fiddler2.com/" target="_blank" rel="external">Fiddler </a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HttpWatch </a><br><a href="http://www.ieinspector.com/" target="_blank" rel="external">HTTP Analyzer</a></p>
<h3 id="服务器监控"><a href="#服务器监控" class="headerlink" title="服务器监控"></a>服务器监控</h3><p><a href="http://www.nagios.org/" target="_blank" rel="external">Nagios</a><br><a href="http://www.cacti.net/" target="_blank" rel="external">Cacti</a></p>
<h3 id="辅助应用"><a href="#辅助应用" class="headerlink" title="辅助应用"></a>辅助应用</h3><p>Fireworks<br>Paint.net<br>Photoshop<br>Paint.net<br>GIMP<br><a href="http://www.axure.com/" target="_blank" rel="external">Axure RP</a><br><a href="http://www.xmind.net/" target="_blank" rel="external">XMind</a></p>
<h3 id="社区-会议"><a href="#社区-会议" class="headerlink" title="社区/会议"></a>社区/会议</h3><p>w3c Tech<br>w3c Plus<br>w3 help<br>div.io<br>nedeParty<br>alloyteam<br>html5基地<br>segmentfault会议<br>深js<br>杭js<br>沪js<br>CMIC<br>D2<br>webrebuild<br>Qcon<br>velocity<br>CSSConf<br>HybridApp<br>html5 梦工厂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/Java串口通信工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/Java串口通信工具类/" itemprop="url">Java串口通信工具类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T21:45:37+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><blockquote>
<p>Jar，Source，Doc包文件下载：<a href="http://pan.baidu.com/s/1nvwTpqT" target="_blank" rel="external">http://pan.baidu.com/s/1nvwTpqT</a><br>RXTX官网：<a href="http://rxtx.qbang.org/wiki/index.php/Using_RXTX" target="_blank" rel="external">http://rxtx.qbang.org/wiki/index.php/Using_RXTX</a></p>
</blockquote>
<h3 id="安装RXTX"><a href="#安装RXTX" class="headerlink" title="安装RXTX"></a>安装RXTX</h3><p>假设JDK路径如下:<br>c:\Program Files\Java\jre1.6.0_01\<br>复制 rxtxParallel.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 rxtxSerial.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 RXTXcomm.jar 到 c:\Program Files\Java\jre1.6.0_01\lib\ext\<br>注意: 如果在windows xp系统上安装还需要crtdll.dll，C运行时组件，自行去下载</p>
<h3 id="引入Jar包SerialPortHelper-1-0-jar"><a href="#引入Jar包SerialPortHelper-1-0-jar" class="headerlink" title="引入Jar包SerialPortHelper-1.0.jar"></a>引入Jar包SerialPortHelper-1.0.jar</h3><p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xdemo.utils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SerialPortHelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="编写回调类"><a href="#编写回调类" class="headerlink" title="编写回调类"></a>编写回调类</h3><p>继承 AbstractReadCallback ，在call方法中，获取输入流输入的内容，用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.utils.serial.demo;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> gnu.io.SerialPortEvent;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Timer;</div><div class="line"><span class="keyword">import</span> java.util.TimerTask;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.AbstractReadCallback;</div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.SerialPortHelper;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * DEMO，获取串口输出</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2017年6月20日 上午9:32:23</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadCallback</span> <span class="keyword">extends</span> <span class="title">AbstractReadCallback</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(BufferedReader reader, InputStream is)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">               方式一：</span></div><div class="line"><span class="comment">               char[] buff=new char[1024];</span></div><div class="line"><span class="comment">                reader.read(buff);</span></div><div class="line"><span class="comment">                String c=new String(buff).trim();</span></div><div class="line"><span class="comment">                addResult(c);</span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">               方式二：</span></div><div class="line"><span class="comment">               String result = reader.readLine();</span></div><div class="line"><span class="comment">                addResult(result.trim());</span></div><div class="line"><span class="comment">                </span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">             */</span></div><div class="line">             </div><div class="line">            <span class="comment">//方式三 对于一些乱码的情况，需要进行字符集转换</span></div><div class="line">             </div><div class="line">            String result=reader.readLine();</div><div class="line">            result=<span class="keyword">new</span> String(result.getBytes(<span class="string">"GBK"</span>),<span class="string">"GBK"</span>);<span class="comment">//编码根据实际场景而定</span></div><div class="line">            addResult(result);</div><div class="line">             </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(SerialPortEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"出错了,错误类型:\t"</span>+event.getEventType());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//连续输出的，一般不需要发送命令，直接就是接受</span></div><div class="line">        <span class="keyword">final</span> SerialPortHelper sp=<span class="keyword">new</span> SerialPortHelper();</div><div class="line">        sp.open(<span class="string">"C:\\serial.config.properties"</span>);</div><div class="line">         </div><div class="line">        <span class="comment">//如果需要发送命令的</span></div><div class="line">        <span class="comment">//sp.write("P");</span></div><div class="line">         </div><div class="line">        <span class="comment">//如果需要不停的发送，可以使用#Timer,每隔1秒发送一次</span></div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                sp.write(<span class="string">"P"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">         </div><div class="line">        MyReadCallback callback=<span class="keyword">new</span> MyReadCallback();</div><div class="line">        sp.read(callback, Charset.forName(<span class="string">"UTF-8"</span>));</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">            System.out.println(callback.getResult());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="配置文件，参考如下"><a href="#配置文件，参考如下" class="headerlink" title="配置文件，参考如下"></a>配置文件，参考如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#端口号</div><div class="line">PORT=COM5</div><div class="line">#波特率</div><div class="line">BAUD_RATE=9600</div><div class="line">#奇偶校验   NONE:0,ODD:1,EVEN:2,MARK:3,SPACE:4</div><div class="line">PARITY_BIT=0</div><div class="line">#数据位        5,6,7,8</div><div class="line">DATA_BIT=8</div><div class="line">#停止位        1:1,2:2,1.5:3</div><div class="line">STOP_BIT=1</div><div class="line">#字符编码</div><div class="line">CHARSET=UTF-8</div></pre></td></tr></table></figure>
<blockquote>
<p>转自：<a href="http://www.xdemo.org/java-serial-port/" target="_blank" rel="external">http://www.xdemo.org/java-serial-port/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/09/前端需要了解的 SSO 与 CAS 知识 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/前端需要了解的 SSO 与 CAS 知识 /" itemprop="url">前端需要了解的 SSO 与 CAS 知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T09:26:50+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不管是什么公司，只要产品数量大于一个，那么单点登录势必是绕不过去的一个问题。作为前端程序员，我们对其虽然接触不多，但适当的了解还是必要的。本文就来谈谈单点登录相关的问题。<br>前置知识<br>了解 SSO，最好具备以下知识。当然，如果不是特别熟，也不影响阅读。</p>
<p>cookie及session<br>浏览器同源策略及跨域<br>了解登录系统的构成<br>什么是 SSO 与 CAS?</p>
<h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO 是英文 Single Sign On 的缩写，翻译过来就是单点登录。顾名思义，它把两个及以上个产品中的用户登录逻辑抽离出来，达到只输入一次用户名密码，就能同时登录多个产品的效果。<br>使用 SSO 的优点很明显：<br>提升用户体验。就以我厂为例。我厂有两个产品，丁香人才网和丁香园论坛，假如你是我厂用户，肯定无法忍受登录丁香园论坛的时候输入一次用户名密码，登录人才网又要输入一次用户名密码吧？<br>避免重复开发。假如你是我厂后端，每天任务都饱和的不行，肯定无法忍受到人才网开发一套登录逻辑，到论坛又开发一套登录逻辑吧？<br>提升安全系数<br>假如你是我厂运维，发现了一个安全隐患需要紧急修复。你肯定无法忍受给茫茫多的产品后端都发一封邮件，责令修复吧？万一漏了一个呢？ </p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段。两者是抽象与具体的关系。当然，除了 CAS 之外，实现 SSO 还有其他手段，比如简单的 cookie。CAS （Central Authentication Service）中心授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0称为代理模式，适用于存在非 Web 应用之间的单点登录。<br>同域 SSO如图，同域 SSO 是最简单的一种情况。此时，两个产品都是在一个域名下，单点登录是很自然的选择。我们来捋一捋步骤，搞清楚这里的步骤是理解后文的基础，千万不要跳过。<br>用户访问产品 a，向 后台服务器发送登录请求。<br>登录认证成功，服务器把用户的登录信息写入 session。<br>服务器为该用户生成一个 cookie，并加入到 response header 中，随着请求返回而写入浏览器。<br>该 cookie 的域设定为 dxy.cn。<br>下一次，当用户访问同域名的产品 b 时，由于 a 和 b 在同一域名下，也是 dxy.cn，浏览器会自动带上之前的 cookie。此时后台服务器就可以通过该 cookie 来验证登录状态了。<br>实际上，这种场景就是最简单最传统的登录操作。虽然我们把产品 a 和 b 人为分开了，但由于它们在同域上，就算看成是同一产品的不同类目也未尝不可。我们没有设置独立的 SSO 服务器，因为业务后台服务器本身就足以承担 SSO 的职能。<br>同父域 SSO<br>同父域 SSO 是同域 SSO 的简单升级，唯一的不同在于，服务器在返回 cookie 的时候，要把cookie 的 domain 设置为其父域。比如两个产品的地址分别为 a.dxy.cn 和 b.dxy.cn，那么 cookie 的域设置为 dxy.cn 即可。在访问 a 和 b 时，这个 cookie 都能发送到服务器，本质上和同域 SSO 没有区别。<br>.跨域 SSO<br>可以看到，在上面两种情况下，我们都没有专门设置 SSO 服务器。但是当两个产品不同域时，cookie 无法共享，所以我们必须设置独立的 SSO 服务器了。这个时候，我们就是通过标准的 CAS 方案来实现 SSO 的。<br>详解CAS</p>
<p>CAS 1.0 协议定义了一组术语，一组票据，一组接口。<br>术语：</p>
<p>Client：用户。<br>Server：中心服务器，也是 SSO 中负责单点登录的服务器。<br>Service：需要使用单点登录的各个服务，相当于上文中的产品 a/b。<br>/login：登录接口，用于登录到中心服务器。<br>/logout：登出接口，用于从中心服务器登出。<br>/validate：用于验证用户是否登录中心服务器。<br>/serviceValidate：用于让各个 service 验证用户是否登录中心服务器。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/03/阿里巴巴Java开发规约插件使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/03/阿里巴巴Java开发规约插件使用/" itemprop="url">阿里巴巴Java开发规约插件使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-03T00:00:20+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>就在今天 10月14日上午9：00 阿里巴巴于在杭州云栖大会《研发效能峰会》上，正式发布《阿里巴巴Java开发手册》扫描插件，该插件在扫描代码后，将不符合《手册》的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能。–两个字牛逼</p>
<p>git地址为这里写链接内容 <a href="https://github.com/alibaba/p3c" target="_blank" rel="external">https://github.com/alibaba/p3c</a></p>
<h3 id="IDea的安装方式："><a href="#IDea的安装方式：" class="headerlink" title="IDea的安装方式："></a>IDea的安装方式：</h3><p>IDEA版的插件发布到了IDEA官方仓库中(最低支持版本14.1.7，JDK1.7+)，<br>只需打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Settings &gt;&gt; Plugins &gt;&gt; Browse repositories</div></pre></td></tr></table></figure></p>
<p>输入 Alibaba 搜索一下便可以看到对应插件了，点击安装等待安装完成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2830896-cfd331e6143be5ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p>
<h3 id="Eclipse的安装方式"><a href="#Eclipse的安装方式" class="headerlink" title="Eclipse的安装方式"></a>Eclipse的安装方式</h3><p>Eclipse版插件支持4.2（Juno，JDK1.8+）及以上版本，提供Update Site，通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Help &gt;&gt; Install New Software</div></pre></td></tr></table></figure>
<p>然后输入<a href="https://p3c.alibaba.com/plugin/eclipse/update" target="_blank" rel="external">https://p3c.alibaba.com/plugin/eclipse/update</a> 即可看到安装列表，安装即可。<br>插件的更新，可以通过 Help &gt;&gt; Check for Udates 进行新版本检测。</p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p><img src="http://upload-images.jianshu.io/upload_images/2830896-1911d3bf3eaaa16f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br><img src="http://upload-images.jianshu.io/upload_images/2830896-2debd0505d66e61b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br><img src="http://upload-images.jianshu.io/upload_images/2830896-59d3710547be75a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p>
<p>还有自动提示的效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2830896-9467b7a4d9073b0c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br>可以说是非常棒了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2830896-e4a8c0354cc62ff7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/2017天猫双11，1682亿背后的阿里绝密50+技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/2017天猫双11，1682亿背后的阿里绝密50+技术/" itemprop="url">2017天猫双11，1682亿背后的阿里绝密50+技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T22:43:56+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring-Cloud概述"><a href="#Spring-Cloud概述" class="headerlink" title="Spring Cloud概述"></a>Spring Cloud概述</h3><h4 id="传统的应用"><a href="#传统的应用" class="headerlink" title="传统的应用"></a>传统的应用</h4><p>1.单体应用<br>在此之前，笔者所在公司开发Java程序，大都使用Struts、Spring、Hibernate（MyBatis）等技术框架，每一个项目都会发布一个单体应用。例如开发一个进销存系统，将会开发一个war包部署到Tomcat中，每一次需要开发新的模块或添加新功能时，都会在原来的基础上不断的添加。若干年后，这个war包不断的膨胀，程序员在进行调试时，服务器也可能需要启动半天，维护这个系统的效率极为低下。这样一个war包，涵盖了库存、销售、会员、报表等模块，如图1-1。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095718_XMPj_3665821.png" alt="图1-1 单体应用"><br>这样的单体应用隐患非常多，任何的一个bug，都有可能导致整个系统宕机。笔者印象最深刻的是，曾经有一客户在高峰期，导出一张销售明细报表（数据量较大），最终造成整个系统瘫痪，前台的销售人员无法售卖。维护这样一个系统，不仅效率极低，而且充满风险，项目组的各个成员惶惶不可终日，我们需要本质上的改变。</p>
<p>2.架构演进<br>针对以上的单体应用的问题，我们参考SOA架构，将各个模块划分独立的服务模块（war），并且使用了数据库的读写分离，架构如图1-2。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095730_JNIO_3665821.png" alt="图1-2 架构演进"><br>各个模块之间会存在相互调用的依赖关系，例如销售模块会调用会员模块的接口，为了减少各个模块之间的耦合，我们加入了企业服务总线（ESB），各模块与ESB之间的架构如图1-3所示。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095740_2lFc_3665821.png" alt="图1-2 架构演进"><br>加入ESB后，各个模块将服务发布到ESB中，它们与ESB之间使用SOAP协议进行通信。图1-2与图1-3的架构实现后，整个系统的性能有了明显的提升，各个模块的耦合度也降低了。运行了一段日子后，又出现了新的问题，由于销售终端数量的增多，销售模块明显超过其承受能力，为了保证销售前端的正常运行，我们使用了Nginx做负载均衡，请见图1-4。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095748_jOP0_3665821.png" alt="图1-3 ESB"><br>加入ESB后，各个模块将服务发布到ESB中，它们与ESB之间使用SOAP协议进行通信。图1-2与图1-3的架构实现后，整个系统的性能有了明显的提升，各个模块的耦合度也降低了。运行了一段日子后，又出现了新的问题，由于销售终端数量的增多，销售模块明显超过其承受能力，为了保证销售前端的正常运行，我们使用了Nginx做负载均衡，请见图1-4。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095748_jOP0_3665821.png" alt="图1-4 使用Nginx"><br>随着销售模块的增多，带来了许多问题，例如管理这些模块，对于运维工程师来说，是一项艰巨的任务，一旦销售模块有所修改，他们将通宵达旦进行升级。另外，企业服务总线也有可能成为性能的瓶颈，虽然目前仍未出现该问题，但我们需要未雨绸缪。</p>
<p>3.架构要求<br>从前面的架构演进可知，应用中的每一个点，都有可能成为系统的问题点。随着互联网应用的普及，在大数据、高并发的环境下，我们的系统架构需要面对更为严苛的挑战，我们需要一套新的架构，它起码能满足以下要求<br>高性能：这是应用程序的基本要求。</p>
<ul>
<li>独立性：其中一个模块出现bug或者其他问题，不可以影响其他模块或者整个应用。</li>
<li>容易扩展：应用中的每一个节点，都可以根据实际需要进行扩展。</li>
<li>便于管理：对于各个模块的资源，可以轻松进行管理、升级，减少维护成本。</li>
<li>状态监控与警报：对整个应用程序进行监控，当某一个节点出现问题时，能及时发出警报。</li>
</ul>
<p>为了能解决遇到的问题、达到以上的架构要求，我们开始研究Spring Cloud。</p>
<h4 id="微服务与Spring-Cloud"><a href="#微服务与Spring-Cloud" class="headerlink" title="微服务与Spring Cloud"></a>微服务与Spring Cloud</h4><p>1.什么是微服务<br>微服务一词来源Martin Fowler的“Microservices”一文，微服务是一种架构风格，将单体应用划分为小型的服务单元，微服务之间使用HTTP的API进行资源访问与操作。</p>
<p>在对单体应用的划分上，微服务与前面的SOA架构有点类似，但是SOA架构侧重于将每个单体应用的服务集成到ESB上，而微服务做得更加彻底，强调将整个模块变成服务组件，微服务对模块的划分粒度可能会更细。以我们前面的销售、会员模块为例，在SOA架构中，只需要将相应的服务发布到ESB容器就可以了，而在微服务架构中，这两个模块本身，将会变为一个或多个的服务组件。SOA架构与微服务架构，请见图1-5与图1-6。</p>
<p><img src="https://static.oschina.net/uploads/space/2017/0924/095758_YXOu_3665821.png" alt="图1-5 SOA架构"></p>
<p><img src="https://static.oschina.net/uploads/space/2017/0924/095810_5ep4_3665821.png" alt="图1-6 微服务架构"></p>
<p>在微服务的架构上，Martin Fowler的文章肯定了Netflix的贡献，接下来，我们了解一下Netflix OSS。</p>
<ol>
<li>关于Netflix OSS<br>Netflix是一个互联网影片提供商，在几年前，Netflix公司成立了自己的开源中心，名称为Netflix Open Source Software Center，简称Netflix OSS。这个开源组织专注于大数据、云计算方面的技术，提供了多个开源框架，这些框架包括大数据工具、构建工具、基于云平台的服务工具等。Netflix所提供的这些框架，很好的遵循微服务所推崇的理念，实现了去中心化的服务管理、服务容错等机制。</li>
</ol>
<p>3.Spring Cloud与Netflix<br>Spring Cloud并不是一个具体的框架，大家可以把它理解为一个工具箱，它提供的各类工具，可以帮助我们快速的构建分布式系统。</p>
<p>Spring Cloud的各个项目基于Spring Boot，将Netflix的多个框架进行封装，并且通过自动配置的方式将这些框架绑定到Spring的环境中，从而简化了这些框架的使用。由于Spring Boot的简便，使得我们在使用Spring Cloud时，很容易的将Netflix各个框架整合进我们的项目中。Spring Cloud下的“Spring Cloud Netflix”模块，主要封装了Netflix的以下项目：<br>Eureka：基于REST服务的分布式中间件，主要用于服务管理。</p>
<ul>
<li>Hystrix：容错框架，通过添加延迟阀值以及容错的逻辑，来帮助我们控制分布式系统间组件的交互。</li>
<li>Feign：一个REST客户端，目的是为了简化Web Service客户端的开发</li>
<li>Ribbon：负载均衡框架，在微服务集群中为各个客户端的通信提供支持，它主要实现中间层应用程序的负载均衡</li>
<li>Zuul：为微服务集群提供过代理、过滤、路由等功能。</li>
</ul>
<p>4.Spring Cloud的主要模块</p>
<p>除了Spring Cloud Netflix模块外，Spring Cloud还包括以下几个重要的模块：</p>
<ul>
<li>Spring Cloud Config：为分布式系统提供了配置服务器和配置客户端，通过对它们的配置，可以很好的管理集群中的配置文件。</li>
<li>Spring Cloud Sleuth：服务跟踪框架，可以与Zipkin、Apache HTrace和ELK等数据分析、服务跟踪系统进行整合，为服务跟踪、解决问题提供了便利。</li>
<li>Spring Cloud Stream：用于构建消息驱动微服务的框架，该框架在Spring Boot的基础上，整合了“Spring Integration”来连接消息代理中间件。</li>
<li>Spring Cloud Bus：连接RabbitMQ、Kafka等消息代理的集群消息总线。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/Java内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/Java内存模型/" itemprop="url">Java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T20:38:11+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。<br>这里的线程是指并发执行的活动实体，通信是指线程之间以何种机制来交换信息。</p>
<p>在命令式编程中，线程之间的通信机制有两种：<strong>共享内存和消息传递。</strong><br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p><strong>Java的并发采用的是共享内存模型</strong><br>Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h3 id="java内存模型三个特性"><a href="#java内存模型三个特性" class="headerlink" title="java内存模型三个特性"></a>java内存模型三个特性</h3><p>Java内存模型有三个特性：原子性、可见性、有序性。<br>这个三个特性主要体现在多线程环境下对变量的操作。这些变量包括：实例字段、静态字段、构成数组对象的元素。这些变量都保存在堆中，<br>堆是线程共享的。那么这些变量在多线程环境下就有可能出现所谓“线程不安全”的问题。 另，局部变量和方法参数是线程私有的，保存在栈中，不会出现线程安全问题。</p>
<blockquote>
<p><strong>原子性 : </strong>表明此操作是不可分割的，不可中断，要全部执行，要么全部不执行。<br>.<br><strong>可见性 : </strong>一个线程对某一共享变量修改之后，另一个线程要立即获取到修改后的结果。<br>.<br><strong>有序性 : </strong>在单线程环境下，程序永远会“有序的”执行，即：线程内表现为串行语义。</p>
</blockquote>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。</p>
<p>局部变量，方法定义参数和异常处理器参数不会在线程之间共享，不会出现线程安全问题，也不受内存模型的影响。</p>
<p><strong>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</strong></p>
<p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本</p>
<blockquote>
<p><strong>本地内存 : </strong> 是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160921182337904" alt="这里写图片描述"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<blockquote>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160921182748551" alt="这里写图片描述"></p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<p>上面也说到了，Java内存模型只是一个抽象概念，那么它在Java中具体是怎么工作的呢？为了更好的理解上Java内存模型工作方式，下面就JVM对Java内存模型的实现、硬件内存模型及它们之间的桥接做详细介绍。</p>
<h3 id="JVM对Java内存模型的实现"><a href="#JVM对Java内存模型的实现" class="headerlink" title="JVM对Java内存模型的实现"></a>JVM对Java内存模型的实现</h3><p>在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图： </p>
<p><img src="http://img.blog.csdn.net/20160921182837697" alt="这里写图片描述"></p>
<blockquote>
<p><strong>线程栈 : </strong> JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。<br>线程栈还包含了当前方法的所有本地变量信息。<strong>一个线程只能读取自己的线程栈</strong>，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。<br>所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。<br>对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p>
</blockquote>
<p>..</p>
<blockquote>
<p><strong>堆 </strong> : 堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p>
</blockquote>
<p>下图展示了调用栈和本地变量都存储在栈区，对象都存储在堆区： </p>
<p><img src="http://img.blog.csdn.net/20160921182903818" alt="这里写图片描述"></p>
<p>一个本地变量如果是原始类型，那么它会被完全存储到栈区。<br>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</p>
<p>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。<br>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</p>
<p>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。<br>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p>
<p><img src="http://img.blog.csdn.net/20160921182948601" alt="这里写图片描述"></p>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><p>不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构： </p>
<p><img src="http://img.blog.csdn.net/20160921183013570" alt="这里写图片描述"></p>
<p>不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构：<br>这里写图片描述</p>
<p>现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。</p>
<p>在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。</p>
<p>当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。</p>
<h3 id="Java内存模型和硬件架构之间的桥接"><a href="#Java内存模型和硬件架构之间的桥接" class="headerlink" title="Java内存模型和硬件架构之间的桥接"></a>Java内存模型和硬件架构之间的桥接</h3><p>正如上面讲到的，Java内存模型和硬件内存架构并不一致。硬件内存架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，当然一部分栈和堆的数据也有可能会存到CPU寄存器中，如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：<br><img src="http://img.blog.csdn.net/20160921183144995" alt="这里写图片描述"></p>
<p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：</p>
<blockquote>
<ol>
<li>共享对象对各个线程的可见性</li>
<li>共享对象的竞争现象</li>
</ol>
</blockquote>
<h4 id="共享对象的可见性"><a href="#共享对象的可见性" class="headerlink" title="共享对象的可见性"></a>共享对象的可见性</h4><p>当多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。</p>
<p>想象一下我们的共享对象存储在主存，一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。</p>
<p><img src="http://img.blog.csdn.net/20160921183218651" alt="这里写图片描述"></p>
<p>要解决共享对象可见性这个问题，我们可以使用java volatile关键字。 Java’s volatile keyword. volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。</p>
<h4 id="竞争现象"><a href="#竞争现象" class="headerlink" title="竞争现象"></a>竞争现象</h4><p>如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。</p>
<p>如下图所示，线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。</p>
<p>如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作</p>
<p><img src="http://img.blog.csdn.net/20160921183251870" alt="这里写图片描述"></p>
<p>要解决上面的问题我们可以使用java synchronized代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p>
<p><strong> volatile和synchronized区别 </strong></p>
<ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ul>
<p><strong> 对于volatile关键字，当且仅当满足以下所有条件时可使用 </strong></p>
<ul>
<li>变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<h3 id="支撑Java内存模型的基础原理"><a href="#支撑Java内存模型的基础原理" class="headerlink" title="支撑Java内存模型的基础原理"></a>支撑Java内存模型的基础原理</h3><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p>
<ul>
<li>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p><strong>数据依赖性</strong></p>
<p>如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。<br>编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。</p>
<p><strong>as-if-serial</strong></p>
<p>不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<h4 id="内存屏障（Memory-Barrier-）"><a href="#内存屏障（Memory-Barrier-）" class="headerlink" title="内存屏障（Memory Barrier ）"></a>内存屏障（Memory Barrier ）</h4><p>通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：</p>
<ul>
<li>保证特定操作的执行顺序。</li>
<li>影响某些数据（或则是某条指令的执行结果）的内存可见性。</li>
</ul>
<p>编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。<br>Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p>上面讲到的volatile是基于Memory Barrier实现的。</p>
<p>如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：</p>
<ul>
<li>一个线程写入变量a后，任何线程访问该变量都会拿到最新值。</li>
<li>在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。</li>
</ul>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。<br>在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。</p>
<p>与程序员密切相关的happens-before规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。</li>
<li>监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。</li>
<li>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</li>
<li>传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。</li>
</ul>
<p>注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/Java性能调优随记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/Java性能调优随记/" itemprop="url">Java性能调优随记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T17:41:37+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事情发生在16年了。当时系统beta版本进行上线前的性能压测时，发现进程的内存占用率会持续升高，与之而来的时，性能的接口性能的持续下降。最奇怪的是，停止压测后CPU和内存开销并没有恢复过来。记得之前发过博文，不知道怎么回事找不到了。 应其他同事的要求，回忆一下当时的定位过程，再做一个简单分享。<br>在讲述整个过程前，请大家自备两个梯子：<br>1)Java虚拟机的垃圾回收机制<br>2)jmeter的基本使用知识</p>
<p>首先下载jmeter工具，感觉是一个轻量级的性能检测工具，很好用。有基于windows 的GUI版本，也有在linux上运行的命令行版本。<br>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="external">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p>怪象简述<br>刚开始压测时，一切指标都是正常的，也达到了预期水平。<br><img src="https://yqfile.alicdn.com/d68a2baf560215bcbf654489328695c3aca91d76.png" alt="Github"><br>8小时后，性能直线下降。<br><img src="https://yqfile.alicdn.com/2824338ce1f4e454c7e46d2edf22af7f7b1efbdc.png" alt="Github"><br>停止压测后，CPU和内存，仍然居高不下。 不要小看 2.4%的内存占用，这是200多G内存的物理服务器。（后面部署方式已切换为虚拟机的部署方式）<br><img src="https://yqfile.alicdn.com/7ec0340ae5296cc1f690656974add8ea82cc0a3c.png" alt="Github"><br>定位解决<br>1) 首先命令行，看下java堆的情况：jmap -heap 24442<br>看见年老区的内存被占满了<br><img src="https://yqfile.alicdn.com/44e00eddb0bbd82e988038652c3276a52da80be1.png" alt="Github"><br>2) 继续执行命令：jsat –gcutil 24442 1000 5，<br>看见年老区 使用率 100%，同时执行了12304次 FullGC<br><img src="https://yqfile.alicdn.com/27faf3175cf3f30ca3f04b21ef88a699f7851643.png" alt="Github"><br>3）查看进程24442的线程信息： ps –mp 24442 –o THREAD,tid,time<br>发现很多线程运行了好几个小时<br><img src="https://yqfile.alicdn.com/3e4e149b1563c6bc1aec5f10ec1efbc0e6faefbd.png" alt="Github"></p>
<p>这个时候，明显怀疑有内存泄露了。<br>再执行了两个命令（时间太久，没有找到截图了）：<br>jstat -printcompilation -h3 24442<br>jmap -histo 24442</p>
<p>进一步发现，内存中某个类的实例数量和String类的实例数量，异常的多。<br>最后在排查代码，找到了具体的类 及其使用逻辑。发现是由于队列的使用不当，造成了内存泄露</p>
<p>总结<br>本项目中，因为涉及频繁的小IO，所以开发同事期望通过生产者－队列－消费者的模型，用批量IO解决频繁小IO带来的资源开销。但在使用此模型时，忘计考虑了极限状态下，生产者的输入能力远大于消费者的消费能力时，会造成队列中的数据积压，进而造成内存泄露。但又因为常规情况下不会出现 此场景，所以很难发现这个bug。<br>这个案例告诉我们：<br>1) 对于一些关键接口，开发同事可以在完成开发后，自己用Jmeter压测一下，避免问题遗留到上线前期，造成巨大风险。<br>2) Java仍然会有内存泄露的情况，使用类似数组、队列、栈等数据结构时，需要格外小心。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/vue常见问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/18/vue常见问题/" itemprop="url">Vue常见问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T13:00:06+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="active-class是哪个组件的属性？嵌套路由怎么定义？"></a>active-class是哪个组件的属性？嵌套路由怎么定义？</h4><p>vue-router模块的router-link组件。</p>
<hr>
<h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p>
<hr>
<h4 id="VUE模板的核心"><a href="#VUE模板的核心" class="headerlink" title="VUE模板的核心"></a>VUE模板的核心</h4><p>Vue.js的组件可以理解为预先定义好了行为的ViewModel类。<br>1.模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。<br>2.初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>3.接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。参数默认是单向绑定（由上至下），但也可以显式地声明为双向绑定。<br>4.方法（methods）：对数据的改动操作一般都在组件的方法内进行。可以通过v-on指令将用户输入事件和组件方法进行绑定。<br>5.生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，比如created，attached，destroyed等等。在这些钩子函数中，我们可以封装一些自定义的逻辑。和传统的MVC相比，可以理解为 Controller的逻辑被分散到了这些钩子函数中。<br>6.私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。由于全局注册资源容易导致命名冲突，一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p>
<hr>
<h4 id="SSR的实现原理"><a href="#SSR的实现原理" class="headerlink" title="SSR的实现原理"></a>SSR的实现原理</h4><p>客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最<br>后再通过<script>window.<strong>initial_state=data</script><br>将其写入网页，最后将服务端渲染好的网页返回回去。<br>接下来客户端会将vuex将写入的 initial_state__ 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。<br>说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。<br>Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。</p>
<hr>
<h4 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h4><p>脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测。<br>数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<hr>
<h4 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h4><p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，<br>作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>
<hr>
<h4 id="scss是什么？安装使用的步骤是？有哪几大特性？"><a href="#scss是什么？安装使用的步骤是？有哪几大特性？" class="headerlink" title="scss是什么？安装使用的步骤是？有哪几大特性？"></a>scss是什么？安装使用的步骤是？有哪几大特性？</h4><p>预处理css，把css当前函数编写，定义变量,嵌套。<br> 先装css-loader、node-loader、sass-loader等加载器模块，<br> 在webpack-base.config.js配置文件中加多一个拓展:extenstion，<br> 再加多一个模块：module里面test、loader</p>
<hr>
<h4 id="vue的computed、methods、watched三者区别"><a href="#vue的computed、methods、watched三者区别" class="headerlink" title="vue的computed、methods、watched三者区别"></a>vue的computed、methods、watched三者区别</h4><p>methods里面定义的函数，是需要主动调用的，而watch和computed相关的函数会自动完成调用<br>watch擅长一个数据影响多个数据<br>computed擅长一个数据受多个数据影响<br>methods不处理数据逻辑关系，只提供可调用函数</p>
<h4 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h4><p>css的预编译。<br>使用步骤：<br>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）<br>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss<br>第三步：还是在同一个文件，配置一个module属性<br>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”<br>有哪几大特性:<br>1、可以用变量，例如（$变量名称=值）；<br>2、可以用混合器，例如（）<br>3、可以嵌套</p>
<hr>
<h4 id="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"><a href="#mint-ui是什么？怎么使用？说出至少三个组件使用方法？" class="headerlink" title="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"></a>mint-ui是什么？怎么使用？说出至少三个组件使用方法？</h4><p>基于vue的前端组件库。npm安装，然后import样式和js，<br>vue.use（mintUi）全局引入。在单个组件局部引入：<br>import {Toast} from ‘mint-ui’。组件一：<br>Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper</p>
<hr>
<h4 id="v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><a href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？" class="headerlink" title="v-model是什么？怎么使用？ vue中标签怎么绑定事件？"></a>v-model是什么？怎么使用？ vue中标签怎么绑定事件？</h4><p>可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。<br>vue的model层的data属性。绑定事件：<input @click="doLog()"></p>
<hr>
<h4 id="axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><p>请求后台资源的模块。npm install axios -S装好，<br>然后发送的是跨域，需在配置文件中config/index.js进行设置。<br>后台如果是Tp5则定义一个资源路由。js中使用import进来，<br>然后.get或.post。返回在.then函数中如果成功，<br>失败则是在.catch函数中</p>
<hr>
<h4 id="axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？axios-put-‘api-user-8′-呢？"><a href="#axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？axios-put-‘api-user-8′-呢？" class="headerlink" title="axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？"></a>axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？</h4><p>跨域，添加用户操作，更新操作。</p>
<hr>
<h4 id="什么是RESTful-API？怎么使用"><a href="#什么是RESTful-API？怎么使用" class="headerlink" title="什么是RESTful API？怎么使用?"></a>什么是RESTful API？怎么使用?</h4><p>是一个api的标准，无状态请求。请求的路由地址是固定的，<br>如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete</p>
<hr>
<h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vue框架中状态管理。在main.js引入store，注入。<br>新建了一个目录store，….. export 。<br>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<hr>
<h4 id="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>一个model+view+viewModel框架，数据模型model，viewModel连接两个<br>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p>
<hr>
<h4 id="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><a href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？" class="headerlink" title="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h4><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）<br>钩子函数参数：el、binding</p>
<hr>
<h4 id="说出至少4种vue当中的指令和它的用法？"><a href="#说出至少4种vue当中的指令和它的用法？" class="headerlink" title="说出至少4种vue当中的指令和它的用法？"></a>说出至少4种vue当中的指令和它的用法？</h4><p>v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>
<hr>
<h4 id="vue-router是什么？它有哪些组件？"><a href="#vue-router是什么？它有哪些组件？" class="headerlink" title="vue-router是什么？它有哪些组件？"></a>vue-router是什么？它有哪些组件？</h4><p>vue用来写路由一个插件。router-link、router-view</p>
<hr>
<h4 id="导航钩子有哪些？它们有哪些参数？"><a href="#导航钩子有哪些？它们有哪些参数？" class="headerlink" title="导航钩子有哪些？它们有哪些参数？"></a>导航钩子有哪些？它们有哪些参数？</h4><p>导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>
<hr>
<h4 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h4><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化<br>第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。<br>ps：16题答案同样适合”vue data是怎么实现的？”此面试题。</p>
<hr>
<h4 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h4><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。<br>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。<br>更新前/后：当data变化时，会触发beforeUpdate和updated方法。<br>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<hr>
<h4 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h4><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。<br>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>
<hr>
<h4 id="你是怎么认识vuex的？"><a href="#你是怎么认识vuex的？" class="headerlink" title="你是怎么认识vuex的？"></a>你是怎么认识vuex的？</h4><p>vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p>
<hr>
<h4 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h4><p>解析.vue文件的一个加载器，跟template/js/style转换成js模块。<br>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p>
<hr>
<h4 id="请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法？</h4><p>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p>
<hr>
<h4 id="vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？"><a href="#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？" class="headerlink" title="vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？"></a>vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</h4><p>第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {<br>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’<br>第三步：注入到vue的子组件的components属性上面,components:{smithButton}<br>第四步：在template视图view中使用，<smith-button>  </smith-button><br>问题有：smithButton命名，使用的时候则smith-button。</p>
<hr>
<h4 id="聊聊你对Vue-js的template编译的理解？"><a href="#聊聊你对Vue-js的template编译的理解？" class="headerlink" title="聊聊你对Vue.js的template编译的理解？"></a>聊聊你对Vue.js的template编译的理解？</h4><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）<br>详情步骤：<br>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。<br>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>
<hr>
<h4 id="vue的组件是怎么定义的？父组件怎么给子组件传值？"><a href="#vue的组件是怎么定义的？父组件怎么给子组件传值？" class="headerlink" title="vue的组件是怎么定义的？父组件怎么给子组件传值？"></a>vue的组件是怎么定义的？父组件怎么给子组件传值？</h4><p>首先注册vue.components，第一个参数是组件名称，第二个参数是选项。<br>直接绑定一个属性，然后在子组件props里面接收</p>
<hr>
<h4 id="使用过element-ui吗？说下它其中两个组件的使用方法？"><a href="#使用过element-ui吗？说下它其中两个组件的使用方法？" class="headerlink" title="使用过element.ui吗？说下它其中两个组件的使用方法？"></a>使用过element.ui吗？说下它其中两个组件的使用方法？</h4><p>使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它<br>的间距，后面也是跟数字，也是从24份里面取的。<br>input按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default<br>（默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）</p>
<hr>
<h4 id="说下你对mvvm的理解？双向绑定的理解"><a href="#说下你对mvvm的理解？双向绑定的理解" class="headerlink" title="说下你对mvvm的理解？双向绑定的理解?"></a>说下你对mvvm的理解？双向绑定的理解?</h4><p>mvvm就是vm框架视图、m模型就是用来定义驱动的数据、v经过数据改变后的html、vm就是用来实现双向绑定<br>双向绑定:一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变</p>
<hr>
<h4 id="说出你所使用过的vue指令"><a href="#说出你所使用过的vue指令" class="headerlink" title="说出你所使用过的vue指令"></a>说出你所使用过的vue指令</h4><p>v-on（监听事件、@change、@click）<br>v-if（判断的）<br>v-show（显示/隐藏）<br>v-bind（绑定属性、:disabled、:src）</p>
<hr>
<h4 id="你觉得怎样的自定义组件是完善的？至少说出4点"><a href="#你觉得怎样的自定义组件是完善的？至少说出4点" class="headerlink" title="你觉得怎样的自定义组件是完善的？至少说出4点"></a>你觉得怎样的自定义组件是完善的？至少说出4点</h4><p>第一点、可以通用<br>第二点、代码尽量简洁<br>第三点、容易修改<br>第四点、功能要多一点 </p>
<hr>
<h4 id="请说下具体使用vue的理解？"><a href="#请说下具体使用vue的理解？" class="headerlink" title="请说下具体使用vue的理解？"></a>请说下具体使用vue的理解？</h4><p>1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。<br>2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。<br>3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。<br>4、js的代码无形的规范，团队合作开发代码可阅读性更高。</p>
<hr>
<h4 id="你觉得哪些项目适合vue框架？"><a href="#你觉得哪些项目适合vue框架？" class="headerlink" title="你觉得哪些项目适合vue框架？"></a>你觉得哪些项目适合vue框架？</h4><p>1、数据信息量比较多的，反之类似企业网站就无需此框架了。<br>2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。</p>
<hr>
<h4 id="怎么理解MVVM模式的这些框架？"><a href="#怎么理解MVVM模式的这些框架？" class="headerlink" title="怎么理解MVVM模式的这些框架？"></a>怎么理解MVVM模式的这些框架？</h4><p>1、M就是Model模型层，存的一个数据对象。<br>2、V就是View视图层，所有的html节点在这一层。<br>3、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。</p>
<hr>
<h4 id="PC端项目你会在哪些场景使用Vue框架？"><a href="#PC端项目你会在哪些场景使用Vue框架？" class="headerlink" title="PC端项目你会在哪些场景使用Vue框架？"></a>PC端项目你会在哪些场景使用Vue框架？</h4><p>上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。<br>那么vue为什么解决这些问题呢？<br>第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。<br>第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。</p>
<hr>
<h4 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<hr>
<h4 id="vuex的State特性是？"><a href="#vuex的State特性是？" class="headerlink" title="vuex的State特性是？"></a>vuex的State特性是？</h4><p>一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data<br>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<hr>
<h4 id="vuex的Getter特性是？"><a href="#vuex的Getter特性是？" class="headerlink" title="vuex的Getter特性是？"></a>vuex的Getter特性是？</h4><p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<hr>
<h4 id="vuex的Mutation特性是？"><a href="#vuex的Mutation特性是？" class="headerlink" title="vuex的Mutation特性是？"></a>vuex的Mutation特性是？</h4><p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<hr>
<h4 id="Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><a href="#Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？" class="headerlink" title="Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"></a>Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h4><p>一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。<br>二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。</p>
<hr>
<h4 id="不用Vuex会带来什么问题？"><a href="#不用Vuex会带来什么问题？" class="headerlink" title="不用Vuex会带来什么问题？"></a>不用Vuex会带来什么问题？</h4><p>一、可维护性会下降，你要想修改数据，你得维护三个地方<br>二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的<br>三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>1、什么是vue生命周期？<br> Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<hr>
<h4 id="vue生命周期的作用是什么？"><a href="#vue生命周期的作用是什么？" class="headerlink" title="vue生命周期的作用是什么？"></a>vue生命周期的作用是什么？</h4><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<hr>
<h4 id="vue生命周期总共有几个阶段？"><a href="#vue生命周期总共有几个阶段？" class="headerlink" title="vue生命周期总共有几个阶段？"></a>vue生命周期总共有几个阶段？</h4><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<hr>
<h4 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h4><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>
<hr>
<h4 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h4><p>DOM 渲染在 mounted 中就已经完成了。</p>
<hr>
<h4 id="简单描述每个周期具体适合哪些场景？"><a href="#简单描述每个周期具体适合哪些场景？" class="headerlink" title="简单描述每个周期具体适合哪些场景？"></a>简单描述每个周期具体适合哪些场景？</h4><p>生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom </p>
<hr>
<h4 id="axios的特点有哪些？"><a href="#axios的特点有哪些？" class="headerlink" title="axios的特点有哪些？"></a>axios的特点有哪些？</h4><p>一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API<br>二、它可以拦截请求和响应<br>三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据<br>四、安全性更高，客户端支持防御 XSRF</p>
<h4 id="axios有哪些常用方法？"><a href="#axios有哪些常用方法？" class="headerlink" title="axios有哪些常用方法？"></a>axios有哪些常用方法？</h4><p>一、axios.get(url[, config])   //get请求用于列表和信息查询<br>二、axios.delete(url[, config])  //删除<br>三、axios.post(url[, data[, config]])  //post请求用于信息的添加<br>四、axios.put(url[, data[, config]])  //更新操作</p>
<h4 id="axios相关配置属性？"><a href="#axios相关配置属性？" class="headerlink" title="axios相关配置属性？"></a>axios相关配置属性？</h4><p><code>url</code>是用于请求的服务器URL<br><code>method</code>是创建请求时使用的方法,默认是get<br><code>baseURL</code>将自动加在<code>url</code>前面，除非<code>url</code>是一个绝对URL。它可以通过设置一个<code>baseURL</code>便于为axios实例的方法传递相对URL<br><code>transformRequest</code>允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法<br><code>headers</code>是即将被发送的自定义请求头<br>headers:{‘X-Requested-With’:’XMLHttpRequest’},<br><code>params</code>是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象<br>params:{<br>ID:12345<br>},<br><code>auth</code>表示应该使用HTTP基础验证，并提供凭据<br>这将设置一个<code>Authorization</code>头，覆写掉现有的任意使用<code>headers</code>设置的自定义<code>Authorization</code>头<br>auth:{<br>username:’janedoe’,<br>password:’s00pers3cret’<br>},<br>‘proxy’定义代理服务器的主机名称和端口<br><code>auth</code>表示HTTP基础验证应当用于连接代理，并提供凭据<br>这将会设置一个<code>Proxy-Authorization</code>头，覆写掉已有的通过使用<code>header</code>设置的自定义<code>Proxy-Authorization</code>头。<br>proxy:{<br>host:’127.0.0.1’,<br>port:9000,<br>auth::{<br>username:’mikeymike’,<br>password:’rapunz3l’<br>}<br>},<br>keep-alive</p>
<hr>
<h4 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h4><p>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面,<br>Hash: 通过改变hash值<br>History: 利用history对象新特性</p>
<p>Hash<br>1.push()<br>功能: 设置新的路由添加历史记录并更新视图,常用情况是直接点击切换视图<br>调用流程:<br>1 $router.push() //显式调用方法<br>2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（window.location.hash= XXX）<br>3 History.transitionTo() //开始更新<br>4 History.updateRoute()  //更新路由<br>5 {app._route= route}<br>6 vm.render() //更新视图<br>2.replace<br>功能: 替换当前路由并更新视图，常用情况是地址栏直接输入新地址<br>流程与push基本一致<br>但流程2变为替换当前hash （window.location.replace= XXX）不懂此方法的可见: <a href="http://www.w3school.com.cn/jsref/met_loc_replace.asp" target="_blank" rel="external">http://www.w3school.com.cn/jsref/met_loc_replace.asp</a><br>3.监听地址栏变化<br>在setupListeners中监听hash变化(window.onhashchange)并调用replace</p>
<p>History<br>1.push<br>与hash模式类似，只是将window.hash改为history.pushState<br>2.replace<br>与hash模式类似，只是将window.replace改为history.replaceState<br>3.监听地址变化<br>在HTML5History的构造函数中监听popState（window.onpopstate）</p>
<p>两种模式对比<br>History模式的优点:<br>1.History模式的地址栏更美观。。。<br>2.History模式的pushState、replaceState参数中的新URL可为同源的任意URL（可为不同的html文件），而hash只能是同一文档<br>3.History模式的pushState、replaceState参数中的state可为js对象，能携带更多数据<br>4.History模式的pushState、replaceState参数中的title能携带字符串数据（当然，部分浏览器，例如firefox不支持title，一般title设为null，不建议使用）</p>
<p>缺点:<br>对于单页面应用来说，理想的场景是仅仅在进入应用时加载页面（例如index.html）,后续的网络操作靠ajax完成，<br>而不会重新请求页面。<br>但当用户直接在用户栏输入地址时则会重新请求，当地址带有参数时两者情况不一样<br>Hash 例如: xxx.com/#/id=5 HTTP请求不会包含后面的hash值，所以请求的仍然是 xxx.com,没有问题<br>History 例如:  xxx.com/id=5 这时请求的便是xxx.com/id=5，如后端没有配置对应id=XXX的路由处理，则会返回404错误。<br>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p>
<h4 id="vue如何实现父子组件通信，以及非父子组件通信？"><a href="#vue如何实现父子组件通信，以及非父子组件通信？" class="headerlink" title="vue如何实现父子组件通信，以及非父子组件通信？"></a>vue如何实现父子组件通信，以及非父子组件通信？</h4><p>1.父组件传递数据给子组件<br>通过props属性来实现</p>
<p>2.子组件与父组件通信<br>vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的.<br>父组件监听子组件触发的事件</p>
<p>3.非父子组件通信<br>通过eventHub来实现通信.所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件.</p>
<hr>
<h4 id="关于服务器端渲染"><a href="#关于服务器端渲染" class="headerlink" title="关于服务器端渲染"></a>关于服务器端渲染</h4><p>Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。</p>
<hr>
<h4 id="Vue状态管理"><a href="#Vue状态管理" class="headerlink" title="Vue状态管理"></a>Vue状态管理</h4><p>State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染。</p>
<hr>
<h4 id="问什么选vue原因"><a href="#问什么选vue原因" class="headerlink" title="问什么选vue原因"></a>问什么选vue原因</h4><p>当需要做一个更复杂的应用时，再增添相应的工具。例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。一个纯粹的复杂的单页应用，和只是在后端渲染的静态页面上嵌入交互内容所需要选择的工程栈其实是有相当大区别的。这就是为什么我觉得，核心+生态的栈会是一个在整体选型更为灵活的栈。</p>
<hr>
<h4 id="Vue的模板渲染"><a href="#Vue的模板渲染" class="headerlink" title="Vue的模板渲染"></a>Vue的模板渲染</h4><p>Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。<br>这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。</p>
<hr>
<h4 id="vue的模板和JSX对比"><a href="#vue的模板和JSX对比" class="headerlink" title="vue的模板和JSX对比"></a>vue的模板和JSX对比</h4><p>用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/20171022140737.png"
                alt="hanx" />
            
              <p class="site-author-name" itemprop="name">hanx</p>
              <p class="site-description motion-element" itemprop="description">向死而生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    ❤
  </span>
  <span class="author" itemprop="copyrightHolder">hanx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  1052685403@qq.com




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
