<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="JavaScript,Vue," />





  <link rel="alternate" href="/atom.xml" title="hanx の 碎片栈" type="application/atom+xml" />






<meta name="description" content="active-class是哪个组件的属性？嵌套路由怎么定义？vue-router模块的router-link组件。  怎么定义vue-router的动态路由？怎么获取传过来的动态参数？在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id  VUE模板的核心Vue.js的组件可以理解为预先定义好了行为的ViewModel类。1.模板（">
<meta name="keywords" content="JavaScript,Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue常见问题">
<meta property="og:url" content="http://yoursite.com/2017/07/18/vue常见问题/index.html">
<meta property="og:site_name" content="hanx の 碎片栈">
<meta property="og:description" content="active-class是哪个组件的属性？嵌套路由怎么定义？vue-router模块的router-link组件。  怎么定义vue-router的动态路由？怎么获取传过来的动态参数？在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id  VUE模板的核心Vue.js的组件可以理解为预先定义好了行为的ViewModel类。1.模板（">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-10T16:16:05.513Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue常见问题">
<meta name="twitter:description" content="active-class是哪个组件的属性？嵌套路由怎么定义？vue-router模块的router-link组件。  怎么定义vue-router的动态路由？怎么获取传过来的动态参数？在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id  VUE模板的核心Vue.js的组件可以理解为预先定义好了行为的ViewModel类。1.模板（">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e7cd7543c04aa55f06761709bc920324";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  <link rel="canonical" href="http://yoursite.com/2017/07/18/vue常见问题/"/>





  <title>Vue常见问题 | hanx の 碎片栈</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hanx の 碎片栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Time waits for no one</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/vue常见问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hanx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/20171022140737.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hanx の 碎片栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vue常见问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T13:00:06+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="active-class是哪个组件的属性？嵌套路由怎么定义？"></a>active-class是哪个组件的属性？嵌套路由怎么定义？</h4><p>vue-router模块的router-link组件。</p>
<hr>
<h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p>
<hr>
<h4 id="VUE模板的核心"><a href="#VUE模板的核心" class="headerlink" title="VUE模板的核心"></a>VUE模板的核心</h4><p>Vue.js的组件可以理解为预先定义好了行为的ViewModel类。<br>1.模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。<br>2.初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>3.接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。参数默认是单向绑定（由上至下），但也可以显式地声明为双向绑定。<br>4.方法（methods）：对数据的改动操作一般都在组件的方法内进行。可以通过v-on指令将用户输入事件和组件方法进行绑定。<br>5.生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，比如created，attached，destroyed等等。在这些钩子函数中，我们可以封装一些自定义的逻辑。和传统的MVC相比，可以理解为 Controller的逻辑被分散到了这些钩子函数中。<br>6.私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。由于全局注册资源容易导致命名冲突，一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p>
<hr>
<h4 id="SSR的实现原理"><a href="#SSR的实现原理" class="headerlink" title="SSR的实现原理"></a>SSR的实现原理</h4><p>客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最<br>后再通过<script>window.<strong>initial_state=data</script><br>将其写入网页，最后将服务端渲染好的网页返回回去。<br>接下来客户端会将vuex将写入的 initial_state__ 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。<br>说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。<br>Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。</p>
<hr>
<h4 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h4><p>脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测。<br>数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<hr>
<h4 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h4><p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，<br>作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>
<hr>
<h4 id="scss是什么？安装使用的步骤是？有哪几大特性？"><a href="#scss是什么？安装使用的步骤是？有哪几大特性？" class="headerlink" title="scss是什么？安装使用的步骤是？有哪几大特性？"></a>scss是什么？安装使用的步骤是？有哪几大特性？</h4><p>预处理css，把css当前函数编写，定义变量,嵌套。<br> 先装css-loader、node-loader、sass-loader等加载器模块，<br> 在webpack-base.config.js配置文件中加多一个拓展:extenstion，<br> 再加多一个模块：module里面test、loader</p>
<hr>
<h4 id="vue的computed、methods、watched三者区别"><a href="#vue的computed、methods、watched三者区别" class="headerlink" title="vue的computed、methods、watched三者区别"></a>vue的computed、methods、watched三者区别</h4><p>methods里面定义的函数，是需要主动调用的，而watch和computed相关的函数会自动完成调用<br>watch擅长一个数据影响多个数据<br>computed擅长一个数据受多个数据影响<br>methods不处理数据逻辑关系，只提供可调用函数</p>
<h4 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h4><p>css的预编译。<br>使用步骤：<br>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）<br>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss<br>第三步：还是在同一个文件，配置一个module属性<br>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”<br>有哪几大特性:<br>1、可以用变量，例如（$变量名称=值）；<br>2、可以用混合器，例如（）<br>3、可以嵌套</p>
<hr>
<h4 id="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"><a href="#mint-ui是什么？怎么使用？说出至少三个组件使用方法？" class="headerlink" title="mint-ui是什么？怎么使用？说出至少三个组件使用方法？"></a>mint-ui是什么？怎么使用？说出至少三个组件使用方法？</h4><p>基于vue的前端组件库。npm安装，然后import样式和js，<br>vue.use（mintUi）全局引入。在单个组件局部引入：<br>import {Toast} from ‘mint-ui’。组件一：<br>Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper</p>
<hr>
<h4 id="v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><a href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？" class="headerlink" title="v-model是什么？怎么使用？ vue中标签怎么绑定事件？"></a>v-model是什么？怎么使用？ vue中标签怎么绑定事件？</h4><p>可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。<br>vue的model层的data属性。绑定事件：<input @click="doLog()"></p>
<hr>
<h4 id="axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><p>请求后台资源的模块。npm install axios -S装好，<br>然后发送的是跨域，需在配置文件中config/index.js进行设置。<br>后台如果是Tp5则定义一个资源路由。js中使用import进来，<br>然后.get或.post。返回在.then函数中如果成功，<br>失败则是在.catch函数中</p>
<hr>
<h4 id="axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？axios-put-‘api-user-8′-呢？"><a href="#axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？axios-put-‘api-user-8′-呢？" class="headerlink" title="axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？"></a>axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？</h4><p>跨域，添加用户操作，更新操作。</p>
<hr>
<h4 id="什么是RESTful-API？怎么使用"><a href="#什么是RESTful-API？怎么使用" class="headerlink" title="什么是RESTful API？怎么使用?"></a>什么是RESTful API？怎么使用?</h4><p>是一个api的标准，无状态请求。请求的路由地址是固定的，<br>如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete</p>
<hr>
<h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vue框架中状态管理。在main.js引入store，注入。<br>新建了一个目录store，….. export 。<br>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<hr>
<h4 id="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>一个model+view+viewModel框架，数据模型model，viewModel连接两个<br>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p>
<hr>
<h4 id="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><a href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？" class="headerlink" title="自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h4><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）<br>钩子函数参数：el、binding</p>
<hr>
<h4 id="说出至少4种vue当中的指令和它的用法？"><a href="#说出至少4种vue当中的指令和它的用法？" class="headerlink" title="说出至少4种vue当中的指令和它的用法？"></a>说出至少4种vue当中的指令和它的用法？</h4><p>v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>
<hr>
<h4 id="vue-router是什么？它有哪些组件？"><a href="#vue-router是什么？它有哪些组件？" class="headerlink" title="vue-router是什么？它有哪些组件？"></a>vue-router是什么？它有哪些组件？</h4><p>vue用来写路由一个插件。router-link、router-view</p>
<hr>
<h4 id="导航钩子有哪些？它们有哪些参数？"><a href="#导航钩子有哪些？它们有哪些参数？" class="headerlink" title="导航钩子有哪些？它们有哪些参数？"></a>导航钩子有哪些？它们有哪些参数？</h4><p>导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>
<hr>
<h4 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h4><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化<br>第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。<br>ps：16题答案同样适合”vue data是怎么实现的？”此面试题。</p>
<hr>
<h4 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h4><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。<br>创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。<br>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。<br>更新前/后：当data变化时，会触发beforeUpdate和updated方法。<br>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<hr>
<h4 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h4><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。<br>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>
<hr>
<h4 id="你是怎么认识vuex的？"><a href="#你是怎么认识vuex的？" class="headerlink" title="你是怎么认识vuex的？"></a>你是怎么认识vuex的？</h4><p>vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p>
<hr>
<h4 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h4><p>解析.vue文件的一个加载器，跟template/js/style转换成js模块。<br>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p>
<hr>
<h4 id="请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法？</h4><p>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p>
<hr>
<h4 id="vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？"><a href="#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？" class="headerlink" title="vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？"></a>vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</h4><p>第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {<br>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’<br>第三步：注入到vue的子组件的components属性上面,components:{smithButton}<br>第四步：在template视图view中使用，<smith-button>  </smith-button><br>问题有：smithButton命名，使用的时候则smith-button。</p>
<hr>
<h4 id="聊聊你对Vue-js的template编译的理解？"><a href="#聊聊你对Vue-js的template编译的理解？" class="headerlink" title="聊聊你对Vue.js的template编译的理解？"></a>聊聊你对Vue.js的template编译的理解？</h4><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）<br>详情步骤：<br>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。<br>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>
<hr>
<h4 id="vue的组件是怎么定义的？父组件怎么给子组件传值？"><a href="#vue的组件是怎么定义的？父组件怎么给子组件传值？" class="headerlink" title="vue的组件是怎么定义的？父组件怎么给子组件传值？"></a>vue的组件是怎么定义的？父组件怎么给子组件传值？</h4><p>首先注册vue.components，第一个参数是组件名称，第二个参数是选项。<br>直接绑定一个属性，然后在子组件props里面接收</p>
<hr>
<h4 id="使用过element-ui吗？说下它其中两个组件的使用方法？"><a href="#使用过element-ui吗？说下它其中两个组件的使用方法？" class="headerlink" title="使用过element.ui吗？说下它其中两个组件的使用方法？"></a>使用过element.ui吗？说下它其中两个组件的使用方法？</h4><p>使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它<br>的间距，后面也是跟数字，也是从24份里面取的。<br>input按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default<br>（默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）</p>
<hr>
<h4 id="说下你对mvvm的理解？双向绑定的理解"><a href="#说下你对mvvm的理解？双向绑定的理解" class="headerlink" title="说下你对mvvm的理解？双向绑定的理解?"></a>说下你对mvvm的理解？双向绑定的理解?</h4><p>mvvm就是vm框架视图、m模型就是用来定义驱动的数据、v经过数据改变后的html、vm就是用来实现双向绑定<br>双向绑定:一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变</p>
<hr>
<h4 id="说出你所使用过的vue指令"><a href="#说出你所使用过的vue指令" class="headerlink" title="说出你所使用过的vue指令"></a>说出你所使用过的vue指令</h4><p>v-on（监听事件、@change、@click）<br>v-if（判断的）<br>v-show（显示/隐藏）<br>v-bind（绑定属性、:disabled、:src）</p>
<hr>
<h4 id="你觉得怎样的自定义组件是完善的？至少说出4点"><a href="#你觉得怎样的自定义组件是完善的？至少说出4点" class="headerlink" title="你觉得怎样的自定义组件是完善的？至少说出4点"></a>你觉得怎样的自定义组件是完善的？至少说出4点</h4><p>第一点、可以通用<br>第二点、代码尽量简洁<br>第三点、容易修改<br>第四点、功能要多一点 </p>
<hr>
<h4 id="请说下具体使用vue的理解？"><a href="#请说下具体使用vue的理解？" class="headerlink" title="请说下具体使用vue的理解？"></a>请说下具体使用vue的理解？</h4><p>1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。<br>2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。<br>3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。<br>4、js的代码无形的规范，团队合作开发代码可阅读性更高。</p>
<hr>
<h4 id="你觉得哪些项目适合vue框架？"><a href="#你觉得哪些项目适合vue框架？" class="headerlink" title="你觉得哪些项目适合vue框架？"></a>你觉得哪些项目适合vue框架？</h4><p>1、数据信息量比较多的，反之类似企业网站就无需此框架了。<br>2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。</p>
<hr>
<h4 id="怎么理解MVVM模式的这些框架？"><a href="#怎么理解MVVM模式的这些框架？" class="headerlink" title="怎么理解MVVM模式的这些框架？"></a>怎么理解MVVM模式的这些框架？</h4><p>1、M就是Model模型层，存的一个数据对象。<br>2、V就是View视图层，所有的html节点在这一层。<br>3、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。</p>
<hr>
<h4 id="PC端项目你会在哪些场景使用Vue框架？"><a href="#PC端项目你会在哪些场景使用Vue框架？" class="headerlink" title="PC端项目你会在哪些场景使用Vue框架？"></a>PC端项目你会在哪些场景使用Vue框架？</h4><p>上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。<br>那么vue为什么解决这些问题呢？<br>第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。<br>第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。</p>
<hr>
<h4 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<hr>
<h4 id="vuex的State特性是？"><a href="#vuex的State特性是？" class="headerlink" title="vuex的State特性是？"></a>vuex的State特性是？</h4><p>一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data<br>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<hr>
<h4 id="vuex的Getter特性是？"><a href="#vuex的Getter特性是？" class="headerlink" title="vuex的Getter特性是？"></a>vuex的Getter特性是？</h4><p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<hr>
<h4 id="vuex的Mutation特性是？"><a href="#vuex的Mutation特性是？" class="headerlink" title="vuex的Mutation特性是？"></a>vuex的Mutation特性是？</h4><p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<hr>
<h4 id="Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><a href="#Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？" class="headerlink" title="Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"></a>Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h4><p>一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。<br>二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。</p>
<hr>
<h4 id="不用Vuex会带来什么问题？"><a href="#不用Vuex会带来什么问题？" class="headerlink" title="不用Vuex会带来什么问题？"></a>不用Vuex会带来什么问题？</h4><p>一、可维护性会下降，你要想修改数据，你得维护三个地方<br>二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的<br>三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>1、什么是vue生命周期？<br> Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<hr>
<h4 id="vue生命周期的作用是什么？"><a href="#vue生命周期的作用是什么？" class="headerlink" title="vue生命周期的作用是什么？"></a>vue生命周期的作用是什么？</h4><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<hr>
<h4 id="vue生命周期总共有几个阶段？"><a href="#vue生命周期总共有几个阶段？" class="headerlink" title="vue生命周期总共有几个阶段？"></a>vue生命周期总共有几个阶段？</h4><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<hr>
<h4 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h4><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>
<hr>
<h4 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h4><p>DOM 渲染在 mounted 中就已经完成了。</p>
<hr>
<h4 id="简单描述每个周期具体适合哪些场景？"><a href="#简单描述每个周期具体适合哪些场景？" class="headerlink" title="简单描述每个周期具体适合哪些场景？"></a>简单描述每个周期具体适合哪些场景？</h4><p>生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom </p>
<hr>
<h4 id="axios的特点有哪些？"><a href="#axios的特点有哪些？" class="headerlink" title="axios的特点有哪些？"></a>axios的特点有哪些？</h4><p>一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API<br>二、它可以拦截请求和响应<br>三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据<br>四、安全性更高，客户端支持防御 XSRF</p>
<h4 id="axios有哪些常用方法？"><a href="#axios有哪些常用方法？" class="headerlink" title="axios有哪些常用方法？"></a>axios有哪些常用方法？</h4><p>一、axios.get(url[, config])   //get请求用于列表和信息查询<br>二、axios.delete(url[, config])  //删除<br>三、axios.post(url[, data[, config]])  //post请求用于信息的添加<br>四、axios.put(url[, data[, config]])  //更新操作</p>
<h4 id="axios相关配置属性？"><a href="#axios相关配置属性？" class="headerlink" title="axios相关配置属性？"></a>axios相关配置属性？</h4><p><code>url</code>是用于请求的服务器URL<br><code>method</code>是创建请求时使用的方法,默认是get<br><code>baseURL</code>将自动加在<code>url</code>前面，除非<code>url</code>是一个绝对URL。它可以通过设置一个<code>baseURL</code>便于为axios实例的方法传递相对URL<br><code>transformRequest</code>允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法<br><code>headers</code>是即将被发送的自定义请求头<br>headers:{‘X-Requested-With’:’XMLHttpRequest’},<br><code>params</code>是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象<br>params:{<br>ID:12345<br>},<br><code>auth</code>表示应该使用HTTP基础验证，并提供凭据<br>这将设置一个<code>Authorization</code>头，覆写掉现有的任意使用<code>headers</code>设置的自定义<code>Authorization</code>头<br>auth:{<br>username:’janedoe’,<br>password:’s00pers3cret’<br>},<br>‘proxy’定义代理服务器的主机名称和端口<br><code>auth</code>表示HTTP基础验证应当用于连接代理，并提供凭据<br>这将会设置一个<code>Proxy-Authorization</code>头，覆写掉已有的通过使用<code>header</code>设置的自定义<code>Proxy-Authorization</code>头。<br>proxy:{<br>host:’127.0.0.1’,<br>port:9000,<br>auth::{<br>username:’mikeymike’,<br>password:’rapunz3l’<br>}<br>},<br>keep-alive</p>
<hr>
<h4 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h4><p>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面,<br>Hash: 通过改变hash值<br>History: 利用history对象新特性</p>
<p>Hash<br>1.push()<br>功能: 设置新的路由添加历史记录并更新视图,常用情况是直接点击切换视图<br>调用流程:<br>1 $router.push() //显式调用方法<br>2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（window.location.hash= XXX）<br>3 History.transitionTo() //开始更新<br>4 History.updateRoute()  //更新路由<br>5 {app._route= route}<br>6 vm.render() //更新视图<br>2.replace<br>功能: 替换当前路由并更新视图，常用情况是地址栏直接输入新地址<br>流程与push基本一致<br>但流程2变为替换当前hash （window.location.replace= XXX）不懂此方法的可见: <a href="http://www.w3school.com.cn/jsref/met_loc_replace.asp" target="_blank" rel="external">http://www.w3school.com.cn/jsref/met_loc_replace.asp</a><br>3.监听地址栏变化<br>在setupListeners中监听hash变化(window.onhashchange)并调用replace</p>
<p>History<br>1.push<br>与hash模式类似，只是将window.hash改为history.pushState<br>2.replace<br>与hash模式类似，只是将window.replace改为history.replaceState<br>3.监听地址变化<br>在HTML5History的构造函数中监听popState（window.onpopstate）</p>
<p>两种模式对比<br>History模式的优点:<br>1.History模式的地址栏更美观。。。<br>2.History模式的pushState、replaceState参数中的新URL可为同源的任意URL（可为不同的html文件），而hash只能是同一文档<br>3.History模式的pushState、replaceState参数中的state可为js对象，能携带更多数据<br>4.History模式的pushState、replaceState参数中的title能携带字符串数据（当然，部分浏览器，例如firefox不支持title，一般title设为null，不建议使用）</p>
<p>缺点:<br>对于单页面应用来说，理想的场景是仅仅在进入应用时加载页面（例如index.html）,后续的网络操作靠ajax完成，<br>而不会重新请求页面。<br>但当用户直接在用户栏输入地址时则会重新请求，当地址带有参数时两者情况不一样<br>Hash 例如: xxx.com/#/id=5 HTTP请求不会包含后面的hash值，所以请求的仍然是 xxx.com,没有问题<br>History 例如:  xxx.com/id=5 这时请求的便是xxx.com/id=5，如后端没有配置对应id=XXX的路由处理，则会返回404错误。<br>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p>
<h4 id="vue如何实现父子组件通信，以及非父子组件通信？"><a href="#vue如何实现父子组件通信，以及非父子组件通信？" class="headerlink" title="vue如何实现父子组件通信，以及非父子组件通信？"></a>vue如何实现父子组件通信，以及非父子组件通信？</h4><p>1.父组件传递数据给子组件<br>通过props属性来实现</p>
<p>2.子组件与父组件通信<br>vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的.<br>父组件监听子组件触发的事件</p>
<p>3.非父子组件通信<br>通过eventHub来实现通信.所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件.</p>
<hr>
<h4 id="关于服务器端渲染"><a href="#关于服务器端渲染" class="headerlink" title="关于服务器端渲染"></a>关于服务器端渲染</h4><p>Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。</p>
<hr>
<h4 id="Vue状态管理"><a href="#Vue状态管理" class="headerlink" title="Vue状态管理"></a>Vue状态管理</h4><p>State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，会使State产生变化，从而导致 View 重新渲染。</p>
<hr>
<h4 id="问什么选vue原因"><a href="#问什么选vue原因" class="headerlink" title="问什么选vue原因"></a>问什么选vue原因</h4><p>当需要做一个更复杂的应用时，再增添相应的工具。例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。一个纯粹的复杂的单页应用，和只是在后端渲染的静态页面上嵌入交互内容所需要选择的工程栈其实是有相当大区别的。这就是为什么我觉得，核心+生态的栈会是一个在整体选型更为灵活的栈。</p>
<hr>
<h4 id="Vue的模板渲染"><a href="#Vue的模板渲染" class="headerlink" title="Vue的模板渲染"></a>Vue的模板渲染</h4><p>Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。这个树非常轻量，它的职责就是描述当前界面所应处的状态。当我们有了这个虚拟的树之后，再交给一个patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到的数据来源之后，之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新树与旧树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。<br>这样做的主要原因是，在浏览器当中，JavaScript的运算在现代的引擎中非常快，但DOM本身是非常缓慢的东西。当你调用原生DOM API的时候，浏览器需要在JavaScript引擎的语境下去接触原生的DOM的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实DOM的操作是最少的。</p>
<hr>
<h4 id="vue的模板和JSX对比"><a href="#vue的模板和JSX对比" class="headerlink" title="vue的模板和JSX对比"></a>vue的模板和JSX对比</h4><p>用户可以选择直接跳过模板这一层去手写渲染函数，同时也有可选JSX支持。从开发者的偏好以及开发者的效益的角度来考量，模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX和直接渲染函数，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/Vue/" rel="tag"># Vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/20/Vue2.0 指定文件不使用 ESLint 语法检查/" rel="next" title="Vue2.0 指定文件不使用 ESLint 语法检查">
                <i class="fa fa-chevron-left"></i> Vue2.0 指定文件不使用 ESLint 语法检查
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/03/Java性能调优随记/" rel="prev" title="Java性能调优随记">
                Java性能调优随记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/20171022140737.png"
                alt="hanx" />
            
              <p class="site-author-name" itemprop="name">hanx</p>
              <p class="site-description motion-element" itemprop="description">向死而生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#active-class是哪个组件的属性？嵌套路由怎么定义？"><span class="nav-number">1.</span> <span class="nav-text">active-class是哪个组件的属性？嵌套路由怎么定义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><span class="nav-number">2.</span> <span class="nav-text">怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VUE模板的核心"><span class="nav-number">3.</span> <span class="nav-text">VUE模板的核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSR的实现原理"><span class="nav-number">4.</span> <span class="nav-text">SSR的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双向绑定原理"><span class="nav-number">5.</span> <span class="nav-text">双向绑定原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-router有哪几种导航钩子？"><span class="nav-number">6.</span> <span class="nav-text">vue-router有哪几种导航钩子？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scss是什么？安装使用的步骤是？有哪几大特性？"><span class="nav-number">7.</span> <span class="nav-text">scss是什么？安装使用的步骤是？有哪几大特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue的computed、methods、watched三者区别"><span class="nav-number">8.</span> <span class="nav-text">vue的computed、methods、watched三者区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><span class="nav-number">9.</span> <span class="nav-text">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mint-ui是什么？怎么使用？说出至少三个组件使用方法？"><span class="nav-number">10.</span> <span class="nav-text">mint-ui是什么？怎么使用？说出至少三个组件使用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-model是什么？怎么使用？-vue中标签怎么绑定事件？"><span class="nav-number">11.</span> <span class="nav-text">v-model是什么？怎么使用？ vue中标签怎么绑定事件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios是什么？怎么使用？描述使用它实现登录功能的流程？"><span class="nav-number">12.</span> <span class="nav-text">axios是什么？怎么使用？描述使用它实现登录功能的流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios-tp5进阶中，调用axios-post-‘api-user’-是进行的什么操作？axios-put-‘api-user-8′-呢？"><span class="nav-number">13.</span> <span class="nav-text">axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是RESTful-API？怎么使用"><span class="nav-number">14.</span> <span class="nav-text">什么是RESTful API？怎么使用?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex是什么？怎么使用？哪种功能场景使用它？"><span class="nav-number">15.</span> <span class="nav-text">vuex是什么？怎么使用？哪种功能场景使用它？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？"><span class="nav-number">16.</span> <span class="nav-text">mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？"><span class="nav-number">17.</span> <span class="nav-text">自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#说出至少4种vue当中的指令和它的用法？"><span class="nav-number">18.</span> <span class="nav-text">说出至少4种vue当中的指令和它的用法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-router是什么？它有哪些组件？"><span class="nav-number">19.</span> <span class="nav-text">vue-router是什么？它有哪些组件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导航钩子有哪些？它们有哪些参数？"><span class="nav-number">20.</span> <span class="nav-text">导航钩子有哪些？它们有哪些参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue的双向数据绑定原理是什么？"><span class="nav-number">21.</span> <span class="nav-text">Vue的双向数据绑定原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请详细说下你对vue生命周期的理解？"><span class="nav-number">22.</span> <span class="nav-text">请详细说下你对vue生命周期的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请说下封装-vue-组件的过程？"><span class="nav-number">23.</span> <span class="nav-text">请说下封装 vue 组件的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你是怎么认识vuex的？"><span class="nav-number">24.</span> <span class="nav-text">你是怎么认识vuex的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-loader是什么？使用它的用途有哪些？"><span class="nav-number">25.</span> <span class="nav-text">vue-loader是什么？使用它的用途有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请说出vue-cli项目中src目录每个文件夹和文件的用法？"><span class="nav-number">26.</span> <span class="nav-text">请说出vue.cli项目中src目录每个文件夹和文件的用法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？"><span class="nav-number">27.</span> <span class="nav-text">vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聊聊你对Vue-js的template编译的理解？"><span class="nav-number">28.</span> <span class="nav-text">聊聊你对Vue.js的template编译的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue的组件是怎么定义的？父组件怎么给子组件传值？"><span class="nav-number">29.</span> <span class="nav-text">vue的组件是怎么定义的？父组件怎么给子组件传值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用过element-ui吗？说下它其中两个组件的使用方法？"><span class="nav-number">30.</span> <span class="nav-text">使用过element.ui吗？说下它其中两个组件的使用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#说下你对mvvm的理解？双向绑定的理解"><span class="nav-number">31.</span> <span class="nav-text">说下你对mvvm的理解？双向绑定的理解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#说出你所使用过的vue指令"><span class="nav-number">32.</span> <span class="nav-text">说出你所使用过的vue指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你觉得怎样的自定义组件是完善的？至少说出4点"><span class="nav-number">33.</span> <span class="nav-text">你觉得怎样的自定义组件是完善的？至少说出4点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请说下具体使用vue的理解？"><span class="nav-number">34.</span> <span class="nav-text">请说下具体使用vue的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你觉得哪些项目适合vue框架？"><span class="nav-number">35.</span> <span class="nav-text">你觉得哪些项目适合vue框架？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么理解MVVM模式的这些框架？"><span class="nav-number">36.</span> <span class="nav-text">怎么理解MVVM模式的这些框架？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PC端项目你会在哪些场景使用Vue框架？"><span class="nav-number">37.</span> <span class="nav-text">PC端项目你会在哪些场景使用Vue框架？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex有哪几种属性？"><span class="nav-number">38.</span> <span class="nav-text">vuex有哪几种属性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex的State特性是？"><span class="nav-number">39.</span> <span class="nav-text">vuex的State特性是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex的Getter特性是？"><span class="nav-number">40.</span> <span class="nav-text">vuex的Getter特性是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vuex的Mutation特性是？"><span class="nav-number">41.</span> <span class="nav-text">vuex的Mutation特性是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><span class="nav-number">42.</span> <span class="nav-text">Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不用Vuex会带来什么问题？"><span class="nav-number">43.</span> <span class="nav-text">不用Vuex会带来什么问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期"><span class="nav-number">44.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue生命周期的作用是什么？"><span class="nav-number">45.</span> <span class="nav-text">vue生命周期的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue生命周期总共有几个阶段？"><span class="nav-number">46.</span> <span class="nav-text">vue生命周期总共有几个阶段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第一次页面加载会触发哪几个钩子？"><span class="nav-number">47.</span> <span class="nav-text">第一次页面加载会触发哪几个钩子？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-渲染在-哪个周期中就已经完成？"><span class="nav-number">48.</span> <span class="nav-text">DOM 渲染在 哪个周期中就已经完成？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单描述每个周期具体适合哪些场景？"><span class="nav-number">49.</span> <span class="nav-text">简单描述每个周期具体适合哪些场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios的特点有哪些？"><span class="nav-number">50.</span> <span class="nav-text">axios的特点有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios有哪些常用方法？"><span class="nav-number">51.</span> <span class="nav-text">axios有哪些常用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axios相关配置属性？"><span class="nav-number">52.</span> <span class="nav-text">axios相关配置属性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue-router实现原理"><span class="nav-number">53.</span> <span class="nav-text">vue-router实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue如何实现父子组件通信，以及非父子组件通信？"><span class="nav-number">54.</span> <span class="nav-text">vue如何实现父子组件通信，以及非父子组件通信？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于服务器端渲染"><span class="nav-number">55.</span> <span class="nav-text">关于服务器端渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue状态管理"><span class="nav-number">56.</span> <span class="nav-text">Vue状态管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问什么选vue原因"><span class="nav-number">57.</span> <span class="nav-text">问什么选vue原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue的模板渲染"><span class="nav-number">58.</span> <span class="nav-text">Vue的模板渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue的模板和JSX对比"><span class="nav-number">59.</span> <span class="nav-text">vue的模板和JSX对比</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    ❤
  </span>
  <span class="author" itemprop="copyrightHolder">hanx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  1052685403@qq.com




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
